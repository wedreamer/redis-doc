***

## 标题： “Redis Streams 教程”&#xA;链接标题：“流教程”&#xA;体重： 61&#xA;描述： >&#xA;有关 Redis 流的综合教程&#xA;别名：&#xA;\- /主题/流介绍&#xA;\- /docs/manual/data-types/streams

如果您不熟悉直播，请参阅[Redis Streams 介绍](/docs/data-types/streams/).有关更全面的教程，请继续阅读。

## 介绍

Redis 流数据类型是在 Redis 5.0 中引入的。流对日志数据结构进行建模，但也实现多个操作来克服典型的仅追加日志的一些限制。这些包括O（1）时间的随机访问和复杂的消费策略，如消费者群体。

## 流基础知识

流是仅追加数据结构。基本写入命令，称为[断续器](/commands/xadd)，将新条目追加到指定的流。

每个流条目由一个或多个字段值对组成，有点像记录或 Redis 哈希：

    > XADD mystream * sensor-id 1234 temperature 19.8
    1518951480106-0

以上调用`XADD`命令添加条目`sensor-id: 1234, temperature: 19.8`到键的流`mystream`，使用自动生成的条目 ID，该 ID 是命令返回的条目 ID，特别是`1518951480106-0`.它获取键名作为其第一个参数`mystream`，则第二个参数是标识流中每个条目的条目 ID。但是，在这种情况下，我们通过了`*`因为我们希望服务器为我们生成一个新的ID。每个新 ID 都将单调增加，因此更简单地说，与所有过去的条目相比，添加的每个新条目都将具有更高的 ID。服务器自动生成 ID 几乎总是您想要的，并且显式指定 ID 的原因非常少见。我们稍后将对此进行详细讨论。每个 Stream 条目都有一个 ID 这一事实是与日志文件的另一个相似之处，其中可以使用行号或文件内的字节偏移量来标识给定条目。回到我们的`XADD`例如，在键名和 ID 之后，下一个参数是组成流条目的字段值对。

只需使用`XLEN`命令：

    > XLEN mystream
    (integer) 1

### 条目 ID

返回的条目 ID`XADD`命令，并单声地标识给定流中的每个条目，由两部分组成：

    <millisecondsTime>-<sequenceNumber>

毫秒时间部分实际上是生成流 ID 的本地 Redis 节点中的本地时间，但是，如果当前毫秒时间恰好小于上一个输入时间，则使用上一个输入时间，因此如果时钟向后跳转，则单调递增的 ID 属性仍然成立。序列号用于在同一毫秒内创建的条目。由于序列号为 64 位宽，因此实际上，在同一毫秒内可以生成的条目数没有限制。

这些ID的格式乍一看可能看起来很奇怪，温柔的读者可能会想知道为什么时间是ID的一部分。原因是 Redis 流支持按 ID 进行范围查询。由于 ID 与生成条目的时间相关，因此能够基本上免费查询时间范围。我们很快就会看到这一点，同时涵盖`XRANGE`命令。

如果由于某种原因，用户需要与时间无关但实际上与另一个外部系统 ID 关联的增量 ID，如前所述，`XADD`命令可以采用显式 ID 而不是`*`触发自动生成的通配符 ID，如以下示例所示：

    > XADD somestream 0-1 field value
    0-1
    > XADD somestream 0-2 foo bar
    0-2

请注意，在这种情况下，最小 ID 为 0-1，并且该命令不会接受等于或小于前一个 ID 的 ID：

    > XADD somestream 0-1 foo bar
    (error) ERR The ID specified in XADD is equal or smaller than the target stream top item

如果您运行的是 Redis 7 或更高版本，则还可以提供仅由毫秒部分组成的显式 ID。在这种情况下，将自动生成ID的序列部分。为此，请使用以下语法：

    > XADD somestream 0-* baz qux
    0-3

## 从流中获取数据

现在，我们终于能够通过以下方式在流中追加条目`XADD`.但是，虽然将数据追加到流中非常明显，但查询流以提取数据的方式并不那么明显。如果我们继续类比日志文件，一个明显的方法是模仿我们通常使用Unix命令执行的操作。`tail -f`，也就是说，我们可能会开始侦听，以便获取附加到流中的新消息。请注意，与 Redis 的阻止列表操作不同，在 Redis 中，给定元素将到达单个客户端，该客户端在*流行风格*操作类似`BLPOP`，对于流，我们希望多个使用者看到附加到流中的新消息（与许多用户相同的方式）`tail -f`进程可以看到添加到日志中的内容）。使用传统术语，我们希望流能够*扇出*发送到多个客户端的消息。

但是，这只是一种潜在的访问模式。我们还可以通过完全不同的方式查看流：不是作为消息传递系统，而是作为*时序存储*.在这种情况下，也许追加新消息也很有用，但另一种自然查询模式是按时间范围获取消息，或者使用游标迭代消息以增量检查所有历史记录。这绝对是另一种有用的访问模式。

最后，如果我们从消费者的角度来看一个流，我们可能希望以另一种方式访问该流，即作为可以分区为正在处理此类消息的多个消费者的消息流，以便消费者组只能看到到达单个流中的消息的子集。通过这种方式，可以在不同的使用者之间扩展消息处理，而无需单个使用者处理所有消息：每个使用者将只获取不同的消息进行处理。这基本上就是Kafka（TM）对消费者群体所做的。通过消费者组读取消息是从 Redis 流读取的另一种有趣的模式。

Redis Streams 通过不同的命令支持上述所有三种查询模式。接下来的部分将展示它们，从最简单，最直接的使用开始：范围查询。

### 按范围查询：XRANGE 和 XREVRANGE

要按范围查询流，我们只需要指定两个ID，*开始*和*结束*.返回的范围将包括将开始或结束作为 ID 的元素，因此该范围是包含性的。两个特殊 ID`-`和`+`分别表示可能的最小 ID 和最大 ID。

    > XRANGE mystream - +
    1) 1) 1518951480106-0
       2) 1) "sensor-id"
          2) "1234"
          3) "temperature"
          4) "19.8"
    2) 1) 1518951482479-0
       2) 1) "sensor-id"
          2) "9999"
          3) "temperature"
          4) "18.2"

返回的每个条目都是一个由两个项目组成的数组：ID 和字段-值对列表。我们已经说过，条目 ID 与时间有关，因为左侧的部分`-`字符是创建流条目的本地节点的 Unix 时间（以毫秒为单位），在创建该条目时（但请注意，流是使用完全指定的`XADD`命令，因此副本将与主副本具有相同的 ID）。这意味着我可以使用`XRANGE`.但是，为了做到这一点，我可能希望省略ID的序列部分：如果省略，在范围的开头，它将被假定为0，而在结束部分，它将被假定为可用的最大序列号。这样，仅使用两毫秒的Unix时间进行查询，我们就可以以一种包容的方式获得在该时间范围内生成的所有条目。例如，如果我想查询两毫秒的时间段，我可以使用：

    > XRANGE mystream 1518951480106 1518951480107
    1) 1) 1518951480106-0
       2) 1) "sensor-id"
          2) "1234"
          3) "temperature"
          4) "19.8"

我在这个范围内只有一个条目，但是在实际数据集中，我可以查询小时范围，或者在短短两毫秒内可能有很多项目，返回的结果可能是巨大的。因此，`XRANGE`支持可选**计数**选项在最后。通过指定计数，我可以只得到第一个*N*项目。如果我想要更多，我可以获取返回的最后一个ID，将序列部分递增一，然后再次查询。让我们在下面的示例中看到这一点。我们开始添加 10 个项目`XADD`（我不会显示这一点，让我们假设流`mystream`填充了 10 个项目）。为了开始我的迭代，每个命令获取 2 个项目，我从全部范围开始，但计数为 2。

    > XRANGE mystream - + COUNT 2
    1) 1) 1519073278252-0
       2) 1) "foo"
          2) "value_1"
    2) 1) 1519073279157-0
       2) 1) "foo"
          2) "value_2"

为了继续对接下来的两个项目进行迭代，我必须选择返回的最后一个ID，即`1519073279157-0`并添加前缀`(`对它。生成的独占范围间隔，即`(1519073279157-0`在这种情况下，现在可以用作新的*开始*下一个参数`XRANGE`叫：

    > XRANGE mystream (1519073279157-0 + COUNT 2
    1) 1) 1519073280281-0
       2) 1) "foo"
          2) "value_3"
    2) 1) 1519073281432-0
       2) 1) "foo"
          2) "value_4"

等等。因为`XRANGE`复杂性为*O（log（N））*寻找，然后*O（M）*返回M个元素，使用较小的计数，命令具有对数时间复杂度，这意味着迭代的每个步骤都很快。所以`XRANGE`也是事实上的*流迭代器*并且不需要**鑫灿**命令。

命令`XREVRANGE`等效于`XRANGE`但以倒序返回元素，因此实际用途为`XREVRANGE`是检查流中的最后一项是什么：

    > XREVRANGE mystream + - COUNT 1
    1) 1) 1519073287312-0
       2) 1) "foo"
          2) "value_10"

请注意，`XREVRANGE`命令采用*开始*和*停*参数的反向顺序。

## 使用 XREAD 侦听新项目

当我们不想通过流中的某个范围访问项目时，通常我们想要的是*订阅*添加到到达流的新项目。这个概念可能看起来与 Redis Pub/Sub 有关，您可以在其中订阅频道，或者与 Redis 阻止列表相关，在 Redis 阻止列表中，您等待密钥来获取新元素，但您在使用流的方式上存在根本差异：

1.  一个流可以有多个客户端（使用者）等待数据。默认情况下，每个新项目都将交付给*每个消费者*正在等待给定流中的数据。此行为与阻止列表不同，在阻止列表中，每个使用者将获得不同的元素。但是，能够*扇出*对于多个消费者类似于Pub /Sub。
2.  在发布/订阅消息中*火与忘*并且无论如何都不会存储，并且在使用阻止列表时，当客户端收到消息时，它是*弹出*（有效地删除）从列表中，流以根本不同的方式工作。所有消息都无限期地追加在流中（除非用户明确要求删除条目）：不同的使用者将通过记住最后接收消息的ID，从其角度知道什么是新消息。
3.  流使用者组提供了 Pub/Sub 或阻止列表无法实现的控制级别，同一流具有不同的组、已处理项目的显式确认、检查挂起项目的能力、未处理消息的声明以及每个客户端的一致历史记录可见性，只能查看其过去消息的私有历史记录。

提供侦听到达流的新消息的功能的命令称为`XREAD`.它比`XRANGE`，因此我们将开始显示简单的窗体，稍后将提供整个命令布局。

    > XREAD COUNT 2 STREAMS mystream 0
    1) 1) "mystream"
       2) 1) 1) 1519073278252-0
             2) 1) "foo"
                2) "value_1"
          2) 1) 1519073279157-0
             2) 1) "foo"
                2) "value_2"

以上是非阻塞形式的`XREAD`.请注意，**计数**选项不是必需的，实际上命令的唯一强制选项是**流**选项，它指定一个密钥列表以及调用使用者已为每个流看到的相应最大 ID，以便该命令将仅向客户端提供 ID 大于我们指定的 ID 的消息。

在上面的命令中，我们写了`STREAMS mystream 0`所以我们想要流中的所有消息`mystream`ID 大于`0-0`.正如您在上面的示例中看到的，该命令返回密钥名称，因为实际上可以使用多个密钥调用此命令，以便同时从不同的流中读取。例如，我可以写：`STREAMS mystream otherstream 0 0`.注意如何在**流**选项我们需要提供键名称，然后是 ID。因此，**流**选项必须始终是最后一个。

除了以下事实：`XREAD`可以一次访问多个流，并且我们能够指定我们拥有的最后一个ID来获取较新的消息，在这种简单的形式中，该命令不会执行与`XRANGE`.然而，有趣的是，我们可以转向`XREAD`进入一个*阻止命令*通过指定**块**论点：

    > XREAD BLOCK 0 STREAMS mystream $

请注意，在上面的示例中，除了删除**计数**，我指定了新的**块**超时为 0 毫秒的选项（这意味着永远不会超时）。此外，而不是传递流的正常 ID`mystream`我通过了特殊 ID`$`.此特殊 ID 表示`XREAD`应使用流中已存储的最大 ID 作为最后一个 ID`mystream`，以便我们仅接收*新增功能*消息，从我们开始收听的时间开始。这类似于`tail -f`Unix命令以某种方式。

请注意，当**块**选项是用的，我们不必使用特殊ID`$`.我们可以使用任何有效的身份证件。如果该命令能够立即满足我们的请求而不会阻塞，它将这样做，否则它将阻塞。通常，如果我们想使用从新条目开始的流，我们从ID开始`$`之后，我们继续使用收到的最后一条消息的 ID 进行下一个调用，依此类推。

阻塞形式`XREAD`还能够通过指定多个键名来侦听多个流。如果由于至少有一个流的元素大于我们指定的相应 ID 而可以同步处理请求，则它将返回结果。否则，该命令将阻止并返回获取新数据的第一个流的项目（根据指定的 ID）。

与阻止列表操作类似，阻止流读取*公平*从客户端等待数据的角度来看，由于语义是FIFO样式。当新项目可用时，阻止给定流的第一个客户端将是第一个被取消阻止的客户端。

`XREAD`没有其他选择，除了**计数**和**块**，因此它是一个非常基本的命令，具有将使用者附加到一个或多个流的特定目的。使用使用者组 API 可以获得更强大的消费流功能，但是通过使用者组进行读取是通过称为`XREADGROUP`，将在本指南的下一节中介绍。

## 消费群体

当手头的任务是使用来自不同客户端的同一流时，则`XREAD`已经提供了一种方法*扇出*到 N 个客户端，可能还会使用副本以提供更多的读取可伸缩性。但是，在某些问题中，我们想要做的不是向许多客户端提供相同的消息流，而是提供*不同的子集*从同一流到多个客户端的消息。一个明显有用的情况是处理速度慢的消息：能够让N个不同的工作线程接收流的不同部分，这使我们能够通过将不同的消息路由到准备做更多工作的不同工作线程来扩展消息处理。

实际上，如果我们想象有三个使用者 C1、C2、C3 和一个包含消息 1、2、3、4、5、6、7 的流，那么我们想要的就是根据下图提供消息：

    1 -> C1
    2 -> C2
    3 -> C3
    4 -> C1
    5 -> C2
    6 -> C3
    7 -> C1

为了实现这一点，Redis使用了一个概念，称为*消费群体*.从实现的角度来看，了解Redis消费者群体与Kafka（TM）消费者群体无关非常重要。然而，它们在功能上是相似的，所以我决定保留Kafka（TM）的术语，因为它最初普及了这个想法。

消费群体就像一个*伪消费者*从流中获取数据，并实际为多个使用者提供服务，提供某些保证：

1.  每条消息都提供给不同的使用者，因此不可能将同一消息传递给多个使用者。
2.  使用者组内由名称标识使用者，该名称是实现使用者的客户端必须选择的区分大小写的字符串。这意味着即使在断开连接后，流使用者组也会保留所有状态，因为客户端将再次声明为同一使用者。但是，这也意味着由客户端提供唯一标识符。
3.  每个消费群体都有概念*从未使用过的第一个 ID*因此，当使用者请求新消息时，它可以仅提供以前未传递的消息。
4.  但是，使用消息需要使用特定命令进行显式确认。Redis 将确认解释为：此消息已得到正确处理，因此可以从使用者组中逐出。
5.  使用者组跟踪当前挂起的所有消息，即已传递给使用者组的某个使用者但尚未确认已处理的消息。由于此功能，在访问流的消息历史记录时，每个使用者*将仅看到已传递到它的邮件*.

在某种程度上，一个消费群体可以想象成一些*状态量*关于流：

    +----------------------------------------+
    | consumer_group_name: mygroup           |
    | consumer_group_stream: somekey         |
    | last_delivered_id: 1292309234234-92    |
    |                                        |
    | consumers:                             |
    |    "consumer-1" with pending messages  |
    |       1292309234234-4                  |
    |       1292309234232-8                  |
    |    "consumer-42" with pending messages |
    |       ... (and so forth)               |
    +----------------------------------------+

如果你从这个角度来看这一点，那么很容易理解一个消费者群体可以做什么，它如何能够为消费者提供待处理消息的历史记录，以及要求新消息的消费者将如何获得大于`last_delivered_id`.同时，如果将使用者组视为 Redis 流的辅助数据结构，很明显，单个流可以有多个使用者组，这些使用者组具有不同的使用者组。实际上，同一流甚至有可能让客户端在没有消费者组的情况下读取，通过`XREAD`和客户端读取`XREADGROUP`在不同的消费群体中。

现在是时候放大以查看基本的使用者组命令了。它们如下：

*   `XGROUP`用于创建、销毁和管理消费者群体。
*   `XREADGROUP`用于通过使用者组从流中读取。
*   `XACK`是允许使用者将挂起的消息标记为已正确处理的命令。

## 创建使用者组

假设我有一把钥匙`mystream`类型流已经存在，为了创建一个消费者组，我只需要执行以下操作：

    > XGROUP CREATE mystream mygroup $
    OK

正如您在上面的命令中看到的那样，在创建使用者组时，我们必须指定一个ID，在示例中只是`$`.这是必要的，因为消费者组，在其他州中，必须知道在第一个消费者连接时下一步要提供什么消息，也就是说，什么是*上次消息 ID*当组刚刚创建时。如果我们提供`$`就像我们所做的那样，从现在开始，只有到达流中的新消息才会提供给组中的使用者。如果我们指定`0`相反，消费者组将消费*都*流历史记录中的消息开始。当然，您可以指定任何其他有效 ID。您知道的是，使用者组将开始传递大于您指定的 ID 的消息。因为`$`表示流中当前最大的 ID，指定`$`将具有仅使用新消息的效果。

`XGROUP CREATE`还支持自动创建流，如果它不存在，请使用可选`MKSTREAM`子命令作为最后一个参数：

    > XGROUP CREATE newstream mygroup $ MKSTREAM
    OK

现在，消费者组已创建，我们可以立即尝试使用`XREADGROUP`命令。我们将从消费者那里读到，我们将调用Alice和Bob，看看系统将如何向Alice或Bob返回不同的消息。

`XREADGROUP`非常相似`XREAD`并提供相同的**块**选项，否则它是同步命令。但是有一个*命令的*必须始终指定的选项，即**群**并且有两个参数：使用者组的名称，以及尝试读取的使用者的名称。选项**计数**也受支持，并且与`XREAD`.

在从流中读取之前，让我们在里面放一些消息：

    > XADD mystream * message apple
    1526569495631-0
    > XADD mystream * message orange
    1526569498055-0
    > XADD mystream * message strawberry
    1526569506935-0
    > XADD mystream * message apricot
    1526569535168-0
    > XADD mystream * message banana
    1526569544280-0

注意：*这里的消息是字段名称，水果是关联的值，请记住，流项目是小字典。*

现在是时候尝试使用消费者组阅读一些东西了：

    > XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >
    1) 1) "mystream"
       2) 1) 1) 1526569495631-0
             2) 1) "message"
                2) "apple"

`XREADGROUP`回复就像`XREAD`答复。请注意`GROUP <group-name> <consumer-name>`以上提供。它指出我想使用使用者组从流中读取`mygroup`而我是消费者`Alice`.每次使用者对使用者组执行操作时，它必须指定其名称，并在组内唯一标识此使用者。

在上面的命令行中还有另一个非常重要的细节，在强制之后**流**选项为密钥请求的 ID`mystream`是特殊 ID`>`.此特殊 ID 仅在使用者组的上下文中有效，这意味着：**到目前为止，消息从未传递给其他消费者**.

这几乎总是您想要的，但是也可以指定一个真实的ID，例如`0`或任何其他有效的身份证件，但是，在这种情况下，发生的事情是我们要求从`XREADGROUP`只是向我们提供**待处理邮件的历史记录**，并且在这种情况下，将永远不会在组中看到新邮件。所以基本上`XREADGROUP`具有以下基于我们指定的 ID 的行为：

*   如果 ID 是特殊 ID`>`那么该命令将仅返回迄今为止从未传递给其他使用者的新消息，并且作为副作用，将更新使用者组的*上一个 ID*.
*   如果 ID 是任何其他有效的数字 ID，则该命令将允许我们访问我们的*待处理邮件的历史记录*.也就是说，传递给此指定使用者（由提供的名称标识）的消息集，到目前为止从未通过`XACK`.

我们可以立即指定 ID 为 0 来测试此行为，而无需任何**计数**选项：我们只会看到唯一挂起的消息，即关于苹果的消息：

    > XREADGROUP GROUP mygroup Alice STREAMS mystream 0
    1) 1) "mystream"
       2) 1) 1) 1526569495631-0
             2) 1) "message"
                2) "apple"

但是，如果我们确认消息已处理，它将不再是挂起消息历史记录的一部分，因此系统将不再报告任何内容：

    > XACK mystream mygroup 1526569495631-0
    (integer) 1
    > XREADGROUP GROUP mygroup Alice STREAMS mystream 0
    1) 1) "mystream"
       2) (empty list or set)

如果您还不知道如何操作，请不要担心`XACK`工作，这个想法只是处理过的消息不再是我们可以访问的历史记录的一部分。

现在轮到鲍勃读点什么了：

    > XREADGROUP GROUP mygroup Bob COUNT 2 STREAMS mystream >
    1) 1) "mystream"
       2) 1) 1) 1526569498055-0
             2) 1) "message"
                2) "orange"
          2) 1) 1526569506935-0
             2) 1) "message"
                2) "strawberry"

Bob 要求最多两条消息，并且正在通过同一组进行阅读`mygroup`.所以发生的事情是，Redis报告只是*新增功能*消息。正如你所看到的，“苹果”消息没有被传递，因为它已经传递给了爱丽丝，所以鲍勃得到了橙色和草莓，依此类推。

这样，Alice、Bob 和组中的任何其他使用者都能够从同一流中读取不同的消息，读取其尚未处理消息的历史记录，或将消息标记为已处理。这允许创建不同的拓扑和语义来使用来自流的消息。

有几件事要记住：

*   消费者在第一次被提及时是自动创建的，不需要显式创建。
*   即使`XREADGROUP`您可以同时读取多个密钥，但是要使其正常工作，您需要在每个流中创建一个具有相同名称的使用者组。这不是一个常见的需求，但值得一提的是，该功能在技术上是可用的。
*   `XREADGROUP`是一个*写入命令*因为即使它从流中读取，消费者组也会作为读取的副作用进行修改，因此它只能在主实例上调用。

使用使用使用者组的使用者实现的示例可能是用 Ruby 语言编写的。Ruby代码旨在让几乎任何有经验的程序员都能阅读，即使他们不了解Ruby：

```ruby
require 'redis'

if ARGV.length == 0
    puts "Please specify a consumer name"
    exit 1
end

ConsumerName = ARGV[0]
GroupName = "mygroup"
r = Redis.new

def process_message(id,msg)
    puts "[#{ConsumerName}] #{id} = #{msg.inspect}"
end

$lastid = '0-0'

puts "Consumer #{ConsumerName} starting..."
check_backlog = true
while true
    # Pick the ID based on the iteration: the first time we want to
    # read our pending messages, in case we crashed and are recovering.
    # Once we consumed our history, we can start getting new messages.
    if check_backlog
        myid = $lastid
    else
        myid = '>'
    end

    items = r.xreadgroup('GROUP',GroupName,ConsumerName,'BLOCK','2000','COUNT','10','STREAMS',:my_stream_key,myid)

    if items == nil
        puts "Timeout!"
        next
    end

    # If we receive an empty reply, it means we were consuming our history
    # and that the history is now empty. Let's start to consume new messages.
    check_backlog = false if items[0][1].length == 0

    items[0][1].each{|i|
        id,fields = i

        # Process the message
        process_message(id,fields)

        # Acknowledge the message as processed
        r.xack(:my_stream_key,GroupName,id)

        $lastid = id
    }
end
```

如您所见，这里的想法是从使用历史记录开始，即我们的待处理消息列表。这很有用，因为使用者以前可能已经崩溃过，因此在重新启动时，我们希望重新读取传递给我们的消息，而无需确认。请注意，我们可能会多次或一次处理一条消息（至少在使用者失败的情况下，但也存在 Redis 持久性和复制所涉及的限制，请参阅有关此主题的特定部分）。

一旦历史记录被消耗，并且我们得到一个空的消息列表，我们可以切换到使用`>`使用新消息的特殊 ID。

## 从永久故障中恢复

上面的示例允许我们编写参与同一使用者组的使用者，每个使用者获取一个消息子集进行处理，并在从故障中恢复时重新读取仅传递给它们的挂起消息。然而，在现实世界中，消费者可能会永久失败，永远无法恢复。使用者的挂起消息在因任何原因停止后永远不会恢复，会发生什么情况？

Redis 使用者组提供了在这些情况下使用的功能，以便*索赔*给定使用者的挂起消息，以便此类消息将更改所有权，并将重新分配给其他使用者。该功能非常明确。使用者必须检查挂起消息的列表，并且必须使用特殊命令声明特定消息，否则服务器将使消息永远处于挂起状态并分配给旧使用者。通过这种方式，不同的应用程序可以选择是否使用此类功能，以及如何使用它。

此过程的第一步只是一个命令，该命令提供使用者组中挂起条目的可观察性，并称为`XPENDING`.
这是一个只读命令，调用它始终是安全的，不会更改任何消息的所有权。
在最简单的形式中，该命令使用两个参数调用，这两个参数是流的名称和使用者组的名称。

    > XPENDING mystream mygroup
    1) (integer) 2
    2) 1526569498055-0
    3) 1526569506935-0
    4) 1) 1) "Bob"
          2) "2"

以这种方式调用时，该命令将输出使用者组中挂起消息的总数（在本例中为两个），挂起消息中的较低和较高消息 ID，最后输出使用者列表及其拥有的挂起消息数。
我们只有 Bob 有两条挂起的消息，因为 Alice 请求的单个消息已使用`XACK`.

我们可以通过提供更多论据来要求更多信息`XPENDING`，因为完整的命令签名如下所示：

    XPENDING <key> <groupname> [[IDLE <min-idle-time>] <start-id> <end-id> <count> [<consumer-name>]]

通过提供开始和结束 ID（可以只是`-`和`+`如`XRANGE`）和一个计数来控制命令返回的信息量，我们能够更多地了解挂起的消息。如果我们想要将输出限制为给定使用者的挂起消息，但在下面的示例中不会使用此功能，则使用可选的最后一个参数（使用者名称）。

    > XPENDING mystream mygroup - + 10
    1) 1) 1526569498055-0
       2) "Bob"
       3) (integer) 74170458
       4) (integer) 1
    2) 1) 1526569506935-0
       2) "Bob"
       3) (integer) 74170458
       4) (integer) 1

现在我们有了每条消息的详细信息：ID，消费者名称，*空闲时间*以毫秒为单位，这是自上次将消息传递给某个使用者以来经过的毫秒数，以及最终传递给定消息的次数。
我们有两条来自 Bob 的消息，它们闲置了 74170458 毫秒，大约 20 个小时。

请注意，没有人阻止我们检查第一条消息内容，只需使用`XRANGE`.

    > XRANGE mystream 1526569498055-0 1526569498055-0
    1) 1) 1526569498055-0
       2) 1) "message"
          2) "orange"

我们只需要在参数中重复相同的 ID 两次。现在我们有了一些想法，爱丽丝可能会决定，在20个小时不处理消息之后，鲍勃可能不会及时恢复，现在是时候了*索赔*此类消息并代替 Bob 恢复处理。为此，我们使用`XCLAIM`命令。

此命令非常复杂，并且充满了完整形式的选项，因为它用于复制使用者组更改，但我们仅使用通常需要的参数。在这种情况下，它就像：

    XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>

基本上，我们说，对于这个特定的键和组，我希望指定的消息ID将更改所有权，并将分配给指定的使用者名称`<consumer>`.但是，我们还提供了最小空闲时间，以便仅当所提及消息的空闲时间大于指定的空闲时间时，操作才会起作用。这很有用，因为可能有两个客户端正在重试同时声明消息：

    Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0
    Client 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0

但是，作为副作用，声明消息将重置其空闲时间，并将增加其传递计数器的数量，因此第二个客户端将无法声明它。通过这种方式，我们避免了对消息的琐碎重新处理（即使在一般情况下，您也无法获得一次处理）。

这是命令执行的结果：

    > XCLAIM mystream mygroup Alice 3600000 1526569498055-0
    1) 1) 1526569498055-0
       2) 1) "message"
          2) "orange"

Alice 成功声明了该消息，Alice 现在可以处理该消息并确认它，即使原始使用者没有恢复，也可以继续进行操作。

从上面的例子中可以清楚地看出，作为成功声明给定消息的副作用，`XCLAIM`命令也返回它。但是，这不是强制性的。这**贾斯蒂德**选项可用于仅返回已成功声明的消息的 ID。如果要减少客户端和服务器之间使用的带宽（以及命令的性能），并且对消息不感兴趣，因为使用者的实现方式是它将不时重新扫描挂起消息的历史记录，则这很有用。

声明也可以通过单独的进程实现：该进程仅检查挂起消息的列表，并将空闲消息分配给看似处于活动状态的使用者。可以使用 Redis 流的可观察性功能之一获取活动使用者。这是下一节的主题。

## 自动声明

这`XAUTOCLAIM`命令（在 Redis 6.2 中添加）实现了我们上面描述的声明过程。
`XPENDING`和`XCLAIM`为不同类型的恢复机制提供基本构建块。
此命令通过让 Redis 管理通用过程来优化通用过程，并为大多数恢复需求提供简单的解决方案。

`XAUTOCLAIM`识别空闲挂起的消息，并将其所有权转让给使用者。
该命令的签名如下所示：

    XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT count] [JUSTID]

因此，在上面的示例中，我可以使用自动声明来声明单个消息，如下所示：

    > XAUTOCLAIM mystream mygroup Alice 3600000 0-0 COUNT 1
    1) 1526569498055-0
    2) 1) 1526569498055-0
       2) 1) "message"
          2) "orange"

喜欢`XCLAIM`，该命令使用已声明消息的数组进行回复，但它也返回允许迭代挂起条目的流 ID。
流 ID 是一个游标，我可以在下一次调用中使用它来继续声明空闲的挂起消息：

    > XAUTOCLAIM mystream mygroup Lora 3600000 1526569498055-0 COUNT 1
    1) 0-0
    2) 1) 1526569506935-0
       2) 1) "message"
          2) "strawberry"

什么时候`XAUTOCLAIM`返回“0-0”流 ID 作为游标，这意味着它到达了使用者组挂起条目列表的末尾。
这并不意味着没有新的空闲挂起消息，因此该过程通过调用来继续`XAUTOCLAIM`从流的开头开始。

## 索赔和送货柜台

您在`XPENDING`输出是每条消息的传递次数。计数器以两种方式递增：当消息成功声明时，通过以下方式`XCLAIM`或当`XREADGROUP`调用用于访问挂起消息的历史记录。

当出现故障时，消息将被多次传递是正常的，但最终它们通常会得到处理和确认。但是，处理某些特定消息时可能会出现问题，因为它已损坏或以触发处理代码中错误的方式制作。在这种情况下，发生的事情是消费者将不断无法处理此特定消息。由于我们有传递尝试的计数器，因此我们可以使用该计数器来检测由于某种原因无法处理的消息。因此，一旦传递计数器达到您选择的给定大数字，将此类消息放在另一个流中并向系统管理员发送通知可能更明智。这基本上是 Redis Streams 实现*死信*概念。

## 流可观察性

缺乏可观察性的消息传递系统非常难以使用。不知道谁在消费消息，哪些消息是挂起的，在给定流中活跃的一组消费者组，使一切都不透明。出于这个原因，Redis Streams和消费者群体有不同的方法来观察正在发生的事情。我们已经涵盖了`XPENDING`，这使我们能够检查在给定时刻正在处理的消息列表，以及它们的空闲时间和传递次数。

但是，我们可能想做更多的事情，并且`XINFO`命令是一个可观察性接口，可以与子命令一起使用，以获取有关流或使用者组的信息。

此命令使用子命令，以便显示有关流及其使用者组状态的不同信息。例如**XINFO 流<key>**报告有关流本身的信息。

    > XINFO STREAM mystream
     1) "length"
     2) (integer) 2
     3) "radix-tree-keys"
     4) (integer) 1
     5) "radix-tree-nodes"
     6) (integer) 2
     7) "last-generated-id"
     8) "1638125141232-0"
     9) "max-deleted-entryid"
    10) "0-0"
    11) "entries-added"
    12) (integer) 2
    13) "groups"
    14) (integer) 1
    15) "first-entry"
    16) 1) "1638125133432-0"
        2) 1) "message"
           2) "apple"
    17) "last-entry"
    18) 1) "1638125141232-0"
        2) 1) "message"
           2) "banana"

输出显示有关如何在内部编码流的信息，还显示流中的第一条和最后一条消息。另一条可用信息是与此流关联的使用者组的数量。我们可以进一步挖掘，询问有关消费者群体的更多信息。

    > XINFO GROUPS mystream
    1)  1) "name"
        2) "mygroup"
        3) "consumers"
        4) (integer) 2
        5) "pending"
        6) (integer) 2
        7) "last-delivered-id"
        8) "1638126030001-0"
        9) "entries-read"
       10) (integer) 2
       11) "lag"
       12) (integer) 0
    2)  1) "name"
        2) "some-other-group"
        3) "consumers"
        4) (integer) 1
        5) "pending"
        6) (integer) 0
        7) "last-delivered-id"
        8) "1638126028070-0"
        9) "entries-read"
       10) (integer) 1
       11) "lag"
       12) (integer) 1

正如您在本文和上一个输出中看到的，`XINFO`命令输出一系列字段值项。因为它是一个可观察性命令，所以允许人类用户立即了解报告的信息，并允许该命令通过添加更多字段来报告更多信息，而不会破坏与旧客户端的兼容性。其他必须提高带宽效率的命令，如`XPENDING`，只需报告不带字段名称的信息。

上面示例的输出，其中**组**使用子命令时，应明确观察字段名称。我们可以通过检查在组中注册的消费者来更详细地检查特定消费者组的状态。

    > XINFO CONSUMERS mystream mygroup
    1) 1) name
       2) "Alice"
       3) pending
       4) (integer) 1
       5) idle
       6) (integer) 9104628
    2) 1) name
       2) "Bob"
       3) pending
       4) (integer) 1
       5) idle
       6) (integer) 83841983

如果您不记得命令的语法，只需向命令本身寻求帮助：

    > XINFO HELP
    1) XINFO <subcommand> [<arg> [value] [opt] ...]. Subcommands are:
    2) CONSUMERS <key> <groupname>
    3)     Show consumers of <groupname>.
    4) GROUPS <key>
    5)     Show the stream consumer groups.
    6) STREAM <key> [FULL [COUNT <count>]
    7)     Show information about the stream.
    8) HELP
    9)     Prints this help.

## 与 Kafka （TM） 分区的区别

Redis 流中的使用者组可能在某些方面类似于基于 Kafka （TM） 分区的使用者组，但请注意，Redis 流实际上非常不同。分区仅*逻辑*并且消息只是放入单个 Redis 密钥中，因此提供不同客户端的方式取决于谁准备好处理新消息，而不是从哪个分区客户端读取消息。例如，如果消费者C3在某个时候永久失败，Redis将继续为C1和C2提供所有到达的新消息，就好像现在只有两个一样。*逻辑*分区。

同样，如果给定的使用者在处理消息方面比其他使用者快得多，则该使用者将在同一时间内按比例接收更多的消息。这是可能的，因为Redis会显式跟踪所有未确认的消息，并记住谁收到了哪条消息以及从未传递给任何消费者的第一条消息的ID。

但是，这也意味着在Redis中，如果您真的想将同一流中的消息划分为多个Redis实例，则必须使用多个密钥和一些分片系统，例如Redis集群或其他一些特定于应用程序的分片系统。单个 Redis 流不会自动分区为多个实例。

我们可以说，从示意图上讲，以下情况是正确的：

*   如果使用 1 个流 -> 1 个使用者，则按顺序处理消息。
*   如果将 N 流与 N 个使用者一起使用，以便只有给定的使用者命中 N 个流的子集，则可以缩放上述 1 个流 -> 1 个使用者的模型。
*   如果使用 1 个流 -> N 个使用者，则与 N 个使用者进行负载平衡，但是在这种情况下，有关同一逻辑项的消息可能会按顺序使用，因为给定使用者处理消息 3 的速度可能比处理消息 4 的速度快。

因此，基本上Kafka分区更类似于使用N个不同的Redis密钥，而Redis使用者组是服务器端的负载平衡系统，将消息从给定流传输到N个不同的使用者。

## 封顶流

许多应用程序不希望将数据永远收集到流中。有时，在流中最多拥有给定数量的项目是有用的，其他时候，一旦达到给定的大小，将数据从Redis移动到不在内存中的存储是有用的，并且速度不快，但适合存储未来几十年的历史记录。Redis 流对此有一些支持。一是**麦克斯伦**的选项`XADD`命令。此选项使用起来非常简单：

    > XADD mystream MAXLEN 2 * value 1
    1526654998691-0
    > XADD mystream MAXLEN 2 * value 2
    1526654999635-0
    > XADD mystream MAXLEN 2 * value 3
    1526655000369-0
    > XLEN mystream
    (integer) 2
    > XRANGE mystream - +
    1) 1) 1526654999635-0
       2) 1) "value"
          2) "2"
    2) 1) 1526655000369-0
       2) 1) "value"
          2) "3"

用**麦克斯伦**当达到指定长度时，旧条目会自动逐出，以便流保持恒定大小。当前没有选项可以告诉流仅保留不早于给定时间段的项目，因为为了一致地运行，此类命令可能会阻止很长时间以逐出项目。例如，想象一下，如果有一个插入尖峰，然后是一个长暂停，另一个插入，会发生什么，所有这些都具有相同的最大时间。流将阻塞以逐出在暂停期间变得太旧的数据。因此，由用户进行一些规划并了解所需的最大流长度是多少。此外，虽然流的长度与使用的内存成正比，但按时间修剪不太容易控制和预测：它取决于插入速率，而插入速率通常会随时间而变化（当它没有变化时，那么仅仅按大小修剪是微不足道的）。

但是修剪**麦克斯伦**可能很昂贵：流由宏节点表示到基数树中，以便非常节省内存。更改由几十个元素组成的单个宏节点不是最佳选择。因此，可以按以下特殊形式使用该命令：

    XADD mystream MAXLEN ~ 1000 * ... entry fields here ...

这`~`参数之间的参数**麦克斯伦**选项和实际计数意味着，我真的不需要这个正好是1000个项目。它可以是1000或1010或1030，只要确保至少保存1000个项目。有了这个参数，只有当我们可以删除整个节点时，才会执行修剪。这使得它更有效率，这通常是你想要的。

还有`XTRIM`命令，它执行与**麦克斯伦**选项在上面，除了它可以自己运行：

    > XTRIM mystream MAXLEN 10

或者，至于`XADD`选择：

    > XTRIM mystream MAXLEN ~ 10

然而`XTRIM`旨在接受不同的修剪策略。另一种修剪策略是**迷你**，则逐出 ID 低于指定 ID 的条目。

如`XTRIM`是一个显式命令，用户应该知道不同修剪策略的可能缺点。

另一个有用的驱逐策略可以添加到`XTRIM`将来，是要通过一系列ID来移除，以方便使用`XRANGE`和`XTRIM`如果需要，将数据从 Redis 移动到其他存储系统。

## 流 API 中的特殊 ID

您可能已经注意到，有几个特殊 ID 可以在 Redis API 中使用。这是一个简短的回顾，以便它们将来更有意义。

前两个特殊 ID 是`-`和`+`，并在范围查询中使用`XRANGE`命令。这两个ID分别表示可能的最小ID（基本上是`0-1`）和可能的最大 ID（即`18446744073709551615-18446744073709551615`).如您所见，写起来要干净得多`-`和`+`而不是那些数字。

然后是一些API，我们想说的是，在流中具有最大ID的项目的ID。这是什么`$`方法。因此，例如，如果我只想要新条目`XREADGROUP`我使用此 ID 表示我已经拥有所有现有条目，但不包括将来要插入的新条目。同样，当我创建或设置使用者组的 ID 时，我可以将上次交付的物料设置为`$`以便将新条目交付给组中的消费者。

如您所见`$`并不意味着`+`，它们是两个不同的东西，如`+`是每个可能的流中可能的最大 ID，而`$`是包含给定条目的给定流中的最大 ID。此外，API通常只能理解`+`或`$`，但避免加载具有多种含义的给定符号是有用的。

另一个特殊 ID 是`>`，即仅与消费群体相关的特殊含义，并且仅当`XREADGROUP`命令被使用。此特殊 ID 意味着我们只需要迄今为止从未交付给其他使用者的条目。所以基本上`>`ID 是*上次交付的 ID*的使用者组。

最后是特殊 ID`*`，只能与`XADD`命令，表示为新条目自动为我们选择一个 ID。

所以我们有`-`,`+`,`$`,`>`和`*`，并且都具有不同的含义，并且大多数时候，可以在不同的上下文中使用。

## 持久性、复制和消息安全

与任何其他 Redis 数据结构一样，流以异步方式复制到副本并保存到 AOF 和 RDB 文件中。然而，可能不那么明显的是，使用者组的完整状态也会传播到AOF，RDB和副本，因此，如果主服务器中挂起的消息，则副本也将具有相同的信息。同样，重新启动后，AOF 将还原使用者组的状态。

但请注意，Redis 流和使用者组是使用 Redis 默认复制进行持久保存和复制的，因此：

*   如果消息的持久性在应用程序中很重要，则必须将 AOF 与强 fsync 策略一起使用。
*   默认情况下，异步复制不保证`XADD`命令或使用者组状态更改将被复制：故障转移后，可能会丢失某些内容，具体取决于副本从主服务器接收数据的能力。
*   这`WAIT`命令可用于强制将更改传播到一组副本。但请注意，虽然这使得数据丢失的可能性很小，但由 Sentinel 或 Redis Cluster 操作的 Redis 故障转移过程仅执行*尽最大努力*检查以故障转移到更新的副本，并且在某些特定故障条件下可能会升级缺少某些数据的副本。

因此，在使用 Redis 流和使用者组设计应用程序时，请确保了解应用程序在发生故障时应具有的语义属性，并相应地进行配置，评估它是否足以满足您的使用案例。

## 从流中删除单个项目

流还具有一个特殊命令，用于仅通过 ID 从流中间删除项目。通常，对于仅追加数据结构，这可能看起来像一个奇怪的功能，但它实际上对于涉及隐私法规等的应用程序很有用。该命令称为`XDEL`并接收流的名称，后跟要删除的 ID：

    > XRANGE mystream - + COUNT 2
    1) 1) 1526654999635-0
       2) 1) "value"
          2) "2"
    2) 1) 1526655000369-0
       2) 1) "value"
          2) "3"
    > XDEL mystream 1526654999635-0
    (integer) 1
    > XRANGE mystream - + COUNT 2
    1) 1) 1526655000369-0
       2) 1) "value"
          2) "3"

但是，在当前实现中，在宏节点完全为空之前，内存不会真正回收，因此不应滥用此功能。

## 零长度流

流与其他 Redis 数据结构之间的区别在于，当其他数据结构不再具有任何元素时，作为调用删除元素的命令的副作用，密钥本身将被删除。例如，当调用`ZREM`将删除排序集中的最后一个元素。另一方面，允许流保持在零元素，这两者都是由于使用**麦克斯伦**计数为零的选项 （`XADD`和`XTRIM`命令），或因为`XDEL`被调用。

存在这种不对称的原因是，Streams 可能具有关联的使用者组，我们不希望仅仅因为流中不再有任何项目而失去使用者组定义的状态。当前，即使流没有关联的使用者组，也不会删除流。

## 使用消息的总延迟

非阻塞流命令，如`XRANGE`和`XREAD`或`XREADGROUP`如果没有 BLOCK 选项，则像任何其他 Redis 命令一样同步提供，因此讨论此类命令的延迟是没有意义的：在 Redis 文档中检查命令的时间复杂性更有趣。在提取范围时，流命令至少与排序的 set 命令一样快就足够了，并且`XADD`速度非常快，如果使用流水线，可以在普通机器中轻松插入每秒50万到100万个项目。

但是，如果我们想了解处理消息的延迟，在阻塞使用者组中的使用者的上下文中，延迟成为一个有趣的参数，从消息产生的那一刻起`XADD`，直到使用者获取消息的那一刻，因为`XREADGROUP`随消息一起返回。

## 为被屏蔽的消费者提供服务的工作原理

在提供已执行测试的结果之前，了解 Redis 使用什么模型来路由流消息（以及通常实际上如何管理任何等待数据的阻塞操作）是很有趣的。

*   被阻止的客户端在哈希表中引用，该哈希表将至少有一个阻塞使用者的键映射到正在等待此类键的使用者列表。这样，给定接收数据的密钥，我们可以解析所有正在等待此类数据的客户端。
*   当写入发生时，在这种情况下，当`XADD`命令被调用，它调用`signalKeyAsReady()`功能。此函数会将密钥放入需要处理的密钥列表中，因为此类密钥可能具有被阻止使用者的新数据。请注意，此类*就绪键*稍后将进行处理，因此在同一事件循环周期的过程中，密钥可能会接收其他写入。
*   最后，在返回事件循环之前，*就绪键*最终处理。对于每个键，将扫描等待数据的客户端列表，如果适用，此类客户端将收到到达的新数据。在流的情况下，数据是消费者请求的适用范围内的消息。

如您所见，基本上，在返回事件循环之前，客户端调用`XADD`和被阻止使用消息的客户端，将在输出缓冲区中具有它们的应答，因此调用方`XADD`应该在消费者收到新消息的同时收到来自 Redis 的回复。

此模型是*基于推送*，因为将数据添加到使用者缓冲区将直接通过调用的操作执行`XADD`，因此延迟往往是非常可预测的。

## 延迟测试结果

为了检查这些延迟特征，使用Ruby程序的多个实例执行了测试，这些实例推送消息具有计算机毫秒时间作为附加字段，Ruby程序从消费者组读取消息并处理它们。消息处理步骤包括将当前计算机时间与消息时间戳进行比较，以便了解总延迟。

结果：

    Processed between 0 and 1 ms -> 74.11%
    Processed between 1 and 2 ms -> 25.80%
    Processed between 2 and 3 ms -> 0.06%
    Processed between 3 and 4 ms -> 0.01%
    Processed between 4 and 5 ms -> 0.02%

因此，99.9% 的请求的延迟< = 2 毫秒，异常值仍然非常接近平均值。

向流中添加数百万条未确认的消息不会改变基准测试的要点，大多数查询仍以非常短的延迟进行处理。

几点说明：

*   在这里，我们每次迭代处理了多达 10000 条消息，这意味着`COUNT`参数`XREADGROUP`设置为 10000。这增加了很多延迟，但为了让速度较慢的使用者能够跟上消息流，这是必需的。因此，您可以期望现实世界的延迟要小得多。
*   与今天的标准相比，用于此基准测试的系统非常慢。
