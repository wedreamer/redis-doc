---
title: "Scripting with Lua"
linkTitle: "Lua scripting"
weight: 2
description: >
   Executing Lua in Redis
aliases:
    - /topics/eval-intro
---

Redis允许用户在服务器上上传和执行Lua脚本。
脚本可以采用编程控制结构, 并使用大部分[命令](/commands)同时执行以访问数据库。
由于脚本在服务器中执行, 因此从脚本读取和写入数据非常高效。

Redis 保证脚本的原子执行。
执行脚本时, 将在整个运行时阻止所有服务器活动。
这些语义意味着脚本的所有效果要么尚未发生, 要么已经发生。

脚本提供了几个属性, 这些属性在许多情况下可能很有价值。
这些包括：

*   通过在数据所在的位置执行逻辑来提供局部性。数据局部性可减少总体延迟并节省网络资源。
*   确保脚本原子执行的阻塞语义。
*   启用Redis中缺少的简单功能的组合, 或者这些功能对于它的一部分来说太小众了。

Lua 允许您在 Redis 中运行部分应用程序逻辑。
此类脚本可以跨多个键执行条件更新, 可能会以原子方式组合多个不同的数据类型。

脚本在 Redis 中由嵌入式执行引擎执行。
目前, Redis 支持单个脚本引擎, [Lua 5.1](https://www.lua.org/)译员。
请参阅[Redis Lua API Reference](/topics/lua-api)页面以获取完整文档。

尽管服务器执行它们, 但 Eval 脚本被视为客户端应用程序的一部分, 这就是为什么它们没有被命名、版本控制或持久化的原因。
因此, 如果缺少所有脚本, 则可能需要应用程序随时重新加载 (在服务器重新启动, 故障转移到副本等之后) 。
从版本 7.0 开始, [Redis Functions](/topics/functions-intro)提供了一种替代的可编程性方法, 允许服务器本身通过附加的编程逻辑进行扩展。

## 开始

我们将通过使用 Redis 开始编写脚本`EVAL`命令。

这是我们的第一个示例：

    > EVAL "return 'Hello, scripting!'" 0
    "Hello, scripting!"

在此示例中, `EVAL`需要两个参数。
第一个参数是由脚本的 Lua 源代码组成的字符串。
该脚本不需要包含 Lua 函数的任何定义。
它只是一个Lua程序, 将在Redis引擎的上下文中运行。

第二个参数是从第三个参数开始, 表示 Redis 键名的脚本正文后面的参数数。
在此示例中, 我们使用了值*0*因为我们没有为脚本提供任何参数, 无论键的名称是否如此。

## 脚本参数化

让应用程序根据其需求动态生成脚本源代码是可能的, 尽管非常不明智。
例如, 应用程序可以发送这两个完全不同但同时完全相同的脚本：

    redis> EVAL "return 'Hello'" 0
    "Hello"
    redis> EVAL "return 'Scripting!'" 0
    "Scripting!"

尽管 Redis 未阻止此操作模式, 但由于脚本缓存注意事项, 它是一种反模式 (有关以下主题的更多信息) 。
您可以对它们进行参数化并传递执行它们所需的任何参数, 而不是让应用程序生成相同脚本的细微变体。

下面的示例演示如何通过参数化实现与上述相同的效果：

    redis> EVAL "return ARGV[1]" 0 Hello
    "Hello"
    redis> EVAL "return ARGV[1]" 0 Parameterization!
    "Parameterization!"

此时, 必须了解 Redis 在作为键名称的输入参数和非键名称的输入参数之间的区别。

虽然 Redis 中的键名只是字符串, 但与任何其他字符串值不同, 这些值表示数据库中的键。
密钥的名称是 Redis 中的基本概念, 也是运行 Redis 集群的基础。

**重要：**
为了确保在独立部署和群集部署中正确执行脚本, 脚本访问的所有键名称都必须显式提供为输入键参数。
脚本**应该只**访问键, 其名称作为输入参数给出。
脚本**永远不应该**访问键具有以编程方式生成的名称或基于存储在数据库中的数据结构的内容。

函数的任何不是键名称的输入都是常规输入参数。

在上面的示例中, 两者*你好*和*参数化！*脚本的常规输入参数。
由于脚本不触及任何键, 因此我们使用数字参数*0*以指定没有键名参数。
执行上下文使参数可供脚本使用, 如下所示[*钥匙*](/topics/lua-api#the-keys-global-variable)和[*断续器*](/topics/lua-api#the-argv-global-variable)全局运行时变量。
这*钥匙*table 是使用在执行脚本之前提供给脚本的所有键名参数预先填充的, 而*断续器*table 具有类似的用途, 但用于常规参数。

以下尝试演示脚本之间输入参数的分布*钥匙*和*断续器*运行时全局变量：

    redis> EVAL "return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }" 2 key1 key2 arg1 arg2 arg3
    1) "key1"
    2) "key2"
    3) "arg1"
    4) "arg2"
    5) "arg3"

**注意：**
从上面可以看出, Lua 的表数组返回为[RESP2 阵列回复](/topics/protocol#resp-arrays), 因此客户端的库很可能会将其转换为编程语言中的本机数组数据类型。
请参阅管理规则[数据类型转换](/topics/lua-api#data-type-conversion)以获取更多相关信息。

## 从脚本与 Redis 交互

可以通过以下方式从 Lua 脚本调用 Redis 命令[`redis.call()`](/topics/lua-api#redis.call)或[`redis.pcall()`](/topics/lua-api#redis.pcall).

两者几乎完全相同。
两者都执行 Redis 命令及其提供的参数 (如果这些参数表示格式正确的命令) 。
但是, 这两个函数之间的区别在于处理运行时错误 (例如语法错误) 的方式。
调用引发的错误`redis.call()`函数将直接返回到执行它的客户端。
相反, 调用`redis.pcall()`函数将返回到脚本的执行上下文, 而不是进行可能的处理。

例如, 请考虑以下事项：

    > EVAL "return redis.call('SET', KEYS[1], ARGV[1])" 1 foo bar
    OK

上述脚本接受一个键名和一个值作为其输入参数。
执行时, 脚本调用`SET`命令来设置输入键, *foo*, 字符串值为“bar”。

## 脚本缓存

在此之前, 我们一直使用`EVAL`命令来运行我们的脚本。

每当我们打电话`EVAL`, 我们还在请求中包含脚本的源代码。
反复呼叫`EVAL`执行同一组参数化脚本, 会浪费网络带宽, 并且在 Redis 中也存在一些开销。
当然, 节省网络和计算资源是关键, 因此, Redis 为脚本提供了缓存机制。

您执行的每个脚本`EVAL`存储在服务器保留的专用缓存中。
缓存的内容由脚本的 SHA1 摘要总和组织, 因此脚本的 SHA1 摘要总和在缓存中唯一标识它。
您可以通过运行`EVAL`和呼叫`INFO`然后。
您会注意到*used_memory_scripts_eval*和*number_of_cached_scripts*指标随着执行的每个新脚本而增长。

如上所述, 动态生成的脚本是一种反模式。
在应用程序运行时生成脚本可能会 (并且可能会) 耗尽主机的内存资源来缓存它们。
相反, 脚本应尽可能通用, 并通过其参数提供自定义执行。

通过调用`SCRIPT LOAD`命令并提供其源代码。
服务器不执行脚本, 而只是编译脚本并将其加载到服务器的缓存中。
加载后, 可以使用从服务器返回的 SHA1 摘要执行缓存的脚本。

下面是加载然后执行缓存脚本的示例：

    redis> SCRIPT LOAD "return 'Immabe a cached script'"
    "c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f"
    redis> EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0
    "Immabe a cached script"

### 缓存波动性

Redis 脚本缓存是**总是不稳定**.
它不被视为数据库的一部分, 并且是**未持久化**.
缓存可以在服务器重新启动时清除, 在故障转移期间副本承担 master 角色时清除, 或者由显式清除`SCRIPT FLUSH`.
这意味着缓存的脚本是短暂的, 缓存的内容可能随时丢失。

使用脚本的应用程序应始终调用`EVALSHA`以执行它们。
如果脚本的 SHA1 摘要不在缓存中, 则服务器将返回错误。
例如：

    redis> EVALSHA ffffffffffffffffffffffffffffffffffffffff 0
    (error) NOSCRIPT No matching script

在这种情况下, 应用程序应首先加载它`SCRIPT LOAD`, 然后呼叫`EVALSHA`再次通过其 SHA1 总和运行缓存的脚本。
大多数[瑞迪斯的客户](/clients)已经提供了用于自动执行此操作的实用程序API。
有关具体细节, 请查阅客户的文件。

### `EVALSHA`在流水线的上下文中

应特别注意执行`EVALSHA`在[管道请求](/topics/pipelining).
流水线请求中的命令按其发送顺序运行, 但其他客户端的命令可能会在这些命令之间交错执行。
因此, `NOSCRIPT`error 可以从管道请求返回, 但无法处理。

因此, 客户端库的实现应恢复为使用 plain`EVAL`在管道上下文中参数化。

### 脚本缓存语义

在正常操作期间, 应用程序的脚本应无限期地保留在缓存中 (即, 直到重新启动服务器或刷新缓存) 。
基本原因是, 编写良好的应用程序的脚本缓存内容不太可能持续增长。
即使是使用数百个缓存脚本的大型应用程序, 在缓存内存使用方面也不应该成为问题。

刷新脚本缓存的唯一方法是显式调用`SCRIPT FLUSH`命令。
运行该命令将*完全齐平*脚本缓存, 删除到目前为止执行的所有脚本。
通常, 仅当要为云环境中的其他客户或应用程序实例化实例化实例时, 才需要这样做。

此外, 如前所述, 重新启动 Redis 实例会刷新非持久性脚本缓存。
但是, 从 Redis 客户端的角度来看, 只有两种方法可以确保 Redis 实例未在两个不同的命令之间重新启动：

*   我们与服务器的连接是持久的, 到目前为止从未关闭过。
*   客户端显式检查`run_id`字段中的字段`INFO`命令以确保服务器未重新启动, 并且仍然是相同的进程。

实际上, 对于客户端来说, 假设在给定连接的上下文中, 缓存脚本保证存在要简单得多, 除非管理员显式调用`SCRIPT FLUSH`命令。
用户可以依靠 Redis 来保留缓存的脚本这一事实在流水线上下文中具有语义上的帮助。

## 这`SCRIPT`命令

雷迪斯酒店`SCRIPT`提供了几种控制脚本子系统的方法。
这些是：

*   `SCRIPT FLUSH`：此命令是强制 Redis 刷新脚本缓存的唯一方法。
    在将同一 Redis 实例重新分配给不同用途的环境中, 它最有用。
    它还有助于测试客户端库的脚本功能实现。

*   `SCRIPT EXISTS`：给定一个或多个 SHA1 摘要作为参数, 此命令返回一个数组*1*的和*0*的。
    *1*表示特定的 SHA1 被识别为脚本缓存中已存在的脚本。*0*的含义是, 具有此 SHA1 的脚本以前未加载过 (或者至少自最近一次调用以来从未加载过) 。`SCRIPT FLUSH`).

*   `SCRIPT LOAD script`：此命令在 Redis 脚本缓存中注册指定的脚本。
    在我们希望确保`EVALSHA`不会失败 (例如, 在管道中或从[`MULTI`/`EXEC`交易](/topics/transactions)) , 而无需执行脚本。

*   `SCRIPT KILL`：此命令是中断长时间运行的脚本 (也称为慢速脚本) 的唯一方法, 无需关闭服务器。
    一旦脚本的执行持续时间超过配置的持续时间, 就会被视为缓慢[最大执行时间](/topics/programmability#maximum-execution-time)门槛。
    这`SCRIPT KILL`命令只能与在执行期间未修改数据集的脚本一起使用 (因为停止只读脚本不会违反脚本引擎保证的原子性) 。

*   `SCRIPT DEBUG`：控制内置的使用[Redis Lua scripts debugger](/topics/ldb).

## 脚本复制

在独立部署中, 单个 Redis 实例称为*主人*管理整个数据库。
一个[群集部署](/topics/cluster-tutorial)至少有三个主节点管理分片数据库。
Redis 使用[复制](/topics/replication)为任何给定的主服务器维护一个或多个副本或精确副本。

由于脚本可以修改数据, 因此 Redis 确保脚本执行的所有写入操作也发送到副本以保持一致性。
在脚本复制方面, 有两种概念性方法：

1.  逐字复制：主服务器将脚本的源代码发送到副本。
    然后, 副本执行脚本并应用写入效果。
    此模式可以在短脚本生成许多命令 (例如, a*为*循环) 。
    但是, 此复制模式意味着副本重做主服务器完成的相同工作, 这是浪费。
    更重要的是, 它还需要[所有编写脚本都是确定性的](#scripts-with-deterministic-writes).
2.  效果复制：仅复制脚本的数据修改命令。
    然后, 副本在不执行任何脚本的情况下运行命令。
    虽然在网络流量方面可能更长, 但根据定义, 此复制模式是确定性的, 因此不需要特别考虑。

在 Redis 3.2 之前, 逐字脚本复制是唯一受支持的模式, 其中添加了效果复制。
这*lua-replicate-commands*配置指令和[`redis.replicate_commands()`](/topics/lua-api#redis.replicate_commands)Lua API可用于启用它。

在 Redis 5.0 中, 效果复制成为默认模式。
从 Redis 7.0 开始, 不再支持逐字复制。

### 复制命令而不是脚本

从 Redis 3.2 开始, 可以选择其他复制方法。
我们可以复制脚本生成的写入命令, 而不是复制整个脚本。
我们称之为**脚本效果复制**.

**注意：**
从 Redis 5.0 开始, 脚本效果复制是默认模式, 不需要显式启用。

在此复制模式下, 在执行 Lua 脚本时, Redis 会收集 Lua 脚本引擎执行的所有实际修改数据集的命令。
脚本执行完成后, 脚本生成的命令序列将包装到[`MULTI`/`EXEC`交易](/topics/transactions)并发送到副本和 AOF。

这在几个方面很有用, 具体取决于用例：

*   当脚本计算速度慢, 但可以通过几个写入命令来总结效果时, 在副本上或重新加载AOF时重新计算脚本是一种耻辱。
    在这种情况下, 最好只复制脚本的效果。
*   启用脚本效果复制后, 将删除对非确定性功能的限制。
    例如, 您可以使用`TIME`或`SRANDMEMBER`脚本中的命令在任何地方都可以自由地进行。
*   此模式下的 Lua PRNG 在每次调用时随机播种。

除非已经通过服务器的配置或默认值启用 (在 Redis 7.0 之前) , 否则您需要在脚本执行写入之前发出以下 Lua 命令：

```lua
redis.replicate_commands()
```

这[`redis.replicate_commands()`](/topics/lua-api#redis.replicate_commands)函数返回 \_true)  如果启用了脚本效果复制;
否则, 如果函数是在脚本已调用写入命令之后调用的, 
它返回*假*, 然后使用正常的整个脚本复制。

此函数自 Redis 7.0 起已弃用, 虽然您仍然可以调用它, 但它将始终成功。

### 具有确定性写入的脚本

**注意：**
从 Redis 5.0 开始, 脚本复制默认基于效果, 而不是逐字复制。
在 Redis 7.0 中, 逐字脚本复制已被完全删除。
以下部分仅适用于在不使用基于效果的脚本复制时低于 Redis 7.0 的版本。

脚本编写的一个重要部分是编写仅以确定性方式更改数据库的脚本。
默认情况下, 在 5.0 版之前, 在 Redis 实例中执行的脚本通过发送脚本本身 (而不是生成的命令) 传播到副本和 AOF 文件。
由于脚本将在远程主机上重新运行 (或在重新加载 AOF 文件时) , 因此其对数据库的更改必须是可重现的。

发送脚本的原因是它通常比发送脚本生成的多个命令快得多。
如果客户端向主服务器发送许多脚本, 则将这些脚本转换为副本/ AOF的单个命令将导致复制链接或仅追加文件的带宽过多 (并且由于调度通过网络接收的命令对于Redis来说比调度由Lua脚本调用的命令要多得多) 。

通常, 复制脚本而不是脚本的影响是有意义的, 但并非在所有情况下都是如此。
因此, 从 Redis 3.2 开始, 脚本引擎能够复制脚本执行产生的写入命令序列, 而不是复制脚本本身。

在本节中, 我们将假设通过发送整个脚本来逐字复制脚本。
我们称之为复制模式**逐字脚本复制**.

主要缺点与*整个脚本复制*方法是脚本需要具有以下属性：
脚本**总是必须的**执行相同的 Redis*写*在给定相同输入数据集的情况下具有相同参数的命令。
脚本执行的操作不能依赖于任何隐藏的 (非显式) 信息或状态, 这些信息或状态可能会随着脚本执行的进行或在脚本的不同执行之间而更改。
它也不能依赖于来自I/O设备的任何外部输入。

诸如使用系统时间, 调用返回随机值的Redis命令 (例如, `RANDOMKEY`) , 或者使用 Lua 的随机数生成器, 可能会导致脚本无法一致地计算。

为了强制执行脚本的确定性行为, Redis 执行以下操作：

*   Lua 不会导出命令来访问系统时间或其他外部状态。
*   如果脚本调用能够更改数据集的 Redis 命令, Redis 将阻止脚本并显示错误**后**a 雷迪斯*随机*命令类似`RANDOMKEY`,`SRANDMEMBER`,`TIME`.
    这意味着不修改数据集的只读脚本可以调用这些命令。
    请注意, 一个*随机命令*并不一定意味着使用随机数的命令：任何非确定性命令都被视为随机命令 (在这方面最好的例子是`TIME`命令) 。
*   在 Redis 版本 4.0 中, 这指的是可能以随机顺序返回元素的命令, 例如`SMEMBERS` (因为 Redis 集是*无序*) , 当从 Lua 调用时表现出不同的行为, 
    并在将数据返回到Lua脚本之前进行静默的词典排序过滤器。
    所以`redis.call("SMEMBERS",KEYS[1])`将始终以相同的顺序返回 Set 元素, 而普通客户端调用的相同命令可能会返回不同的结果, 即使键包含完全相同的元素也是如此。
    但是, 从 Redis 5.0 开始, 不再执行此排序, 因为复制效果会规避这种类型的非确定性。
    通常, 即使在针对 Redis 4.0 进行开发时, 也不要假设 Lua 中的某些命令将被排序, 而是依赖于您调用的原始命令的文档来查看它提供的属性。
*   Lua 的伪随机数生成函数`math.random`被修改, 并且始终在每次执行时使用相同的种子。
    这意味着调用[`math.random`](/topics/lua-api#runtime-libraries)每次执行脚本时将始终生成相同的数字序列 (除非`math.randomseed`使用) 。

总而言之, 您仍然可以通过一个简单的技巧使用写入和随机行为的命令。
假设您要编写一个 Redis 脚本, 该脚本将使用 N 个随机整数填充列表。

Ruby 中的初始实现可能如下所示：

    require 'rubygems'
    require 'redis'

    r = Redis.new

    RandomPushScript = <<EOF
        local i = tonumber(ARGV[1])
        local res
        while (i > 0) do
            res = redis.call('LPUSH',KEYS[1],math.random())
            i = i-1
        end
        return res
    EOF

    r.del(:mylist)
    puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])

每次运行此代码时, 生成的列表将恰好具有
以下元素：

    redis> LRANGE mylist 0 -1
     1) "0.74509509873814"
     2) "0.87390407681181"
     3) "0.36876626981831"
     4) "0.6921941534114"
     5) "0.7857992587545"
     6) "0.57730350670279"
     7) "0.87046522734243"
     8) "0.09637165539729"
     9) "0.74990198051087"
    10) "0.17082803611217"

为了使脚本既具有确定性又仍然具有确定性, 请生成不同的随机元素, 
我们可以向脚本添加一个额外的参数, 该参数是Lua的伪随机数生成器的种子。
新脚本如下所示：

    RandomPushScript = <<EOF
        local i = tonumber(ARGV[1])
        local res
        math.randomseed(tonumber(ARGV[2]))
        while (i > 0) do
            res = redis.call('LPUSH',KEYS[1],math.random())
            i = i-1
        end
        return res
    EOF

    r.del(:mylist)
    puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))

我们在这里所做的是将PRNG的种子作为论点之一发送。
给定相同的参数 (我们的要求) , 脚本输出将始终相同, 但我们在每次调用时都会更改其中一个参数, 
生成随机种子客户端。
种子将作为复制链接和仅追加文件中的参数之一进行传播, 
保证在重新加载 AOF 或副本处理脚本时将生成相同的更改。

注意：此行为的一个重要部分是 Redis 实现为`math.random`和`math.randomseed`保证具有相同的输出, 而不管运行 Redis 的系统架构如何。
32 位、64 位、大端和小端系统都将产生相同的输出。

## 调试评估脚本

从 Redis 3.2 开始, Redis 支持本机 Lua 调试。
Redis Lua调试器是一个远程调试器, 由一个服务器 (Redis本身) 和一个客户端 (默认情况下为) 组成。[`redis-cli`](/topics/rediscli).

Lua 调试器在[Lua 脚本调试](/topics/ldb)部分。

## 在低内存条件下执行

当 Redis 中的内存使用量超过`maxmemory`限制, 在使用额外内存的脚本中遇到的第一个写入命令将导致脚本中止 (除非[`redis.pcall`](/topics/lua-api#redis.pcall)已使用) 。

但是, 上述情况的例外情况是, 脚本的第一个写入命令不使用额外的内存, 例如`DEL`和`LREM`).
在这种情况下, Redis 将允许脚本中的所有命令运行以确保原子性。
如果脚本中的后续写入会消耗额外的内存, Redis 的内存使用量可能会超过`maxmemory`配置指令。

脚本可能导致内存使用率超过`maxmemory`阈值是指当 Redis 略低于时执行开始的时间`maxmemory`, 因此允许脚本的第一个写入命令。
当脚本执行时, 后续的写入命令会消耗更多的内存, 从而导致服务器使用比配置的RAM更多的RAM`maxmemory`命令。

在这些情况下, 应考虑将`maxmemory-policy`配置指令, 用于除以下值以外的任何值`noeviction`.
此外, Lua 脚本应尽可能快, 以便逐出可以在执行之间启动。

请注意, 您可以使用以下命令更改此行为[标志](#eval-flags)

## 评估标志

通常, 当您运行 Eval 脚本时, 服务器不知道它如何访问数据库。
默认情况下, Redis 假定所有脚本都读取和写入数据。
但是, 从 Redis 7.0 开始, 有一种方法可以在创建脚本时声明标志, 以便告诉 Redis 它应该如何运行。

方法是在脚本的第一行使用Shebang语句, 如下所示：

    #!lua flags=no-writes,allow-stale
    local x = redis.call('get','x')
    return x

请注意, 一旦 Redis 看到`#!`注释, 它会像声明标志一样对待脚本, 即使没有定义标志, 
与没有`#!`线。

另一个区别是, 没有脚本`#!`可以运行访问属于不同集群哈希槽的密钥的命令, 但`#!`继承默认标志, 因此它们不能。

请参考[脚本标志](/topics/lua-api#script_flags)以了解各种脚本和默认值。
