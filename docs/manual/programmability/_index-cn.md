---
title: "Redis programmability"
linkTitle: "Programmability"
weight: 1
description: >
   Extending Redis with Lua and Redis Functions
aliases:
    - /topics/programmability
---

Redis 提供了一个编程接口, 允许您在服务器本身上执行自定义脚本。在 Redis 7 及更高版本中, 您可以使用[Redis Functions](/docs/manual/programmability/functions-intro)以管理和运行脚本。在 Redis 6.2 及更低版本中, 您可以使用[使用 EVAL 命令编写 Lua 脚本](/docs/manual/programmability/eval-intro)对服务器进行编程。

## 背景

Redis is,  by[定义](https://github.com/redis/redis/blob/unstable/MANIFESTO#L7)一个*“抽象数据类型的域特定语言”*.
Redis所说的语言包括[命令](/commands).
大多数命令专门用于操作核心[数据类型](/topics/data-types-intro)以不同的方式。
在许多情况下, 这些命令提供了开发人员在 Redis 中管理应用程序数据所需的所有功能。

术语**可编程性**在 Redis 中, 意味着能够通过服务器执行任意用户定义的逻辑。
我们将这样的逻辑片段称为**脚本**.
在我们的例子中, 脚本可以在数据所在的位置处理数据, 又名*数据局部性*.
此外, 在 Redis 服务器中负责任地嵌入编程工作流有助于减少网络流量并提高整体性能。
开发人员可以使用此功能来实现特定于应用程序的可靠 API。
此类 API 可以封装业务逻辑, 并跨多个键和不同的数据结构维护数据模型。

用户脚本在 Redis 中由嵌入式沙盒脚本引擎执行。
目前, Redis 支持单个脚本引擎, [Lua 5.1](https://www.lua.org/)译员。

请参阅[Redis Lua API Reference](/topics/lua-api)页面以获取完整文档。

## 运行脚本

Redis 提供了两种运行脚本的方法。

首先, 自 Redis 2.6.0 以来, `EVAL`命令启用运行服务器端脚本。
Eval 脚本提供了一种让 Redis 临时运行脚本的快速而直接的方法。
但是, 使用它们意味着脚本化逻辑是应用程序的一部分 (而不是 Redis 服务器的扩展) 。
运行脚本的每个应用实例都必须随时可以加载该脚本的源代码。
这是因为脚本仅由服务器缓存并且是易失性的。
随着应用程序的增长, 此方法可能变得难以开发和维护。

其次, 在 v7.0 中添加的 Redis Functions 本质上是一流的数据库元素脚本。
因此, 函数将脚本与应用程序逻辑分离, 并支持脚本的独立开发、测试和部署。
若要使用函数, 需要先加载这些函数, 然后才能供所有连接的客户端使用。
在这种情况下, 将函数加载到数据库将成为管理部署任务 (例如, 加载 Redis 模块) , 这会将脚本与应用程序分开。

有关详细信息, 请参阅以下页面：

*   [Redis Eval Scripts](/topics/eval-intro)
*   [Redis Functions](/topics/functions-intro)

运行脚本或函数时, Redis 保证其原子执行。
脚本的执行会在整个过程中阻止所有服务器活动, 类似于[交易](/topics/transactions).
这些语义意味着脚本的所有效果要么尚未发生, 要么已经发生。
已执行脚本的阻塞语义始终适用于所有连接的客户端。

请注意, 这种阻止方法的潜在缺点是执行慢速脚本不是一个好主意。
创建快速脚本并不难, 因为脚本的开销非常低。
但是, 如果您打算在应用程序中使用慢速脚本, 请注意, 所有其他客户端都将被阻止, 并且在运行时无法执行任何命令。

## 只读脚本

只读脚本是仅执行不修改 Redis 中任何键的命令的脚本。
只读脚本可以通过添加`no-writes` [旗](/topics/lua-api#script_flags)到脚本中, 或者使用只读脚本命令变体之一执行脚本：`EVAL_RO`,`EVALSHA_RO`或`FCALL_RO`.
它们具有以下属性：

*   它们始终可以在副本上执行。
*   他们总是可以被杀死`SCRIPT KILL`命令。
*   当 redis 超过内存限制时, 它们永远不会因 OOM 错误而失败。
*   在写入暂停期间不会阻止它们, 例如在协调故障转移期间发生的写入暂停。
*   他们无法执行任何可能修改数据集的命令。
*   现在`PUBLISH`,`SPUBLISH`和`PFCOUNT`在脚本中也被视为写入命令, 因为它们可以尝试将命令传播到副本和 AOF 文件。

除了所有只读脚本提供的优点之外, 只读脚本命令还具有以下优点：

*   它们可用于将 ACL 用户配置为只能执行只读脚本。
*   许多客户端还更好地支持将只读脚本命令路由到希望使用副本进行读取缩放的应用程序的副本。

#### 只读脚本历史记录

只读脚本和只读脚本命令在 Redis 7.0 中引入

*   在 Redis 7.0.1 之前`PUBLISH`,`SPUBLISH`和`PFCOUNT`不被视为脚本中的写入命令
*   在 Redis 7.0.1 之前`no-writes` [旗](/topics/lua-api#script_flags)没有暗示`allow-oom`
*   在 Redis 7.0.1 之前`no-writes`标志不允许脚本在写入暂停期间运行。

推荐的方法是将标准脚本命令与`no-writes`标记, 除非您需要前面提到的功能之一。

## 沙盒脚本上下文

Redis 将执行用户脚本的引擎放在沙盒中。
沙盒尝试防止意外误用并减少来自服务器环境的潜在威胁。

脚本不应尝试访问 Redis 服务器的基础主机系统 (如文件系统、网络) , 也不应尝试执行 API 支持之外的任何其他系统调用。

脚本应仅对存储在 Redis 中的数据以及作为其执行参数提供的数据进行操作。

## 最长执行时间

脚本有最长执行时间 (默认设置为五秒) 。
此默认超时非常严重, 因为脚本通常在不到一毫秒的时间内运行。
该限制用于处理开发过程中创建的意外无限循环。

可以修改脚本可以以毫秒精度执行的最长时间, 
通过`redis.conf`或者通过使用`CONFIG SET`命令。
影响最大执行时间的配置参数称为`busy-reply-threshold`.

当脚本达到超时阈值时, Redis 不会自动终止该脚本。
这样做将违反 Redis 和脚本引擎之间的契约, 该契约确保脚本是原子的。
中断脚本的执行可能会使数据集留下半写更改。

因此, 当脚本执行时间超过配置的超时时间时, 将发生以下情况：

*   Redis 会记录脚本运行时间过长的情况。
*   它再次开始接受来自其他客户端的命令, 但会向所有发送正常命令的客户端回复 BUSY 错误。在此状态下允许的唯一命令是`SCRIPT KILL`,`FUNCTION KILL`和`SHUTDOWN NOSAVE`.
*   可以使用以下命令终止仅执行只读命令的脚本`SCRIPT KILL`和`FUNCTION KILL`命令。这些命令不违反脚本语义, 因为脚本尚未将任何数据写入数据集。
*   如果脚本已经执行了哪怕一次写入操作, 则唯一允许的命令是`SHUTDOWN NOSAVE`停止服务器而不将当前数据集保存在磁盘上 (基本上, 服务器已中止) 。
