---
title: Key eviction
linkTitle: Eviction
weight: 1
description: Overview of Redis key eviction policies (LRU, LFU, etc.)
aliases: [
    /topics/lru_cache,
    /topics/lru_cache.md,
    /manual/eviction,
    /manual/eviction.md,
]
---

当 Redis 用作缓存时，在添加新数据时让它自动淘汰旧数据通常很方便。这种行为在开发者社区中是众所周知的，因为它是流行的 *memcached* 系统的默认行为。

本页涵盖了 Redis `maxmemory` 指令的更一般主题，该指令用于将内存使用限制为固定数量。这一页还深入介绍了 Redis 使用的 LRU 淘汰算法，这实际上是精确 LRU 的近似值。

## `Maxmemory` 配置指令

这`maxmemory`配置指令配置 Redis 为数据集使用指定的内存量。您可以使用`redis.conf`文件，或以后使用这`CONFIG SET`命令。

例如，要将内存限制配置为 100 MB，可以使用以下指令内部`redis.conf`文件：

    maxmemory 100mb

将 `maxmemory` 设置为零会导致没有内存限制。这是 64 位系统的默认行为，而 32 位系统使用 3GB 的隐式内存限制。

当达到指定的内存量时，**淘汰策略**的配置方式决定了默认行为.
Redis 可以为可能导致使用更多内存的命令返回错误，或者它可以逐出一些旧数据以在每次添加新数据时返回到指定的限制.

## 淘汰策略

当达到 `maxmemory` 限制时，Redis 遵循的确切行为是使用 `maxmemory-policy` 配置指令配置的。

以下策略可用：

*   **noeviction**：达到内存限制时不保存新值。当数据库使用复制时，这适用于主数据库
*   **allkeys-lru**：保留最近使用的 key ;删除最近最少使用的 (LRU)  key 
*   **allkeys-lfu**：保留常用键;删除最不常用 (LFU) 键
*   **volatile-lru**：删除最近最少使用的 key `expire`字段设置为`true`.
*   **volatile-lfu**：删除最不常用的键`expire`字段设置为`true`.
*   **allkeys-random**：随机删除键以为添加的新数据腾出空间。
*   **volatile-random**：随机删除键`expire`字段设置为`true`.
*   **volatile-ttl**：删除键`expire`字段设置为`true`和最短剩余生存时间 (TTL) 值。

策略**volatile-lru**,**volatile-lfu**,**volatile-random**和**volatile-ttl**行为方式很像**noeviction**, 在没有匹配先决条件的键来淘汰的情况下。

根据应用程序的访问模式选择正确的驱逐策略很重要，但是您可以在应用程序运行时在运行时重新配置策略，并使用 Redis 的 "INFO" 输出监控缓存未命中和命中的数量以调整设置。

一般来说，作为经验法则：

*   使用**allkeys-lru**策略，当您期望在请求的受欢迎程度中呈现幂律分布时。也就是说，您希望元素子集的访问频率远远高于其余元素。**如果您不确定，这是一个不错的选择**.

*   使用**allkeys-random**如果您具有连续扫描所有键的循环访问，或者当您期望分布均匀时。

*   使用**volatile-ttl**如果您希望能够在创建缓存对象时使用不同的 TTL 值向 Redis 提供有关什么是过期的良好候选项的提示。

这**volatile-lru**和**volatile-random**当您希望将单个实例用于缓存并具有一组持久键时，策略主要有用。但是，运行两个 Redis 实例来解决此类问题通常是一个更好的主意。

同样值得注意的是，设置`expire`值到 key 会消耗内存，因此使用类似于**allkeys-lru**内存效率更高，因为不需要`expire`配置，以便在内存压力下逐出 key 。

## 淘汰过程的工作原理

重要的是要了解淘汰过程的工作原理如下：

*   客户端运行新命令，从而添加更多数据。
*   Redis 检查内存使用情况，如果它大于`maxmemory`限制 ，它会根据策略逐出 key 。
*   执行新命令，依此类推。

因此，我们不断越过内存限制的边界，越过它，然后逐出键以返回到限制之下。

如果某个命令导致大量内存被使用(例如，将大集合交集存储到新键中)，则内存限制可能会明显超出。

## 近似 LRU 算法

Redis LRU 算法不是一个精确的实现。这意味着 Redis 无法选择*最佳候选者*进行淘汰，即过去访问最远的访问权限。相反，它将尝试运行 LRU 算法的近似值，通过对少量 key 进行采样，并逐出采样 key 中最好的(具有最旧访问时间)的 key 。

然而，从 Redis 3.0 开始，该算法得到了改进，同时也采用了一个良好的候选池进行淘汰。这提高了算法的性能，使其能够更接近真实 LRU 算法的行为。

Redis LRU 算法的重要之处在于，您**能够调整**算法的精度通过更改样本数量来检查每次淘汰。此参数由以下配置指令控制：

    maxmemory-samples 5

Redis 不使用真正的 LRU 实现的原因是因为它需要更多的内存。但是，对于使用 Redis 的应用程序，该近似值实际上是等效的。这张图比较了 Redis 使用的 LRU 逼近和真正的 LRU。

![LRU comparison](../images/lru_comparison.png)


生成上述图形的测试用给定数量的 key 填充了 Redis 服务器。 key 是从第一个到最后一个访问的。第一个键是使用 LRU 算法逐出的最佳候选项。后来又增加了50%的 key ，以强制一半的旧 key 被淘汰。

您可以在图表中看到三种点，形成三个不同的带。

*   浅灰色条带是被逐出的物体。
*   灰色条带是未被逐出的物体。
*   绿色条带是已添加的对象。

在理论上的 LRU 实现中，我们预计在旧 key 中，前半部分将过期。Redis LRU 算法将仅*概率*使旧 key 过期。

如您所见，与 Redis 2.8 相比，Redis 3.0 在 5 个样本中做得更好，但是 Redis 2.8 仍然保留了最新访问的大多数对象。在 Redis 3.0 中使用样本数量 10 时，近似值非常接近 Redis 3.0 的理论性能。

请注意，LRU 只是一个模型，用于预测给定 key 在未来被访问的可能性。此外，如果您的数据访问模式非常类似于幂律，则大多数访问将在 LRU 近似算法可以很好处理的 key 集中。

在模拟中，我们发现使用幂律访问模式，真正的 LRU 和 Redis 近似之间的差异很小或不存在。

但是，您可以以增加一些 CPU 使用为代价将样本大小提高到 10，以接近真实的 LRU，并检查这是否会影响您的缓存未命中率。

使用 `CONFIG SET maxmemory-samples <count>` 命令在生产中试验不同的样本大小值，非常简单。

## 新的 LFU 模式

从 Redis 4.0 开始，可以使用 [最不常用的淘汰模式](http://antirez.com/news/109)。在某些情况下，此模式可能会更好地工作(提供更好的命中/未命中率)。在 LFU 模式下，Redis 会尝试跟踪项目的访问频率，因此很少使用的会被淘汰。这意味着所使用的 key 通常有更高的机会保留在内存中。

要配置 LFU 模式，可以使用以下策略：

*   `volatile-lfu`在具有过期集的 key 中使用近似的 LFU 进行逐出。
*   `allkeys-lfu`使用近似的 LFU 逐出任何 key 。

LFU 近似于 LRU：它使用概率计数器，称为[Morris counter](https://en.wikipedia.org/wiki/Approximate_counting_algorithm)使用每个对象的几位来估计对象访问频率，并结合衰减周期，以便计数器随着时间的推移而减少。在某些时候，我们不再希望将 key 视为经常访问的 key ，即使它们在过去也是如此，以便算法可以适应访问模式的转变。

该信息的采样方式与 LRU(如本文档上一节中所述)选择逐出候选项时发生的情况类似。

然而，与 LRU 不同的是，LFU 具有某些可调参数：例如，如果不再访问排名较低的频繁项应该多快？还可以调整莫里斯计数器范围以更好地使算法适应特定用例。

默认情况下，Redis 配置为：

*   在大约一百万个请求时使计数器饱和。
*   每一分钟衰减一次计数器。

这些应该是合理的值，并经过实验测试，但用户可能希望使用这些配置设置来选择最佳值。

有关如何调整这些参数的说明，请参阅示例`redis.conf`文件。简而言之，它们是：

    lfu-log-factor 10
    lfu-decay-time 1

衰减时间是显而易见的，它是计数器在采样并发现比该值更旧时应衰减的分钟数。特殊值`0`意思是：我们永远不会腐烂计数器。

计数器*对数因子*改变了使频率计数器饱和所需的命中次数，它正好在 0-255 的范围内。系数越高，达到最大值所需的访问次数就越多。系数越低，计数器对低访问的分辨率越好，如下表所示：

    +--------+------------+------------+------------+------------+------------+
    | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
    +--------+------------+------------+------------+------------+------------+
    | 0      | 104        | 255        | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 1      | 18         | 49         | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 10     | 10         | 18         | 142        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 100    | 8          | 11         | 49         | 143        | 255        |
    +--------+------------+------------+------------+------------+------------+

因此，基本上，该因素是在更好地区分低访问量的项目与区分具有高访问量的项目之间的权衡。示例中提供了更多信息`redis.conf`文件。
