---
title: Key eviction
linkTitle: Eviction
weight: 1
description: Overview of Redis key eviction policies (LRU, LFU, etc.)
aliases: [
    /topics/lru_cache,
    /topics/lru_cache.md,
    /manual/eviction,
    /manual/eviction.md,
]
---

当 Redis 用作缓存时，通常方便地让它自动在添加新数据时逐出旧数据。此行为在开发人员社区，因为它是流行的默认行为*memcached*系统。

本页涵盖了 Redis 的更一般主题`maxmemory`用于将内存使用量限制为固定量的指令。此页面也涵盖在深度 Redis 使用的 LRU 逐出算法，这实际上是确切的 LRU。

## `Maxmemory`配置指令

这`maxmemory`配置指令配置 Redis为数据集使用指定的内存量。您可以使用`redis.conf`文件，或以后使用这`CONFIG SET`命令。

例如，要将内存限制配置为 100 MB，可以使用以下指令内部`redis.conf`文件：

    maxmemory 100mb

设置`maxmemory`到零结果进入无内存限制。这是64 位系统的默认行为，而 32 位系统使用隐式内存限制为 3GB。

当达到指定的内存量时，如何**逐出策略**已配置确定默认行为。Redis 可能会为可能导致更多内存的命令返回错误正在使用，或者它可以逐出一些旧数据以返回到每次添加新数据时指定限制。

## 逐出政策

Redis 遵循的确切行为是`maxmemory`达到的限制是
使用`maxmemory-policy`配置指令。

以下策略可用：

*   **禁止驱逐**：达到内存限制时不保存新值。当数据库使用复制时，这适用于主数据库
*   **allkeys-lru**：保留最近使用的密钥;删除最近最少使用的 （LRU） 密钥
*   **allkeys-lfu**：保留常用键;删除最不常用 （LFU） 键
*   **volatile-lru**：删除最近最少使用的密钥`expire`字段设置为`true`.
*   **挥发性-lfu**：删除最不常用的键`expire`字段设置为`true`.
*   **所有键-随机**：随机删除键以为添加的新数据腾出空间。
*   **挥发性随机**：随机删除键`expire`字段设置为`true`.
*   **挥发性**：删除键`expire`字段设置为`true`和最短剩余生存时间 （TTL） 值。

政策**volatile-lru**,**挥发性-lfu**,**挥发性随机**和**挥发性**行为方式**禁止驱逐**如果没有与先决条件匹配的要逐出的键。

选择正确的逐出策略非常重要，具体取决于访问模式，但是，您可以在运行时重新配置策略，同时应用程序正在运行，并监视缓存未命中和命中数使用 Redis`INFO`输出以调整您的设置。

一般来说，作为经验法则：

*   使用**allkeys-lru**策略，当您期望在请求的受欢迎程度中幂律分布时。也就是说，您希望元素子集的访问频率远远高于其余元素。**如果您不确定，这是一个不错的选择**.

*   使用**所有键-随机**如果您具有连续扫描所有键的循环访问，或者当您期望分布均匀时。

*   使用**挥发性**如果您希望能够在创建缓存对象时使用不同的 TTL 值向 Redis 提供有关什么是过期的良好候选项的提示。

这**volatile-lru**和**挥发性随机**当您希望将单个实例用于缓存并具有一组持久键时，策略主要有用。但是，运行两个 Redis 实例来解决此类问题通常是一个更好的主意。

同样值得注意的是，设置`expire`值到密钥会消耗内存，因此使用类似于**allkeys-lru**内存效率更高，因为不需要`expire`配置，以便在内存压力下逐出密钥。

## 驱逐过程的工作原理

重要的是要了解驱逐过程的工作原理如下：

*   客户端运行新命令，从而添加更多数据。
*   Redis 检查内存使用情况，如果它大于`maxmemory`限制 ，它会根据策略逐出密钥。
*   执行新命令，依此类推。

因此，我们不断越过内存限制的边界，越过它，然后逐出键以返回到限制之下。

如果某个命令导致大量内存被使用（例如，将大集合交集存储到新键中），则内存限制可能会明显超出。

## 近似 LRU 算法

Redis LRU 算法不是一个精确的实现。这意味着 Redis 是无法选择*最佳候选人*驱逐，即访问是过去访问最远的地方。相反，它将尝试运行近似值的 LRU 算法，通过对少量键进行采样，并逐出一个是采样密钥中最好的（具有最旧的访问时间）。

但是，自Redis 3.0以来，算法得到了改进，也采取了良好的池子。驱逐的候选人。这提高了算法的性能，使它能够更接近真实LRU算法的行为。

Redis LRU 算法的重要之处在于，您**能够调整**算法的精度通过更改样本数量来检查每次驱逐。此参数由以下配置指令控制：

    maxmemory-samples 5

Redis 不使用真正的 LRU 实现的原因是因为它消耗更多内存。但是，对于使用 Redis 的应用程序。此图比较Redis 使用的具有真 LRU 的 LRU 近似值。

![LRU comparison](../../images/lru_comparison.png)

生成上述图形的测试用给定数量的密钥填充了 Redis 服务器。密钥是从第一个到最后一个访问的。第一个键是使用 LRU 算法逐出的最佳候选项。后来又增加了50%的密钥，以强制一半的旧密钥被驱逐。

您可以在图表中看到三种点，形成三个不同的带。

*   浅灰色条带是被逐出的物体。
*   灰色条带是未被逐出的物体。
*   绿色条带是已添加的对象。

在理论上的 LRU 实现中，我们预计在旧密钥中，前半部分将过期。Redis LRU 算法将仅*概率*使旧密钥过期。

如您所见，与 Redis 2.8 相比，Redis 3.0 在 5 个样本中做得更好，但是 Redis 2.8 仍然保留了最新访问的大多数对象。在 Redis 3.0 中使用样本数量 10 时，近似值非常接近 Redis 3.0 的理论性能。

请注意，LRU 只是一个模型，用于预测将来访问给定密钥的可能性。此外，如果您的数据访问模式紧密结合类似于幂律，大多数访问将在密钥集中LRU近似算法可以很好地处理。

在仿真中，我们发现使用幂律访问模式，真LRU和Redis近似之间的差异很小或根本不存在。

但是，您可以将样本数量提高到 10，但需要一些额外的 CPU用于接近真正的LRU，并检查这是否使缓存未命中率的差异。

要在生产中使用不同的样本数量值进行试验，请使用
这`CONFIG SET maxmemory-samples <count>`命令，很简单。

## 新的 LFU 模式

从 Redis 4.0 开始，[最不常用的逐出模式](http://antirez.com/news/109)可用。此模式可能效果更好（提供更好的命中/未命中比率）在某些情况下。在LFU模式下，Redis将尝试跟踪访问物品的频率，因此很少使用的物品被驱逐。这意味着使用的密钥通常有更高的机会保留在内存中。

要配置 LFU 模式，可以使用以下策略：

*   `volatile-lfu`在具有过期集的密钥中使用近似的 LFU 进行逐出。
*   `allkeys-lfu`使用近似的 LFU 逐出任何密钥。

LFU近似于LRU：它使用概率计数器，称为[莫里斯计数器](https://en.wikipedia.org/wiki/Approximate_counting_algorithm)使用每个对象的几位来估计对象访问频率，并结合衰减周期，以便计数器随着时间的推移而减少。在某些时候，我们不再希望将密钥视为经常访问的密钥，即使它们在过去也是如此，以便算法可以适应访问模式的转变。

该信息的采样方式与 LRU（如本文档上一节中所述）选择逐出候选项时发生的情况类似。

然而，与LRU不同的是，LFU具有某些可调参数：例如，速度有多快如果不再访问频繁的项目，它的排名是否应该降低？还可以调整 Morris 计数器范围，以便更好地使算法适应特定用例。

默认情况下，Redis 配置为：

*   在大约一百万个请求时使计数器饱和。
*   每一分钟衰减一次计数器。

这些应该是合理的值，并经过实验测试，但用户可能希望使用这些配置设置来选择最佳值。

有关如何调整这些参数的说明，请参阅示例`redis.conf`文件。简而言之，它们是：

    lfu-log-factor 10
    lfu-decay-time 1

衰减时间是显而易见的，它是计数器在采样并发现比该值更旧时应衰减的分钟数。特殊值`0`意思是：我们永远不会腐烂计数器。

柜台*对数因子*更改使频率计数器饱和所需的命中数，该计数器仅在 0-255 范围内。因子越高，达到最大值所需的访问次数就越多。系数越低，计数器在低访问情况下的分辨率越高，如下表所示：

    +--------+------------+------------+------------+------------+------------+
    | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
    +--------+------------+------------+------------+------------+------------+
    | 0      | 104        | 255        | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 1      | 18         | 49         | 255        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 10     | 10         | 18         | 142        | 255        | 255        |
    +--------+------------+------------+------------+------------+------------+
    | 100    | 8          | 11         | 49         | 143        | 255        |
    +--------+------------+------------+------------+------------+------------+

因此，基本上，该因素是在更好地区分低访问量的项目与区分具有高访问量的项目之间的权衡。示例中提供了更多信息`redis.conf`文件。
