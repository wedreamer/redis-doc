---
title: Redis persistence
linkTitle: Persistence
weight: 1
description: How Redis writes data to disk (append-only files, snapshots, etc.)
aliases: [
    /topics/persistence,
    /topics/persistence.md,
    /manual/persistence,
    /manual/persistence.md,
]
---

持久性是指将数据写入持久存储, 例如固态磁盘 (SSD)。 Redis 本身提供了一系列持久化选项：

*   **RDB**(Redis 数据库)：RDB 持久性按指定的时间间隔执行数据集的时间点快照。
*   **AOF**(仅追加文件)：AOF 持久性记录服务器收到的每个写入操作, 这些操作将在服务器启动时再次播放, 从而重建原始数据集。命令使用与 Redis 协议本身相同的格式以仅追加的方式进行记录。Redis 能够 [重写](#log-rewriting)日志, 当在后台变得太大时。
*   **无持久性**：如果您愿意, 可以完全禁用持久性, 如果您希望数据在服务器运行期间就存在。
*   **RDB + AOF**：可以在同一实例中同时组合 AOF 和 RDB。请注意, 在这种情况下, 当 Redis 重新启动时, 将使用 AOF 文件来重建原始数据集, 因为它保证是最完整的。

最重要的是要了解 RDB 和 AOF 持久性之间的不同取舍。

## RDB 的优势

*   RDB 是 Redis 数据的非常紧凑的单文件时间点表示形式。RDB 文件非常适合备份。例如, 您可能希望在最近 24 小时内每小时存档一次 RDB 文件, 并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松还原数据集的不同版本。
*   RDB 非常适合灾难恢复, 它是一个可以传输到远程数据中心或 Amazon S3(可能加密)的单个紧凑文件。
*   RDB 最大限度地提高了 Redis 的性能, 因为 Redis 父进程为了持久化而需要做的唯一工作就是 fork 一个将完成其余所有工作的子进程。父进程永远不会执行磁盘 I/O 或类似操作。
*   与 AOF 相比, RDB 允许使用大数据集更快地重新启动。
*   在副本上, RDB 支持[重新启动和故障转移后的部分重新同步](https://redis.io/topics/replication#partial-resynchronizations-after-restarts-and-failovers).

## RDB 的缺点

*   如果您需要在 Redis 停止工作(例如停电后)将数据丢失的可能性降至最低, 则 RDB 并不好。您可以配置不同的*保存值*生成 RDB 的位置(例如, 在对数据集进行至少 5 分钟和 100 次写入后, 可以有多个保存点)。但是, 您通常会每五分钟或更长时间创建一个 RDB 快照, 因此, 如果 Redis 因任何原因在没有正确关闭的情况下停止工作, 您应该准备好丢失最新几分钟的数据。
*   RDB 经常需要 fork() 才能使用子进程保留在磁盘上。如果数据集很大, fork() 可能会很耗时, 并且可能导致 Redis 停止为客户端提供服务几毫秒, 如果数据集非常大并且 CPU 性能不是很好, 甚至停止一秒钟。AOF 也需要 fork()但频率较低, 您可以调整重写日志的频率, 而无需在持久性上进行任何权衡。

## AOF优势

*   使用 AOF Redis 更持久：您可以拥有不同的 fsync 策略：完全没有 fsync, 每秒fsync, 每次查询时都有 fsync。使用每秒 fsync 的默认策略, 写入性能仍然很高。fsync是使用后台线程执行的, 当没有 fsync 正在进行时, 主线程将努力执行写入, 因此您只能丢失一秒钟的写入。
*   AOF 日志是仅追加日志, 因此在断电时不会出现寻道或损坏问题。即使由于某种原因(磁盘已满或其他原因), 日志也能够以半写命令结尾, redis-check-aof 工具也能够轻松修复它。
*   Redis 能够在 AOF 变得太大时在后台自动重写它。重写是完全安全的, 因为当 Redis 继续附加到旧文件时, 使用创建当前数据集所需的最少操作集生成一个全新的文件, 一旦第二个文件准备就绪, Redis 就会切换两个文件并开始附加到新文件。
*   AOF 以易于理解和解析的格式一个接一个地包含所有操作的日志。您甚至可以轻松导出 AOF 文件。例如, 即使您不小心使用`FLUSHALL`命令, 只要在此期间没有执行日志重写, 您仍然可以通过停止服务器, 删除最新命令并再次重新启动 Redis 来保存数据集。

## AOF 缺点

*   AOF 文件通常比同一数据集的等效 RDB 文件大。
*   AOF 可能比 RDB 慢, 具体取决于确切的 fsync 策略。通常, 将 fsync 设置为*每秒*性能仍然非常高, 并且在禁用 fsync 的情况下, 即使在高负载下, 它也应该与 RDB 一样快。 RDB 仍然能够为最大延迟提供更多保证, 即使在巨大的写入负载的情况下也是如此。

**Redis < 7.0**

*   如果在重写期间对数据库进行写入, AOF 可以使用大量内存(这些写入内存并在最后写入新的 AOF)。
*   在重写期间到达的所有写入命令都将写入磁盘两次。
*   Redis 可以在重写结束时冻结写入并将这些写入命令同步到新的 AOF 文件。

## 好吧, 那么我应该使用什么？

您应该同时使用这两种持久性方法的一般指示是你想要一定程度的数据安全性, 可以与 PostgreSQL 可以为您提供的相当。

如果你非常关心你的数据, 但仍然可以忍受几分钟, 如果发生灾难, 数据丢失, 您可以简单地单独使用RDB。

有许多用户单独使用 AOF, 但我们不鼓励使用它, 因为要有一个 RDB 快照不时是进行数据库备份的好主意, 用于更快的重新启动, 以及在 AOF 引擎中出现错误时。

以下各节将阐释有关这两个持久性模型的更多详细信息。

## 快照

默认情况下, Redis 将数据集的快照保存在磁盘上的二进制文件中文件调用`dump.rdb`.您可以将 Redis 配置为让它保存数据集每 N 秒一次, 如果数据集中至少有 M 个变化, 或者您可以手动调用`SAVE`或`BGSAVE`命令。

例如, 此配置将使 Redis 自动转储数据集每 60 秒到磁盘, 如果至少有 1000 个 key 已更改：

    save 60 1000

此策略称为*快照*.

### 它是如何运作的

每当 Redis 需要将数据集转储到磁盘时, 就会发生这种情况：

*   Redis[fork](http://linux.die.net/man/2/fork).我们现在有了一个子进程
    和父进程。

*   子进程开始将数据集写入临时 RDB 文件。

*   当孩子写完新的 RDB 文件后, 它会替换旧的。

此方法允许 Redis 从写入时复制语义中受益。

## 仅追加文件

快照不是很持久。如果运行 Redis 的计算机停止运行, 您的电源线出现故障, 或者您不小心`kill -9`您的实例, 写入 Redis 的最新数据将丢失。 虽然这可能不是一个大问题对于某些应用程序, 有完全耐久性的用例, 以及在这些情况下, 仅靠 Redis 快照不是一个可行的选择。

这*仅追加文件*是一种替代的、完全持久的策略, 用于 Redis。 它在版本1.1中可用。

您可以在配置文件中打开 AOF：

    appendonly yes

从现在开始, 每次 Redis 收到一个命令, 该命令会更改数据集(例如`SET`), 它将它附加到AOF。 重新启动时 Redis 它将重新播放 AOF 以重建状态。

从 Redis 7.0.0 开始, Redis 使用多部分 AOF 机制。
也就是说, 原始的单个 AOF 文件被拆分为基文件(最多一个)和增量文件(可能有多个)。
基文件表示当 AOF 为[重写](#log-rewriting).
增量文件包含自上次创建基本 AOF 文件以来的增量更改。所有这些文件都放在一个单独的目录中, 并由清单文件跟踪。

### 日志重写

随着写入操作的进行, AOF 变得越来越大执行。 例如, 如果要将计数器递增 100 倍, 你最终会在数据集中得到一个 key , 其中包含最终的值, 但 AOF 中有 100 个条目。其中 99 个条目是不需要的以重建当前状态。

重写是完全安全的。当 Redis 继续追加到旧文件时, 使用创建当前数据集所需的最少操作集生成一个全新的操作集, 一旦第二个文件准备就绪, Redis 就会切换两个文件并开始附加到新文件。

因此, Redis 支持一个有趣的功能：它能够重建AOF。在后台, 而不会中断对客户端的服务。每当您发出`BGREWRITEAOF`, Redis 将编写最短的序列在内存中重建当前数据集所需的命令。 如果你是将 AOF 与 Redis 2.2 配合使用, 您需要运行`BGREWRITEAOF`不时到时间。由于 Redis 2.4 能够自动触发日志重写(请参阅示例配置文件以获取更多信息)。

从 Redis 7.0.0 开始, 当计划 AOF 重写时, Redis 父进程将打开一个新的增量 AOF 文件以继续写入。
子进程执行重写逻辑并生成新的基 AOF。
Redis 将使用临时清单文件来跟踪新生成的基文件和增量文件。
准备就绪后, Redis 将执行原子替换操作, 以使此临时清单文件生效。
为了避免在 AOF 重写重复失败和重试的情况下创建许多增量文件的问题,  Redis 引入了 AOF 重写限制机制, 以确保以越来越慢的速度重试失败的 AOF 重写。

### 仅追加文件的持久性如何？

您可以配置 Redis 的次数
[`fsync`](http://linux.die.net/man/2/fsync)磁盘上的数据。有三个选项：

*   `appendfsync always`:`fsync`每次将新命令追加到 AOF 时。非常非常慢, 非常安全。请注意, 在执行来自多个客户端或管道的一批命令后, 这些命令将追加到 AOF, 因此这意味着一次写入和一次 fsync(在发送回复之前)。
*   `appendfsync everysec`:`fsync`每一秒。足够快(因为版本 2.4 可能与快照一样快), 如果发生灾难, 您可能会丢失 1 秒的数据。
*   `appendfsync no`： 从不`fsync`, 只需将您的数据交到操作系统的手中即可。更快, 安全性较低的方法。通常, Linux 会使用此配置每 30 秒刷新一次数据, 但这取决于内核的精确调优。

建议(和默认)策略是每秒执行一次 "fsync"。它既快速又相对安全。 `always` 策略在实践中很慢, 但它支持组提交, 所以如果有多个并行写入, Redis 会尝试执行单个 `fsync` 操作。

### 如果我的 AOF 被截断, 我该怎么办？

服务器在写入 AOF 文件时可能崩溃, 或者在写入时, 存储 AOF 文件的卷已满。当这种情况发生时, AOF 仍包含表示给定时间点版本的一致数据的数据集(使用默认的 AOF fsync, 可能最多为一秒策略), 但 AOF 中的最后一个命令可能会被截断。无论如何, Redis 的最新主要版本都能够加载 AOF, 只需丢弃文件中最后一个格式不正确的命令。在这种情况下, 服务器将发出类似以下内容的日志：

    * Reading RDB preamble from AOF file...
    * Reading the remaining AOF tail...
    # !!! Warning: short read while loading the AOF file !!!
    # !!! Truncating the AOF at offset 439 !!!
    # AOF loaded anyway because aof-load-truncated is enabled

您可以更改默认配置以强制 Redis 在此类环境中停止案例, 如果需要, 但默认配置是继续, 而不考虑文件中的最后一个命令格式不正确, 以保证重新启动后的可用性。

较旧版本的 Redis 可能无法恢复, 并且可能需要执行以下步骤：

*   制作 AOF 文件的备份副本。

*   使用`redis-check-aof`Redis 附带的工具：

        $ redis-check-aof --fix <filename>

*   可选使用`diff -u`以检查两个文件之间的区别。

*   使用固定文件重新启动服务器。

### 如果我的 AOF 损坏了, 我该怎么办？

如果 AOF 文件不仅被截断, 而且被无效字节损坏中间的序列, 事情就比较复杂了。Redis 会抱怨在启动时, 将中止：

    * Reading the remaining AOF tail...
    # Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>

最好的办法是运行`redis-check-aof`实用程序, 最初没有这`--fix`选项, 然后了解问题, 跳转到给定的文件中的偏移量, 并查看是否可以手动修复该文件：AOF 使用与 Redis 协议相同的格式, 并且修复起来非常简单手动地。否则, 可以让实用程序为我们修复文件, 但是在这种情况下, 从无效部分到末尾的所有 AOF 部分文件可能会被丢弃, 导致大量数据丢失, 如果损坏恰好在文件的初始部分。

### 它是如何运作的

日志重写使用相同的写入时复制技巧, 这些技巧已用于快照。 这是它的工作原理：

**Redis >= 7.0**

*   Redis[fork](http://linux.die.net/man/2/fork), 所以现在我们有了一个子进程和父进程。

*   子级开始在临时文件中写入新的基 AOF。

*   父级打开一个新的增量 AOF 文件以继续写入更新。
    如果重写失败, 旧的基础和增量文件 (如果有的话) 加上这个新打开的增量文件就代表了完整的更新数据集, 所以我们是安全的。

*   当孩子完成对基础文件的重写后, 父母会收到一个信号, 并使用新打开的增量文件和孩子生成的基础文件来构建临时清单, 并将其持久化。

*   好处！现在 Redis 对清单文件进行原子交换, 以便此 AOF 重写的结果生效。 Redis 还会清理旧的基础文件和任何未使用的增量文件。

**Redis < 7.0**

*   Redis[fork](http://linux.die.net/man/2/fork), 所以现在我们有了一个孩子
    和父进程。

*   孩子开始在临时文件中写入新的 AOF。

*   父级在内存缓冲区中累积所有新更改 (但同时它将新更改写入旧的仅附加文件中, 因此如果重写失败, 我们是安全的) .

*   当子进程完成文件重写后, 父进程会收到一个信号, 并将内存缓冲区附加到子进程生成的文件末尾.

*   现在 Redis 以原子方式将新文件重命名为旧文件, 并开始将新数据附加到新文件中.

### 如果我当前正在使用 dump.rdb 快照, 如何切换到 AOF？

在版本 2.0 及更高版本中执行此操作的过程不同, 因为您可以猜到它比 Redis 2.2 更简单, 根本不需要重新启动。

**Redis >= 2.2**

*   备份最新的 dump.rdb 文件。
*   将此备份传输到安全位置。
*   发出以下两个命令：
*   `redis-cli config set appendonly yes`
*   `redis-cli config set save ""`
*   确保数据库包含的 key 数与它所包含的 key 数相同。
*   确保将写入内容正确追加到仅追加文件。

第一个 CONFIG 命令启用 "仅追加文件" 持久性。

第二个 CONFIG 命令用于关闭快照持久性。这是可选的, 如果您愿意, 可以启用这两种持久性方法。

**重要**请记住编辑 redis.conf 以打开 AOF, 否则重新启动服务器时, 配置更改将丢失, 并且服务器将使用旧配置再次启动。

**Redis 2.0**

*   备份最新的 dump.rdb 文件。
*   将此备份传输到安全位置。
*   停止对数据库的所有写入！
*   发出`redis-cli BGREWRITEAOF`.这将创建仅追加文件。
*   在 Redis 完成生成 AOF 转储时停止服务器。
*   编辑 redis.conf 结束启用仅追加文件持久性。
*   重新启动服务器。
*   请确保您的数据库包含的 key 数与切换之前包含的 key 数相同。
*   确保将写入内容正确追加到仅追加文件。

## AOF 和 RDB 持久性之间的交互

Redis >= 2.4 确保在 RDB 时避免触发 AOF 重写快照操作已在进行中, 或允许`BGSAVE`而 AOF 重写正在进行中。这可以防止两个 Redis 后台进程从同时执行繁重的磁盘 I/O。

当快照正在进行并且用户显式请求日志时重写操作使用`BGREWRITEAOF`服务器将回复 "确定" 状态代码告诉用户操作已计划, 并重写将在快照完成后启动。

如果同时启用了 AOF 和 RDB 持久性, 并且 Redis 重新启动 AOF 文件将用于重建原始数据集, 因为它是保证是最完整的。

## 备份 Redis 数据

在开始本节之前, 请务必阅读下面的话：**确保备份您的数据库**。磁盘损坏, 云中的实例消失等等：没有备份意味着数据消失到 /dev/null 的巨大风险。

Redis 是非常数据备份友好的, 因为你可以复制 RDB 文件, 而数据库正在运行：RDB 一旦产生就永远不会被修改, 而当它生产它使用临时名称并重命名为其最终目的地原子地使用 rename(2) 只有在新快照完成时。

这意味着在服务器运行时复制 RDB 文件是完全安全的。这就是我们的建议：

*   在服务器中创建一个 cron 作业, 在一个目录中创建 RDB 文件的每小时快照, 在另一个目录中创建每日快照。
*   每次运行 cron 脚本时, 请确保调用`find`命令以确保删除太旧的快照：例如, 您可以拍摄最近 48 小时的每小时快照, 以及一到两个月的每日快照。确保使用日期和时间信息命名快照。
*   每天至少传输一次, 确保传输 RDB 快照*数据中心外部*或至少*物理机外部*运行您的 Redis 实例。

### 备份 AOF 持久性

如果您运行仅启用了 AOF 持久性的 Redis 实例, 您仍然可以执行备份。
从 Redis 7.0.0 开始, AOF 文件被拆分为多个文件, 这些文件驻留在由`appenddirname`配置。
在正常操作期间, 您需要做的就是 copy/tar此目录中的文件以实现备份。但是, 如果在[重写](#log-rewriting), 则最终可能会得到无效的备份。
要解决此问题, 您必须在备份期间禁用 AOF 重写：

1.  关闭自动重写<br/>
    `CONFIG SET` `auto-aof-rewrite-percentage 0`<br/>
    确保不要手动启动重写(使用`BGREWRITEAOF`)在此期间。
2.  使用检查当前没有正在进行的重写<br/>
    `INFO` `persistence`<br/>
    并验证`aof_rewrite_in_progress`为 0。如果是 1, 则需要等待重写完成。
3.  现在, 您可以安全地复制`appenddirname`目录。
4.  完成后重新启用重写：<br/>
    `CONFIG SET` `auto-aof-rewrite-percentage <prev-value>`

**注意：**如果要最大程度地缩短禁用 AOF 重写的时间, 则可以创建指向`appenddirname`(在上面的步骤 3 中), 然后在创建硬链接后重新启用重写(步骤 4)。
现在, 您可以复制/标记硬链接并在完成后将其删除。这是有效的, 因为Redis保证它仅附加到此目录中的文件, 或在必要时完全替换它们, 因此内容应在任何给定时间点保持一致。

**注意：**如果要处理在备份期间重新启动服务器的情况, 并确保重新启动后不会自动开始重写, 则可以更改上面的步骤1, 以通过以下方式保留更新的配置`CONFIG REWRITE`.
只需确保在完成后重新启用自动重写(步骤4), 并将其与另一个步骤一起保留`CONFIG REWRITE`.

在 7.0.0 版之前, 只需复制 aof 文件(如备份 RDB 快照)即可备份 AOF 文件。文件可能缺少最终部分
但是 Redis 仍然能够加载它(请参阅前面的部分[截断的 AOF 文件](#what-should-i-do-if-my-aof-gets-truncated)).

1.  关闭自动重写<br/>
    `CONFIG SET` `auto-aof-rewrite-percentage 0`<br/>
    确保不要手动启动重写(使用`BGREWRITEAOF`)在此期间。
2.  使用检查当前没有正在进行的重写<br/>
    `INFO` `persistence`<br/>
    并验证`aof_rewrite_in_progress`为 0。如果是 1, 则需要等待重写完成。
3.  现在, 您可以安全地复制`appenddirname`目录。
4.  完成后重新启用重写：<br/>
    `CONFIG SET` `auto-aof-rewrite-percentage <prev-value>`

**注意：**如果要最大程度地缩短禁用 AOF 重写的时间, 则可以创建指向`appenddirname`(在上面的步骤 3 中), 然后在创建硬链接后重新启用重写(步骤 4)。
现在, 您可以复制/标记硬链接并在完成后将其删除。这是有效的, 因为Redis保证它仅附加到此目录中的文件, 或在必要时完全替换它们, 因此内容应在任何给定时间点保持一致。

**注意：**如果要处理在备份期间重新启动服务器的情况, 并确保重新启动后不会自动开始重写, 则可以更改上面的步骤1, 以通过以下方式保留更新的配置`CONFIG REWRITE`.
只需确保在完成后重新启用自动重写(步骤4), 并将其与另一个步骤一起保留`CONFIG REWRITE`.

在 7.0.0 版本之前, 备份 AOF 文件可以简单地通过复制 aof 文件来完成 (就像备份 RDB 快照一样) 。该文件可能缺少最后一部分, 但 Redis 仍然能够加载它 (请参阅前面有关 [截断 AOF 文件](#what-should-i-do-if-my-aof-gets-truncated) 的部分) .

## 灾难恢复

Redis 环境中的灾难恢复基本上与备份, 以及在许多不同的外部环境中传输这些备份的能力数据中心。这样, 即使在发生灾难性事件时也能保护数据影响运行 Redis 的主数据中心并生成其事件的事件快照。

我们将回顾最有趣的灾难恢复技术成本不会太高。

*   Amazon S3 和其他类似服务是实施灾难恢复系统的好方法。只需以加密形式将每日或每小时 RDB 快照传输到 S3 即可。您可以使用以下命令加密数据`gpg -c`(在对称加密模式下)。确保将密码存储在许多不同的安全位置(例如, 将副本提供给组织中最重要的人员)。建议使用多个存储服务以提高数据安全性。
*   使用 SCP (SSH 的一部分) 将您的快照传输到远程服务器。这是一个相当简单和安全的方法：在离你很远的地方找一个小型 VPS, 在那里安装 ssh, 并生成一个没有密码的 ssh 客户端密钥, 然后将其添加到你的小型 VPS 的 `authorized_keys` 文件中。您已准备好以自动方式传输备份。在两个不同的提供商中获得至少两个 VPS 为获得最佳结果。

重要的是要了解, 如果没有, 这个系统很容易失败。以正确的方式实施。至少, 绝对确保在传输已完成, 您可以验证文件大小(应匹配您复制的文件之一), 也可能是 SHA1 摘要(如果您使用的是一个 VPS。

您还需要某种独立的警报系统, 如果转移新鲜备份由于某种原因不起作用。
