---
title: Redis replication
linkTitle: Replication
weight: 1
description: How Redis supports high availability and failover with replication
aliases: [
    /topics/replication,
    /topics/replication.md,
    /manual/replication,
    /manual/replication.md,
]
---

在 Redis 复制的基础 (不包括 Redis Cluster 或 Redis Sentinel 作为附加层提供的高可用性功能) , 有一个*领导者追随者*易于使用和配置的 (主副本) 复制。它允许副本 Redis 实例是主实例的精确副本。每次链路断开时, 副本将自动重新连接到主服务器, 并尝试成为其精确副本*无论*发生在主人身上的事情。

该系统使用三种主要机制工作：

1.  当主实例和副本实例连接良好时, 主实例通过向副本发送命令流来复制, 由于以下原因而对主端发生的数据集的影响, 从而保持副本更新：客户端写入、key 过期或逐出, 任何其他操作更改了主数据集。
2.  当主服务器和副本之间的链路断开时, 由于网络问题, 或者由于在主服务器或副本中检测到超时, 副本将重新连接并尝试继续进行部分重新同步：这意味着它将尝试仅获取在断开连接期间错过的部分命令流。
3.  当无法进行部分重新同步时, 副本将要求完全重新同步。这将涉及一个更复杂的过程, 其中主服务器需要创建其所有数据的快照, 将其发送到副本, 然后在数据集更改时继续发送命令流。

Redis 默认使用异步复制，低延迟、高性能，是绝大多数 Redis 用例的自然复制模式。但是，Redis 副本会异步确认它们定期与主服务器接收的数据量。因此，master 不会每次都等待副本处理命令，但是如果需要，它知道哪个副本已经处理了哪个命令。这允许具有可选的同步复制。

客户端可以使用 "WAIT" 命令请求某些数据的同步复制。但是 WAIT 只能保证其他 Redis 实例中有指定数量的已确认副本，它不会将一组 Redis 实例变成具有强一致性的 CP 系统：在故障转移期间确认的写入仍然可能丢失，取决于 Redis 持久性的确切配置。然而，使用 "WAIT"，在失败事件后丢失写入的概率大大降低到某些难以触发的失败模式。

您可以查看 Redis Sentinel 或 Redis Cluster 文档以获取更多信息关于高可用性和故障转移。本文档的其余部分主要介绍 Redis 基本复制的基本特征。

### 有关 Redis 复制的重要事实

*   Redis 使用异步复制, 通过异步副本到主服务器确认处理的数据量。
*   一个主节点可以有多个副本。
*   副本能够接受来自其他副本的连接。除了将多个副本连接到同一主节点之外, 副本还可以以类似级联的结构连接到其他副本。从 Redis 4.0 开始, 所有子副本都将从主服务器接收完全相同的复制流。
*   Redis 复制在主端是非阻塞的。这意味着, 当一个或多个副本执行初始同步或部分重新同步时, 主服务器将继续处理查询。
*   复制在副本端也在很大程度上是非阻塞的。当副本执行初始同步时, 它可以使用旧版本的数据集处理查询, 前提是您在 redis.conf 中将 Redis 配置为这样做。 否则, 您可以将 Redis 副本配置为在复制流关闭时向客户端返回错误。但是, 在初始同步后, 必须删除旧数据集, 并且必须加载新数据集。副本将在此短暂时段内阻止传入连接 (对于非常大的数据集, 该时段可长达数秒) 。从 Redis 4.0 开始, 您可以配置 Redis, 以便删除旧数据集发生在不同的线程中, 但是加载新的初始数据集仍将在主线程中进行并阻止副本。
*   复制既可以用于可伸缩性, 也可以用于为只读查询提供多个副本 (例如, 可以将慢速 O (N)  操作卸载到副本) , 也可以仅用于提高数据安全性和高可用性。
*   您可以使用复制来避免让主服务器将完整数据集写入磁盘的成本：典型的技术是配置主服务器`redis.conf`以避免永久保存到磁盘, 然后连接配置为不时保存的副本, 或启用 AOF。但是, 必须小心处理此设置, 因为重新启动的主节点将从空数据集开始：如果副本尝试与其同步, 则副本也将被清空。

## 主服务器关闭持久化时复制的安全性

在使用 Redis 复制的设置中，强烈建议在主服务器和副本中打开持久性。如果无法做到这一点，例如由于磁盘速度非常慢而导致延迟问题，则应将实例配置为**避免在重新启动后自动重新启动**。

为了更好地理解为什么关闭持久性并配置为自动重启的 master 很危险，请检查以下故障模式，其中数据从 master 及其所有副本中擦除：

1.  我们有一个设置, 节点A充当主节点, 持久性关闭, 节点B和C从节点A复制。
2.  节点 A 崩溃, 但是它有一些自动重新启动系统, 用于重新启动进程。但是, 由于持久性已关闭, 因此节点将使用空数据集重新启动。
3.  节点 B 和 C 将从节点 A 复制, 节点 A 是空的, 因此它们将有效地销毁其数据副本。

当 Redis Sentinel 用于实现高可用性时, 也会关闭持久性在主服务器上, 加上进程的自动重启, 是危险的。例如, 主服务器可以足够快地重新启动, 以使 Sentinel 不检测到故障, 从而发生上述故障模式。

每当数据安全很重要, 并且复制是在配置了没有持久性的主节点的情况下使用的, 就应该禁用实例的自动重启。

## Redis 复制的工作原理

每个 Redis 主节点都有一个复制 ID：它是一个大的伪随机字符串标记数据集的给定故事。每个主控形状还采用一个偏移量生成复制流的每个字节的增量发送到副本, 以使用新更改更新副本的状态修改数据集。即使没有副本, 复制偏移量也会递增实际上是连接的, 所以基本上每个给定的对：

    Replication ID, offset

标识主数据集的确切版本。

当副本连接到主服务器时, 它们使用`PSYNC`要发送的命令他们的旧主复制 ID 和他们到目前为止处理的偏移量。这边主站可以只发送所需的增量部分。但是, 如果没有足够*储备*在主缓冲区中, 或者如果复制副本引用不再已知的历史记录 (复制 ID) , 然后完全重新同步发生：在这种情况下, 副本将从头开始获取数据集的完整副本。

以下是完整同步在更多详细信息中的工作方式：

主服务器启动后台保存过程以生成 RDB 文件。同时, 它开始缓冲从客户端接收的所有新写入命令。后台保存完成后, 主数据库将数据库文件传输到副本, 副本将其保存在磁盘上, 然后将其加载到内存中。然后, 主服务器会将所有缓冲的命令发送到副本。这是作为命令流完成的, 并且采用与Redis协议本身相同的格式。

您可以通过远程登录自行尝试。连接到 Redis 端口, 同时服务器正在做一些工作, 并发出`SYNC`命令。你会看到一个批量传输, 然后主站收到的每个命令都将重新发出在远程登录会话中。实际上`SYNC`是不再使用的旧协议较新的 Redis 实例, 但仍存在向后兼容性：它确实不允许部分重新同步, 所以现在`PSYNC`而是使用。

如前所述, 当主副本链路由于某种原因而关闭时, 副本能够自动重新连接。如果主服务器收到多个并发副本同步请求, 它将执行单个后台保存以为所有请求提供服务。

## 复制 ID 说明

在上一节中, 我们说过, 如果两个实例具有相同的复制ID 和复制偏移, 它们具有完全相同的数据。但是它很有用了解复制 ID 到底是什么, 以及为什么实例实际上具有两个复制 ID：主 ID 和辅助 ID。

复制 ID 基本上标记了给定的*历史*的数据集。每次实例作为主实例从头开始重新启动, 或者复制副本作为主实例升级为主实例, 将为此实例生成一个新的复制 ID。连接到 的副本主节点将在握手后继承其复制 ID。所以两个实例具有相同ID的关联之处在于它们保存相同的数据, 但是可能在不同的时间。它是作为逻辑时间的偏移量以了解, 对于给定的历史记录 (复制 ID) , 谁拥有最新的数据集。

例如, 如果两个实例 A 和 B 具有相同的复制 ID, 但有一个偏移量为 1000, 一个偏移量为 1023, 这意味着第一个缺少确定性应用于数据集的命令。这也意味着A, 通过只应用几个命令, 可能会达到与 B 完全相同的状态。

Redis 实例之所以有两个复制 ID, 是因为复制副本晋升为大师。故障转移后, 提升的副本需要仍然记住它过去的复制ID是什么, 因为这样的复制ID是前主人之一。这样, 当其他副本将同步时对于新的主站, 他们将尝试使用旧的主复制 ID。这将按预期工作, 因为当复制副本被提升为主, 它将它的辅助ID设置为它的主ID, 记住什么是发生此 ID 切换时的偏移量。稍后它将选择一个新的随机复制 ID, 因为新的历史记录开始了。处理新副本时连接时, 主站将使其ID和偏移量与电流相匹配ID 和辅助 ID (为了安全起见, 最多为给定的偏移量) 。简而言之, 这意味着故障转移后, 连接到新提升的主服务器的副本没有以执行完全同步。

如果您想知道为什么提升为主副本需要更改其故障转移后的复制 ID：旧的主服务器可能仍为由于某些网络分区而作为主节点工作：保留相同的复制 ID 将违反以下事实：相同的 ID 和相同的偏移量两个随机实例意味着它们具有相同的数据集。

## 无盘复制

通常, 完全重新同步需要在磁盘上创建 RDB 文件, 然后从磁盘重新加载相同的 RDB, 以便为副本提供数据。

对于慢速磁盘, 这对主磁盘来说可能是一个非常紧张的操作。Redis 版本 2.8.18 是第一个支持无盘的版本复制。在此设置中, 子进程直接发送通过连接到副本的 RDB, 而不将磁盘用作中间存储。

## 配置

要配置基本的 Redis 复制非常简单：只需将以下行添加到副本配置文件中：

    replicaof 192.168.1.1 6379

当然, 您需要将192.168.1.1 6379替换为您的主IP地址 (或主机名) 和端口。或者, 您可以调用`REPLICAOF`命令和主主机将开始与副本同步。

还有一些参数用于调整复制积压工作在内存中由主站执行部分重新同步。查看示例`redis.conf`随 Redis 发行版一起提供, 了解更多信息。

可以使用`repl-diskless-sync`配置参数。开始传输以等待更多副本的延迟到达后的第一个被控制`repl-diskless-sync-delay`参数。请参考示例`redis.conf`文件了解更多详情。

## 只读副本

从 Redis 2.6 开始, 副本支持默认启用的只读模式。
此行为由`replica-read-only`选项, 并且可以在运行时使用`CONFIG SET`.

只读副本将拒绝所有写入命令, 因此无法由于错误而写入副本。这并不意味着该功能旨在将副本实例公开给 Internet, 或者更一般地向存在不受信任的客户端的网络公开副本实例, 因为管理命令如`DEBUG`或`CONFIG`仍处于启用状态。这[安全](/topics/security)页面介绍如何保护 Redis 实例。

您可能想知道为什么可以恢复只读设置并拥有可以被写入操作作为目标的副本实例。
答案是可写副本仅出于历史原因而存在.
使用可写副本可能会导致主副本和复制副本之间不一致, 因此不建议使用可写副本。
要了解在哪些情况下这可能是一个问题, 我们需要了解复制的工作原理。
通过将常规 Redis 命令传播到副本来复制主服务器上的更改。
当主服务器上的 key 过期时, 它将作为 DEL 命令传播。
如果主节点上存在但被删除、过期或副本上与主节点具有不同类型的 key , 则对从主服务器传播的 DEL、INCR 或 RPOP 等命令的反应将与预期不同。
传播的命令可能会在复制副本上失败或导致不同的结果。
为了最大限度地降低风险 (如果您坚持使用可写副本) , 我们建议您遵循以下建议：

*   不要写入可写副本中也在主服务器上使用的 key 。
     (如果您无法控制写入主服务器的所有客户端, 则很难保证这一点。

*   在升级正在运行的系统中的一组实例时, 不要将实例配置为可写副本作为中间步骤。
    通常, 如果要保证数据一致性, 如果实例可以提升为主实例, 则不要将其配置为可写副本。

从历史上看, 有一些用例被认为是可写副本的合法用例。
从 7.0 版本开始, 这些用例现在都已经过时了, 可以通过其他方式实现相同的操作。
例如：

*   计算缓慢的 Set 或 Sorted set 操作, 并使用以下命令将结果存储在临时本地键中[三联店](/commands/sunionstore)和[津特商店](/commands/zinterstore).
    相反, 请使用返回结果而不存储结果的命令, 例如[苏尼翁](/commands/sunion)和[辛特](/commands/zinter).

*   使用[排序](/commands/sort)命令 (由于可选的 STORE 选项, 它不被视为只读命令, 因此不能在只读副本上使用) 。
    相反, 请使用[SORT_RO](/commands/sort_ro), 这是一个只读命令。

*   用[评估](/commands/eval)和[埃瓦尔沙](/commands/evalsha)也不被视为只读命令, 因为 Lua 脚本可能会调用写入命令。
    相反, 请使用[EVAL_RO](/commands/eval_ro)和[EVALSHA_RO](/commands/evalsha_ro)其中 Lua 脚本只能调用只读命令。

虽然如果复制副本和主服务器重新同步或重新启动复制副本, 则将放弃对复制副本的写入操作, 但不能保证它们将自动同步。

在 4.0 版之前, 可写副本无法使key 在生存时间设置后过期。
这意味着, 如果您使用`EXPIRE`或者为key 设置最大 TTL 的其他命令, key 将泄漏, 虽然您在使用读取命令访问key 时可能不再看到它, 但您将在key 计数中看到它, 并且它仍然会使用内存。
Redis 4.0 RC3 及更高版本能够像主服务器一样使用 TTL 逐出key , 但以大于 63 的数据库编号写入的key 除外 (但默认情况下, Redis 实例只有 16 个数据库) 。
请注意, 即使在大于 4.0 的版本中, 使用`EXPIRE`在主服务器上可能存在的key 上可能会导致副本和主服务器之间不一致。

另请注意, 由于 Redis 4.0 副本写入仅是本地的, 不会传播到附加到实例的子副本。相反, 子副本将始终接收与顶级主服务器发送到中间副本的复制流相同的复制流。例如, 在以下设置中：

    A ---> B ---> C

便`B`是可写的, C 将看不到`B`写入, 并将具有与主实例相同的数据集`A`.

## 设置副本以向主服务器进行身份验证

如果您的主节点有密码, 则通过以下方式`requirepass`, 配置副本以在所有同步操作中使用该密码。

要在正在运行的实例上执行此操作, 请使用`redis-cli`和类型：

    config set masterauth <password>

要永久设置它, 请将其添加到您的配置文件中：

    masterauth <password>

## 仅允许对 N 个附加的复制副本进行写入

从 Redis 2.8 开始, 您可以将 Redis 主服务器配置为仅当当前至少有 N 个副本连接到主人。

但是, 由于 Redis 使用异步复制, 因此无法确保副本实际接收到给定的写入, 因此始终有一个数据窗口损失。

以下是该功能的工作原理：

*   Redis 副本每秒 ping 一次主节点, 确认处理的复制流的数量。
*   Redis 主节点将记住它上次从每个副本收到 ping 的时间。
*   用户可以配置延迟不大于最大秒数的最小副本数。

如果至少有 N 个副本, 延迟小于 M 秒, 则将接受写入。

您可能会将其视为一种尽力而为的数据安全机制, 其中无法确保给定写入的一致性, 但至少数据丢失的时间窗口限制为给定的秒数。一般来说, 绑定数据丢失比未绑定数据丢失更好。

如果不满足条件, 主服务器将改为回复错误, 并且不会接受写入。

此功能有两个配置参数：

*   最小副本写入`<number of replicas>`
*   最小副本最大延迟`<number of seconds>`

有关更多信息, 请查看示例`redis.conf`随 文件附带
Redis 源代码分发。

## Redis 复制如何处理 key 过期问题

Redis 过期允许 key 具有有限的生存时间  (TTL) 。这样的功能取决于实例计算时间的能力, 但 Redis 副本正确复制具有过期的key , 即使使用 Lua 更改此类 key 脚本。

要实现这样的功能, Redis 不能依靠主和复制副本具有同步时钟, 因为这是一个无法解决的问题并且会导致竞争条件和数据集发散, 因此 Redis 使用三种主要技术来复制过期的 key 能够工作：

1.  副本不会使 key 过期, 而是等待主节点使key 过期。当主key 过期 (或由于 LRU 而将其逐出) 时, 它会合成`DEL`命令, 该命令将传输到所有副本。
2.  但是, 由于主节点驱动的过期, 有时副本可能仍然具有逻辑上已过期的key , 因为主副本无法提供`DEL`及时命令。为了解决这个问题, 副本使用其逻辑时钟来报告key 不存在**仅用于读取操作**不违反数据集的一致性 (因为来自主服务器的新命令将到达) 。通过这种方式, 副本可以避免报告仍然存在的逻辑过期key 。实际上, 使用副本进行缩放的 HTML 片段缓存将避免返回已早于所需生存时间的项目。
3.  在 Lua 脚本执行期间, 不执行任何关键过期。当 Lua 脚本运行时, 从概念上讲, 主脚本中的时间将被冻结, 因此给定的键在脚本运行的所有时间内要么存在, 要么不存在。这可以防止key 在脚本中途过期, 并且需要以保证在数据集中具有相同效果的方式将相同的脚本发送到副本。

一旦复制副本被提升为主服务器, 它将开始独立地使key 过期, 并且不需要其旧主节点的任何帮助。

## 在 Docker 和 NAT 中配置复制

当使用 Docker 或其他类型的使用端口转发或网络地址转换的容器时, Redis 复制需要一些额外的注意, 尤其是在使用 Redis Sentinel 或其他主站系统时`INFO`或`ROLE`扫描命令输出以发现副本的地址。

问题是`ROLE`命令, 以及这`INFO`输出在发布到主实例时, 将显示副本因为他们具有用于连接到主服务器的IP地址, 该IP地址在与 的逻辑地址相比, 使用 NAT 的环境可能会有所不同副本实例 (客户端应用于连接到副本的实例) 。

同样, 副本将列出并配置了侦听端口到`redis.conf`, 则可能与转发的端口不同, 以防万一端口将重新映射。

要解决这两个问题, 从 Redis 3.2.2 开始, 可以强制一个副本, 用于向主服务器宣布任意一对 IP 和端口。
要使用的两个配置指令是：

    replica-announce-ip 5.5.5.5
    replica-announce-port 1234

并记录在示例中`redis.conf`最近的 Redis 发行版。

## "信息" 和 "角色" 命令

有两个 Redis 命令, 它们提供了有关当前的大量信息主实例和副本实例的复制参数。一个是`INFO`.如果命令使用`replication`参数作为`INFO replication`只将显示与复制相关的信息。另一个更多计算机友好型命令是`ROLE`, 提供主服务器和副本及其复制偏移量, 已连接列表复制副本等。

## 重新启动和故障转移后的部分同步

从 Redis 4.0 开始, 当实例在故障转移后提升为主实例时, 它仍然能够与副本执行部分重新同步老主人。为此, 复制副本会记住旧的复制 ID 和其前主站的偏移量, 因此可以提供部分积压到连接副本, 即使它们要求提供旧的复制 ID。

但是, 已升级复制副本的新复制 ID 将有所不同, 因为它构成了数据集的不同历史记录。例如, 主节点可以返回可用, 并且可以继续接受写入一段时间, 因此使用提升的复制副本中的相同复制 ID 将违反以下规则：复制 ID 和偏移量对仅标识单个数据集。

此外, 副本 - 当轻轻关闭电源并重新启动时 - 能够存储在`RDB`归档与其重新同步所需的信息主人。这在升级的情况下很有用。当需要时, 最好使用`SHUTDOWN`命令以执行`save & quit`在复制品。

无法部分同步通过
AOF 文件。但是, 在关闭之前, 实例可能会转换为 RDB 持久性
向下, 然后可以重新启动, 最后可以再次启用AOF。

## `Maxmemory` 在副本上

默认情况下, 副本将忽略`maxmemory` (除非在故障转移后或手动将其提升为主节点) 。
这意味着key 的逐出将由主站处理, 将DEL命令发送到副本, 因为主站端的键被逐出。

此行为可确保主服务器和副本保持一致, 这通常是您想要的。
但是, 如果副本是可写的, 或者您希望副本具有不同的内存设置, 并且您确定对副本执行的所有写入都是幂等的, 则可以更改此默认值 (但请务必了解您正在执行的操作) 。

请注意, 由于副本默认不逐出, 因此它最终可能使用比通过设置的内存更多的内存`maxmemory` (因为副本上的某些缓冲区可能更大, 或者数据结构有时可能会占用更多内存等等) 。
确保监视副本, 并确保它们具有足够的内存, 以便在主服务器达到配置的之前永远不会遇到真正的内存不足情况`maxmemory`设置。

若要更改此行为, 可以允许副本不忽略`maxmemory`.要使用的配置指令是：

    replica-ignore-maxmemory no
