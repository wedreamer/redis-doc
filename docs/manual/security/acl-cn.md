***

## 标题： “前交叉韧带”&#xA;链接标题： “ACL”&#xA;体重： 1&#xA;描述： Redis 访问控制列表&#xA;别名：&#xA;\- /主题/acl

Redis ACL是访问控制列表的缩写，是允许某些功能的功能
连接在可以执行的命令和
可以访问的键。它的工作方式是，连接后，客户端
需要提供用户名和密码才能进行身份验证。如果身份验证成功，则连接与给定的
用户和用户具有的限制。可以对 Redis 进行配置，以便
连接已使用“默认”用户进行身份验证（这是
默认配置）。作为副作用，配置默认用户具有
能够仅为连接提供特定的功能子集
未显式进行身份验证。

在默认配置中，Redis 6（第一个具有 ACL 的版本）可以正常工作
就像旧版本的Redis一样。每个新连接都是
能够调用每个可能的命令并访问每个键，因此
ACL 功能向后兼容旧客户端和应用程序。也
配置密码的旧方法，使用**requirepass**配置
指令，仍按预期工作。但是，现在
为默认用户设置密码。

雷迪斯酒店`AUTH`命令在 Redis 6 中得到了扩展，因此现在可以
以双参数形式使用它：

    AUTH <username> <password>

下面是旧窗体的示例：

    AUTH <password>

发生的事情是用于身份验证的用户名是“默认的”，因此
只是指定密码意味着我们要进行身份验证
默认用户。这提供了向后兼容性。

## 当 ACL 有用时

在使用 ACL 之前，您可能需要问问自己想要的目标是什么
通过实施此保护层来实现。通常有
ACL可以很好地实现的两个主要目标：

1.  您希望通过限制对命令和密钥的访问来提高安全性，以便不受信任的客户端没有访问权限，而受信任的客户端仅具有对数据库的最低访问级别，以便执行所需的工作。例如，某些客户端可能只能执行只读命令。
2.  您希望提高操作安全性，以便不允许访问 Redis 的进程或人员因软件错误或手动错误而损坏数据或配置。例如，从 Redis 获取延迟作业的辅助角色没有理由能够调用`FLUSHALL`命令。

ACL 的另一个典型用法与托管 Redis 实例有关。Redis is
通常由公司内部团队作为托管服务提供，这些团队负责
Redis 基础架构，用于他们拥有的其他内部客户，或者是
由云提供商在软件即服务设置中提供。在两者中
设置，我们希望确保排除配置命令
客户。

## 使用 ACL 命令配置 ACL

ACL是使用DSL（域特定语言）定义的，它描述了什么
允许给定用户执行此操作。此类规则始终从
从前到尾，从左到右，因为有时规则的顺序是
重要的是要了解用户真正能够做什么。

默认情况下，定义了单个用户，称为*违约*.我们
可以使用`ACL LIST`命令以检查当前活动的 ACL
并验证新启动的、默认配置的配置
Redis 实例为：

    > ACL LIST
    1) "user default on nopass ~* &* +@all"

上面的命令以相同的格式报告用户列表，格式与
在 Redis 配置文件中使用，通过转换当前 ACL 集
让用户回到他们的描述。

每行的前两个单词是“user”，后跟用户名。这
接下来的单词是描述不同事物的ACL规则。我们将详细展示规则的工作原理，但现在只需说默认规则就足够了。
用户配置为活动（打开）、不需要密码（无通行）、到
访问每个可能的密钥 （`~*`） 和酒吧/订阅频道 （`&*`），并且能够
调用每个可能的命令 （`+@all`).

此外，在默认用户的特殊情况下，具有*诺通*规则意味着
新连接将自动使用默认用户进行身份验证
没有任何明确的`AUTH`需要呼叫。

## 前交叉韧带规则

以下是有效 ACL 规则的列表。某些规则只是
用于激活或删除标志的单个单词，或
对用户 ACL 执行给定的更改。其他规则是字符前缀，这些前缀
与命令或类别名称、键模式和
等等。

启用和禁止用户：

*   `on`：启用用户：可以以此用户身份进行身份验证。
*   `off`：禁止用户：无法再对此用户进行身份验证;但是，以前经过身份验证的连接仍将有效。请注意，如果默认用户被标记为*关闭*，新连接将以未通过身份验证的方式启动，并要求用户发送`AUTH`或`HELLO`使用AUTH选项，以便以某种方式进行身份验证，而不管默认用户配置如何。

允许和禁止命令：

*   `+<command>`：将命令添加到用户可以调用的命令列表中。可与`|`用于允许子命令（例如“+config|get”）。
*   `-<command>`：将命令删除到用户可以调用的命令列表中。从 Redis 7.0 开始，它可以与`|`用于阻塞子命令（例如“-config|set”）。
*   `+@<category>`：添加此类类别中的所有命令以供用户调用，有效类别如@admin，@set，@sortedset，...依此类推，通过调用`ACL CAT`命令。特殊类别@all是指所有命令，包括服务器中当前存在的命令，以及将来将通过模块加载的命令。
*   `-@<category>`： 赞`+@<category>`但从客户端可以调用的命令列表中删除命令。
*   `+<command>|first-arg`：允许以其他方式禁用的命令的特定第一个参数。它仅在没有子命令的命令上受支持，并且不允许作为负形式（如 -SELECT|1），仅以“+”开头的加法。此功能已弃用，将来可能会被删除。
*   `allcommands`：+@all的别名。请注意，这意味着能够执行通过模块系统加载的所有未来命令。
*   `nocommands`：-@all的别名。

允许和禁止某些密钥和密钥权限：

*   `~<pattern>`：添加可作为命令的一部分提及的键模式。例如`~*`允许所有键。该模式是球形样式的模式，如`KEYS`.可以指定多个模式。
*   `%R~<pattern>`：（在 Redis 7.0 及更高版本中可用）添加指定的读取键模式。这类似于常规密钥模式，但仅授予读取与给定模式匹配的密钥的权限。看[密钥权限](#key-permissions)了解更多信息。
*   `%W~<pattern>`：（在 Redis 7.0 及更高版本中可用）添加指定的写入密钥模式。这类似于常规密钥模式，但仅授予写入与给定模式匹配的密钥的权限。看[密钥权限](#key-permissions)了解更多信息。
*   `%RW~<pattern>`：（在 Redis 7.0 及更高版本中可用）别名`~<pattern>`.
*   `allkeys`：别名`~*`.
*   `resetkeys`：刷新允许的键模式列表。例如，ACL`~foo:* ~bar:* resetkeys ~objects:*`，将仅允许客户端访问与模式匹配的密钥`objects:*`.

允许和禁止发布/订阅频道：

*   `&<pattern>`：（在 Redis 6.2 及更高版本中可用）添加用户可访问的 Pub/Sub 频道的 glob 样式模式。可以指定多个通道模式。请注意，模式匹配仅对`PUBLISH`和`SUBSCRIBE`而`PSUBSCRIBE`需要其通道模式与允许用户的通道模式之间的文字匹配。
*   `allchannels`：别名`&*`允许用户访问所有发布/订阅频道。
*   `resetchannels`：刷新允许的通道模式列表，如果用户的 Pub/Sub 客户端不再能够访问其各自的通道和/或通道模式，请断开这些客户端的连接。

为用户配置有效密码：

*   `><password>`：将此密码添加到用户的有效密码列表中。例如`>mypass`将“mypass”添加到有效密码列表中。 此指令清除了*诺通*标志（见后文）。每个用户都可以拥有任意数量的密码。
*   `<<password>`：从有效密码列表中删除此密码。在您尝试删除的密码实际上未设置的情况下发出错误。
*   `#<hash>`：将此 SHA-256 哈希值添加到用户的有效密码列表中。此哈希值将与为 ACL 用户输入的密码的哈希值进行比较。这允许用户将哈希存储在`acl.conf`文件，而不是存储明文密码。仅接受 SHA-256 哈希值，因为密码哈希必须为 64 个字符，并且仅包含小写十六进制字符。
*   `!<hash>`：从有效密码列表中删除此哈希值。当您不知道哈希值指定的密码但想要从用户中删除密码时，这很有用。
*   `nopass`：用户的所有设置密码都将被删除，并且用户被标记为不需要密码：这意味着每个密码都将对此用户起作用。如果此指令用于默认用户，则每个新连接将立即使用默认用户进行身份验证，而无需任何显式 AUTH 命令。请注意，*重置通行证*指令将清除此条件。
*   `resetpass`：刷新允许的密码列表并删除*诺通*地位。后*重置通行证*，则用户没有关联的密码，并且无法在不添加某些密码（或将其设置为）的情况下进行身份验证*诺通*稍后）。

*注意：如果用户未被标记为 nopass 并且没有有效密码列表，则该用户实际上无法使用，因为无法以该用户身份登录。*

为用户配置选择器：

*   `(<rule list>)`：（在 Redis 7.0 及更高版本中可用）创建新的选择器来匹配规则。选择器在用户权限之后进行评估，并根据定义的顺序进行评估。如果命令与用户权限或任何选择器匹配，则允许该命令。看[选择](#selectors)了解更多信息。
*   `clearselectors`：（在 Redis 7.0 及更高版本中可用）删除附加到用户的所有选择器。

重置用户：

*   `reset`执行以下操作：重置通道、重置密钥、重置通道、关闭、-@all。用户将返回到创建后立即恢复的相同状态。

## 使用 ACL SETUSER 命令创建和编辑用户 ACL

可以通过两种主要方式创建和修改用户：

1.  使用 ACL 命令及其`ACL SETUSER`子命令。
2.  修改可以定义用户的服务器配置，然后重新启动服务器。使用*外部 ACL 文件*，只需调用`ACL LOAD`.

在本节中，我们将学习如何使用`ACL`命令。
有了这样的知识，通过
配置文件。在配置中定义用户值得拥有自己的
部分，稍后将单独讨论。

首先，尝试最简单的`ACL SETUSER`命令调用：

    > ACL SETUSER alice
    OK

这`ACL SETUSER`命令获取要应用的用户名和 ACL 规则列表
给用户。但是，上面的示例根本没有指定任何规则。
如果用户不存在，这将只创建用户，使用默认值
用户。如果用户已存在，则上述命令将不执行任何操作。

检查默认用户状态：

    > ACL LIST
    1) "user alice off &* -@all"
    2) "user default on nopass ~* ~& +@all"

新用户“alice”是：

*   在关闭状态下，因此`AUTH`将不适用于用户“爱丽丝”。
*   用户也没有设置密码。
*   无法访问任何命令。请注意，默认情况下创建用户时无法访问任何命令，因此`-@all`在上面的输出中可以省略;然而`ACL LIST`试图是显式的而不是隐式的。
*   没有用户可以访问的关键模式。
*   用户可以访问所有发布/订阅频道。

默认情况下，新用户是使用限制性权限创建的。从 Redis 6.2 开始，ACL 还提供发布/订阅通道访问管理。为了在升级到 Redis 6.2 时确保与 6.0 版的向后兼容性，默认情况下，新用户将被授予“所有通道”权限。默认值可设置为`resetchannels`通过`acl-pubsub-default`配置指令。

从 7.0 开始，`acl-pubsub-default`值设置为`resetchannels`以默认限制通道访问，以提供更好的安全性。
默认值可设置为`allchannels`通过`acl-pubsub-default`配置指令，以便与以前的版本兼容。

这样的用户是完全无用的。让我们尝试定义用户，以便
它是活动的，有一个密码，并且只能访问`GET`命令
到以字符串“cached：”开头的键名。

    > ACL SETUSER alice on >p1pp0 ~cached:* +get
    OK

现在用户可以做一些事情，但会拒绝做其他事情：

    > AUTH alice p1pp0
    OK
    > GET foo
    (error) NOPERM this user has no permissions to access one of the keys used as arguments
    > GET cached:1234
    (nil)
    > SET cached:1234 zap
    (error) NOPERM this user has no permissions to run the 'set' command

事情正在按预期进行。为了检查配置的
用户 alice（请记住，用户名区分大小写），可以
使用替代项`ACL LIST`它被设计为更适合
计算机读取，同时`ACL GETUSER`更具人类可读性。

    > ACL GETUSER alice
    1) "flags"
    2) 1) "on"
       2) "allchannels"
    3) "passwords"
    4) 1) "2d9c75..."
    5) "commands"
    6) "-@all +get"
    7) "keys"
    8) "~cached:*"
    9) "channels"
    10) "&*"
    11) "selectors"
    12) 1) 1) "commands"
           2) "-@all +set"
           3) "keys"
           4) "~*"
           5) "channels"
           6) "&*"

这`ACL GETUSER`返回一个字段值数组，该数组以更易于解析的术语描述用户。输出包括标志集、密钥模式列表、密码等。如果我们使用 RESP3，则输出可能更具可读性，以便将其作为映射回复返回：

    > ACL GETUSER alice
    1# "flags" => 1~ "on"
       2~ "allchannels"
    2# "passwords" => 1) "2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927"
    3# "commands" => "-@all +get"
    4# "keys" => "~cached:*"
    5# "channels" => "&*"
    6# "selectors" => 1) 1# "commands" => "-@all +set"
        2# "keys" => "~*"
        3# "channels" => "&*"

*注意：从现在开始，我们将继续使用 Redis 默认协议版本 2*

使用另一个`ACL SETUSER`命令（来自其他用户，因为 alice 无法运行`ACL`命令），我们可以向用户添加多个模式：

    > ACL SETUSER alice ~objects:* ~items:* ~public:*
    OK
    > ACL LIST
    1) "user alice on >2d9c75... ~cached:* ~objects:* ~items:* ~public:* &* -@all +get"
    2) "user default on nopass ~* &* +@all"

内存中的用户表示形式现在符合我们的预期。

## 对 ACL SETUSER 的多次调用

了解当`ACL SETUSER`称为
多次。关键是要知道，每个`ACL SETUSER`呼叫将
不会重置用户，而只会将 ACL 规则应用于现有用户。
仅当用户以前不知道时，才会重置该用户。在这种情况下，一个全新的
用户是使用归零 ACL 创建的。用户不能做任何事情，
不允许，没有密码，等等。这是安全的最佳默认值。

但是，以后的调用只会以增量方式修改用户。例如
以下序列：

    > ACL SETUSER myuser +set
    OK
    > ACL SETUSER myuser +get
    OK

将导致用户能够同时调用`GET`和`SET`:

    > ACL LIST
    1) "user default on nopass ~* &* +@all"
    2) "user myuser off &* -@all +set +get"

## 命令类别

通过一个接一个地指定所有命令来设置用户 ACL 是
真的很烦人，所以我们做这样的事情：

    > ACL SETUSER antirez on +@all -@dangerous >42a979... ~*

通过说+@all和-@dangerous，我们包含了所有命令，后来删除了
Redis 命令表中标记为危险的所有命令。
请注意，命令类别**从不包含模块命令**跟
\+@all除外。如果说+@all，则所有命令都可以通过以下方式执行
用户，甚至将来通过模块系统加载的命令。但是，如果您
使用ACL规则+@read或任何其他，模块命令始终
排除。这非常重要，因为您应该只信任 Redis
内部命令表。模块可能会暴露危险的东西和
ACL只是相加的，即`+@all -...`
你应该绝对确定你永远不会包括你不是指什么
自。

以下是命令类别及其含义的列表：

*   **管理**- 管理命令。普通应用程序将永远不需要使用
    这些。包括`REPLICAOF`,`CONFIG`,`DEBUG`,`SAVE`,`MONITOR`,`ACL`,`SHUTDOWN`等。
*   **位图**- 数据类型：位图相关。
*   **阻塞**- 可能阻止连接，直到被另一个释放
    命令。
*   **连接**- 影响连接或其他连接的命令。
    这包括`AUTH`,`SELECT`,`COMMAND`,`CLIENT`,`ECHO`,`PING`等。
*   **危险**- 潜在危险的命令（每个命令都应谨慎考虑
    各种原因）。这包括`FLUSHALL`,`MIGRATE`,`RESTORE`,`SORT`,`KEYS`,
    `CLIENT`,`DEBUG`,`INFO`,`CONFIG`,`SAVE`,`REPLICAOF`等。
*   **地理**- 数据类型：地理空间索引相关。
*   **散 列**- 数据类型：哈希相关。
*   **超日志**- 数据类型：与超日志相关。
*   **快**- 快速 O（1） 命令。可以循环参数的数量，但不是
    键中的元素数。
*   **键空间**- 写入或读取密钥、数据库或其元数据
    以与类型无关的方式。包括`DEL`,`RESTORE`,`DUMP`,`RENAME`,`EXISTS`,`DBSIZE`,
    `KEYS`,`EXPIRE`,`TTL`,`FLUSHALL`等。可能修改键空间的命令，
    键或元数据也将具有`write`类别。仅读取的命令
    键空间、键或元数据将具有`read`类别。
*   **列表**- 数据类型：相关列表。
*   **酒吧酒吧**- 与 PubSub 相关的命令。
*   **读**- 从键（值或元数据）读取。请注意，不带的命令
    与密钥交互，不会有`read`或`write`.
*   **脚本**- 脚本相关。
*   **设置**- 数据类型：集合相关。
*   **排序集**- 数据类型：排序集相关。
*   **慢**- 所有不是的命令`fast`.
*   **流**- 数据类型：流相关。
*   **字符串**- 数据类型：字符串相关。
*   **交易**-`WATCH`/`MULTI`/`EXEC`相关命令。
*   **写**- 写入键（值或元数据）。

Redis还可以使用Redis向您显示所有类别的列表以及每个类别包含的确切命令`ACL`命令的`CAT`子命令。它可以以两种形式使用：

    ACL CAT -- Will just list all the categories available
    ACL CAT <category-name> -- Will list all the commands inside the category

例子：

     > ACL CAT
     1) "keyspace"
     2) "read"
     3) "write"
     4) "set"
     5) "sortedset"
     6) "list"
     7) "hash"
     8) "string"
     9) "bitmap"
    10) "hyperloglog"
    11) "geo"
    12) "stream"
    13) "pubsub"
    14) "admin"
    15) "fast"
    16) "slow"
    17) "blocking"
    18) "dangerous"
    19) "connection"
    20) "transaction"
    21) "scripting"

如您所见，到目前为止有21个不同的类别。现在让我们检查一下什么
命令是*地理*类别：

    > ACL CAT geo
    1) "geohash"
    2) "georadius_ro"
    3) "georadiusbymember"
    4) "geopos"
    5) "geoadd"
    6) "georadiusbymember_ro"
    7) "geodist"
    8) "georadius"

请注意，命令可能是多个类别的一部分。例如，一个
ACL 规则，如`+@geo -@read`将导致某些 geo 命令成为
排除，因为它们是只读命令。

## 允许/阻止子命令

从 Redis 7.0 开始，可以像其他子命令一样允许/阻止子命令
命令（通过使用分隔符`|`在命令和子命令之间，用于
例：`+config|get`或`-config|set`)

对于除 DEBUG 之外的所有命令都是如此。为了允许/阻止特定
调试子命令，请参阅下一节。

## 允许被阻止命令的第一个参数

**注意：自 Redis 7.0 起，此功能已弃用，将来可能会被删除。**

有时，排除或包含命令或子命令作为一个整体的能力是不够的。
许多部署可能不满意提供执行`SELECT`对于任何数据库，但可能
还是希望能够运行`SELECT 0`.

在这种情况下，我们可以通过以下方式更改用户的 ACL：

    ACL SETUSER myuser -select +select|0

首先，删除`SELECT`命令，然后添加允许的
第一个参数。请注意，**不可能反其道而行之**自 first-args 以来
只能添加，不能排除。指定所有第一个参数更安全
对某些用户有效，因为有可能
将来可能会添加新的 first-args。

另一个例子：

    ACL SETUSER myuser -debug +debug|digest

请注意，first-arg 匹配可能会增加一些性能损失;但是，即使使用合成基准，也很难衡量。这
只有在调用此类命令时才支付额外的 CPU 成本，而不是在调用此类命令时支付
调用其他命令。

可以使用此机制来允许 Redis 中的子命令
7.0 之前的版本（请参阅上一节）。

## +@all VS -@all

在上一节中，观察了如何定义命令
基于添加/删除单个命令的 ACL。

## 选择

从 Redis 7.0 开始，Redis 支持添加多组规则，这些规则是相互独立评估的。
这些辅助权限集称为选择器，并通过在括号内包装一组规则来添加。
为了执行命令，root 权限（在括号外定义的规则）或任何选择器（在括号内定义的规则）必须与给定的命令匹配。
在内部，首先检查根权限，然后按添加顺序检查选择器。

例如，考虑具有 ACL 规则的用户`+GET ~key1 (+SET ~key2)`.
此用户能够执行`GET key1`和`SET key2 hello`，但不是`GET key2`或`SET key1 world`.

与用户的 root 权限不同，选择器在添加后无法修改。
相反，可以选择器可以通过`clearselectors`关键字，用于删除所有添加的选择器。
请注意，`clearselectors`不会删除根权限。

## 密钥权限

从 Redis 7.0 开始，键模式还可用于定义命令如何触摸键。
这是通过定义密钥权限的规则实现的。
关键权限规则采用以下形式`%(<permission>)~<pattern>`.
权限定义为映射到以下关键权限的单个字符：

*   W（写入）：密钥中存储的数据可能会被更新或删除。
*   R（读取）：处理、复制或返回用户从密钥提供的数据。请注意，这不包括元数据，例如大小信息（示例`STRLEN`）、类型信息（示例`TYPE`）或有关集合中是否存在值的信息（示例`SISMEMBER`).

可以通过指定多个字符来组合权限。
将权限指定为“RW”被视为完全访问权限，类似于仅传入`~<pattern>`.

有关具体示例，请考虑具有 ACL 规则的用户`+@all ~app1:* (+@readonly ~app2:*)`.
此用户对`app1:*`和只读访问`app2:*`.
但是，某些命令支持从一个键读取数据，执行一些转换，然后将其存储到另一个键中。
一个这样的命令是`COPY`命令，将数据从源密钥复制到目标密钥。
示例 ACL 规则集无法处理从`app2:user`到`app1:user`，因为 root 权限或选择器都不完全匹配该命令。
但是，使用键选择器，您可以定义一组可以处理此请求的 ACL 规则`+@all ~app1:* %R~app2:*`.
第一种模式能够匹配`app1:user`并且第二种模式能够匹配`app2:user`.

命令需要哪种类型的权限通过以下方式记录[主要规格](/topics/key-specs#logical-operation-flags).
权限类型基于键逻辑操作标志。
插入、更新和删除标志映射到写入密钥权限。
访问标志映射到读取密钥权限。
如果密钥没有逻辑操作标志，例如`EXISTS`，用户仍然需要密钥读取或密钥写入权限来执行命令。

注意：在评估执行命令是否需要读取权限时，将忽略访问用户数据的侧通道。
这意味着某些返回有关已修改密钥的元数据的写入命令只需要对密钥的写入权限即可执行：
例如，请考虑以下两个命令：

*   `LPUSH key1 data`：修改“key1”但只返回有关它的元数据，推送后列表的大小，因此该命令只需要对“key1”的写入权限即可执行。
*   `LPOP key2`：修改“key2”，但也从列表中最左边的项目返回数据，因此该命令需要对“key2”的读取和写入权限才能执行。

如果应用程序需要确保没有从密钥（包括侧通道）访问数据，则建议不要提供对密钥的任何访问。

## 密码如何在内部存储

Redis 在内部存储使用 SHA256 进行哈希处理的密码。如果您设置了密码
并检查输出`ACL LIST`或`ACL GETUSER`，您将看到一个长十六进制
看起来伪随机的字符串。下面是一个示例，因为在上一个
例如，为了简洁起见，修剪了长十六进制字符串：

    > ACL GETUSER default
    1) "flags"
    2) 1) "on"
       2) "allkeys"
       3) "allcommands"
       4) "allchannels"
    3) "passwords"
    4) 1) "2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927"
    5) "commands"
    6) "+@all"
    7) "keys"
    8) "~*"
    9) "channels"
    10) "&*"
    11) "selectors"
    12) (empty array)

此外，从 Redis 6 开始，旧命令`CONFIG GET requirepass`将
不再返回明文密码，而是返回散列密码。

使用 SHA256 可以避免以明文形式存储密码
同时仍然允许非常快`AUTH`命令，这是一个非常重要的
Redis的功能，并且与客户对Redis的期望是一致的。

然而，前交叉韧带*密码*不是真正的密码。它们是共享的秘密
在服务器和客户端之间，因为密码是
不是人类使用的身份验证令牌。例如：

*   没有长度限制，密码只会在某些客户端软件中记住。在这种情况下，没有人需要召回密码。
*   ACL 密码不保护任何其他内容。例如，它永远不会是某些电子邮件帐户的密码。
*   通常，当您能够访问散列密码本身时，通过完全访问给定服务器的Redis命令或损坏系统本身，您已经可以访问密码所保护的内容：Redis实例稳定性及其包含的数据。

因此，减慢密码身份验证速度，以便使用
算法，利用时间和空间使密码破解变得困难，
是一个非常糟糕的选择。相反，我们的建议是产生强大的
密码，以便没有人能够使用
字典或暴力攻击，即使他们有哈希。为此，有一个特殊的ACL
命令`ACL GENPASS`使用系统加密伪随机生成密码
发电机：

    > ACL GENPASS
    "dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc"

该命令输出一个 32 字节（256 位）伪随机字符串，该字符串转换为
64 字节字母数字字符串。这足够长以避免攻击和短
足以易于管理，剪切和粘贴，存储等。这是什么
您应该使用以生成 Redis 密码。

## 使用外部 ACL 文件

有两种方法可以将用户存储在 Redis 配置中：

1.  用户可直接在`redis.conf`文件。
2.  可以指定外部 ACL 文件。

这两种方法是*相互不兼容*，所以 Redis 会要求你使用一个
或另一个。在内部指定用户`redis.conf`是
适用于简单的用例。当有多个用户要定义时，在
环境复杂，建议您改用 ACL 文件。

内部使用的格式`redis.conf`并且在外部 ACL 文件中正好是
相同，因此从一个切换到另一个是微不足道的，并且
以下各项：

    user <username> ... acl rules ...

例如：

    user worker +@list +@connection ~jobs:* on >ffa9203c493aa99

如果要使用外部 ACL 文件，需要指定
名为`aclfile`喜欢这个：

    aclfile /etc/redis/users.acl

当您只是在`redis.conf`
文件，您可以使用`CONFIG REWRITE`为了存储新的用户配置
通过重写文件在文件中。

但是，外部 ACL 文件功能更强大。您可以执行以下操作：

*   用`ACL LOAD`如果您手动修改了 ACL 文件，并且希望 Redis 重新加载新配置。请注意，此命令能够加载文件*仅当正确指定了所有用户时*.否则，将向用户报告错误，并且旧配置将保持有效。
*   用`ACL SAVE`将当前 ACL 配置保存到 ACL 文件。

请注意，`CONFIG REWRITE`不同时触发`ACL SAVE`.当您使用时
ACL 文件、配置和 ACL 是单独处理的。

## 哨兵和副本的 ACL 规则

如果您不想提供 Redis 副本和 Redis Sentinel 实例
对 Redis 实例的完全访问权限，以下是命令集
必须允许才能使一切正常工作。

对于 Sentinel，允许用户在主实例和副本实例中访问以下命令：

*   身份验证， 客户端， 订阅， 脚本， 发布， PING， 信息， 多， SLAVEOF， 配置， 客户端， 执行。

Sentinel 不需要访问数据库中的任何密钥，但确实使用 Pub/Sub，因此 ACL 规则如下（注意：`AUTH`不需要，因为它总是被允许的）：

    ACL SETUSER sentinel-user on >somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill

Redis 副本需要允许在主实例上执行以下命令：

*   PSYNC， REPLCONF， PING

无需访问任何密钥，因此这转换为以下规则：

    ACL setuser replica-user on >somepassword +psync +replconf +ping

请注意，您无需配置副本即可允许主服务器能够执行任何一组命令。从副本的角度来看，主服务器始终被认证为 root 用户。
