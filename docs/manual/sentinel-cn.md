---
title: "High availability with Redis Sentinel"
linkTitle: "High availability with Sentinel"
weight: 1
description: High availability for non-clustered Redis
aliases:
  - /topics/sentinel
---

Redis Sentinel 在不使用时为 Redis 提供高可用性[Redis Cluster](/docs/manual/scaling).

Redis Sentinel还提供其他附带任务，例如监控，
通知，并充当客户端的配置提供程序。

这是宏观层面的哨兵能力的完整列表（即*全局*):

*   **监测**.Sentinel 会不断检查您的主实例和副本实例是否按预期工作。
*   **通知**.Sentinel 可以通过 API 通知系统管理员或其他计算机程序，其中一个受监视的 Redis 实例出现问题。
*   **自动故障转移**.如果主服务器未按预期工作，Sentinel 可以启动故障转移过程，其中副本将提升为主服务器，其他其他副本将重新配置为使用新主服务器，并且使用 Redis 服务器的应用程序将被告知连接时要使用的新地址。
*   **配置提供程序**.Sentinel 充当客户端服务发现的权威来源：客户端连接到 Sentinels，以便请求负责给定服务的当前 Redis 主节点的地址。如果发生故障转移，Sentinels 将报告新地址。

## 哨兵作为分布式系统

Redis Sentinel是一个分布式系统：

Sentinel 本身被设计为在有多个 Sentinel 进程协同协作的配置中运行。多个哨兵流程合作的优势如下：

1.  当多个哨兵同意给定主站不再可用时，将执行故障检测。这降低了误报的可能性。
2.  即使不是所有的 Sentinel 进程都在工作，Sentinel 也能正常工作，从而使系统能够针对故障进行健壮。毕竟，拥有一个本身就是单点故障的故障转移系统是没有乐趣的。

哨兵、Redis 实例（主实例和副本）和客户端的总和
连接到Sentinel和Redis，也是一个更大的分布式系统
特定属性。本文档将逐步介绍概念
从基本信息开始，了解基本信息
Sentinel 的属性，到更复杂的信息（可选）
以了解哨兵的确切工作原理。

## 哨兵快速启动

### 获取哨兵

Sentinel的当前版本称为**哨兵 2**.它是重写的
使用更强大、更易于预测的初始 Sentinel 实现
算法（本文档中对此进行了说明）。

Redis Sentinel 的稳定版本自 Redis 2.8 起发布。

新的开发在*稳定*分支和新功能
有时一旦它们被移植回最新的稳定分支
被认为是稳定的。

Redis Sentinel 版本 1 随 Redis 2.6 一起提供，已弃用，不应使用。

### 奔跑的哨兵

如果您使用的是`redis-sentinel`可执行文件（或者如果您有符号
将具有该名称的链接链接到`redis-server`可执行文件）您可以运行 Sentinel
使用以下命令行：

    redis-sentinel /path/to/sentinel.conf

否则，您可以直接使用`redis-server`可执行文件在
哨兵模式：

    redis-server /path/to/sentinel.conf --sentinel

两种方式的工作原理相同。

然而**它是强制性的**在运行 Sentinel 时使用配置文件，因为系统将使用此文件来保存将在重新启动时重新加载的当前状态。如果没有给出配置文件或配置文件路径不可写，Sentinel 将简单地拒绝启动。

哨兵默认运行**侦听与 TCP 端口 26379 的连接**所以
让哨兵正常工作，服务器端口 26379**必须打开**接收
来自其他哨兵实例的 IP 地址的连接。
否则哨兵无法交谈，也无法就该做什么达成一致，因此故障转移
永远不会被执行。

### 部署前需要了解的有关 Sentinel 的基本知识

1.  您至少需要三个 Sentinel 实例才能进行可靠的部署。
2.  应将这三个 Sentinel 实例放入被认为以独立方式失败的计算机或虚拟机中。例如，在不同的可用性区域上执行不同的物理服务器或虚拟机。
3.  Sentinel + Redis 分布式系统不保证在故障期间保留已确认的写入，因为 Redis 使用异步复制。但是，有一些部署 Sentinel 的方法，使丢失写入的窗口仅限于某些时刻，而还有其他不太安全的方法来部署它。
4.  您需要客户中的圣天诺支持。流行的客户端库支持 Sentinel，但不是全部。
5.  如果您不时在开发环境中进行测试，则没有安全的HA设置，如果可以，在生产环境中，如果它们可以工作，则甚至更好。您可能有一个配置错误，只有当为时已晚时（凌晨3点，当您的主站停止工作时），才会变得明显。
6.  **应谨慎混合使用 Sentinel、Docker 或其他形式的网络地址转换或端口映射**：Docker 执行端口重新映射，打破 Sentinel 自动发现其他 Sentinel 进程和主节点的副本列表。检查[部分关于*哨兵和 Docker*](#sentinel-docker-nat-and-possible-issues)本文档稍后部分，了解更多信息。

### 配置哨兵

Redis 源分发版包含一个名为`sentinel.conf`
这是一个自我记录的示例配置文件，您可以使用
配置 Sentinel，但是典型的最小配置文件看起来像
以后：

    sentinel monitor mymaster 127.0.0.1 6379 2
    sentinel down-after-milliseconds mymaster 60000
    sentinel failover-timeout mymaster 180000
    sentinel parallel-syncs mymaster 1

    sentinel monitor resque 192.168.1.3 6380 4
    sentinel down-after-milliseconds resque 10000
    sentinel failover-timeout resque 180000
    sentinel parallel-syncs resque 5

您只需要指定要监视的主站，即可将每个主控点分开
主（可能具有任意数量的副本）具有不同的名称。没有
需要指定自动发现的副本。哨兵将更新
使用有关副本的其他信息自动配置（在
以便在重新启动时保留信息）。配置是
在故障转移期间，每次将副本提升为主副本时也重写
每当发现新的哨兵时。

上面的示例配置基本上监视两组 Redis
实例，每个实例由一个主实例和一个未定义数量的副本组成。
一组实例称为`mymaster`，以及`resque`.

论据的含义`sentinel monitor`语句如下：

    sentinel monitor <master-group-name> <ip> <port> <quorum>

为了清楚起见，让我们逐行检查配置
选项表示：

第一行用于告诉 Redis 监视一个名为*迈斯特*,
位于地址 127.0.0.1 和端口 6379 处，仲裁数为 2。万事
很明显，但**法定人数**论点：

*   这**法定人数**是需要就主站无法访问的事实达成一致的哨兵数量，以便真正将主服务器标记为失败，并最终在可能的情况下启动故障转移过程。
*   然而**仲裁仅用于检测故障**.为了实际执行故障转移，需要选择其中一个哨兵进行故障转移的领导者，并授权他们继续。这只发生在投票**大多数哨兵流程**.

例如，如果您有 5 个 Sentinel 进程，以及给定的仲裁
master 设置为值 2，发生如下情况：

*   如果两个哨兵同时同意主服务器无法访问，则两个哨兵中的一个将尝试启动故障转移。
*   如果总共至少有三个可访问的哨兵，则故障转移将被授权并实际启动。

实际上，这意味着在故障期间**如果大多数 Sentinel 进程无法通信，Sentinel 从不启动故障转移**（即少数分区中没有故障转移）。

### 其他哨兵选项

其他选项几乎总是采用以下形式：

    sentinel <option_name> <master_name> <option_value>

并用于以下目的：

*   `down-after-milliseconds`是实例不应使用的时间（以毫秒为单位）
    可访问（要么不回复我们的 PING，要么回复
    错误）对于哨兵开始认为它已经关闭。
*   `parallel-syncs`设置可重新配置为使用的副本数
    同时故障转移后的新主服务器。数字越低，
    完成故障转移过程需要更多时间，但是，如果
    副本配置为提供旧数据，您可能不希望所有副本
    同时与主服务器重新同步。而复制
    对于副本，进程大多是非阻塞的，有一个时刻它停止
    从主服务器加载批量数据。您可能希望确保只有一个副本
    通过将此选项设置为值 1，一次无法访问。

本文档的其余部分介绍了其他选项，以及
记录在示例中`sentinel.conf`文件随 Redis 一起提供
分配。

可以在运行时修改配置参数：

*   使用修改特定于主节点的配置参数`SENTINEL SET`.
*   全局配置参数修改为`SENTINEL CONFIG SET`.

查看[*在运行时重新配置 Sentinel*部分](#reconfiguring-sentinel-at-runtime)了解更多信息。

### 哨兵部署示例

现在您已经了解了有关哨兵的基本信息，您可能想知道在哪里
你应该放置你的哨兵进程，你需要多少个哨兵进程
等等。本部分介绍一些示例部署。

我们使用 ASCII 艺术向您展示*图形*
格式，这就是不同符号的含义：

    +--------------------+
    | This is a computer |
    | or VM that fails   |
    | independently. We  |
    | call it a "box"    |
    +--------------------+

我们在盒子里写下它们正在运行的内容：

    +-------------------+
    | Redis master M1   |
    | Redis Sentinel S1 |
    +-------------------+

不同的盒子通过线条连接，以表明它们能够说话：

    +-------------+               +-------------+
    | Sentinel S1 |---------------| Sentinel S2 |
    +-------------+               +-------------+

网络分区使用斜杠显示为中断行：

    +-------------+                +-------------+
    | Sentinel S1 |------ // ------| Sentinel S2 |
    +-------------+                +-------------+

另请注意：

*   母版被称为M1，M2，M3，...，Mn。
*   复制品称为 R1，R2，R3，...，Rn（R 代表*复制品*).
*   哨兵被称为S1，S2，S3，...，Sn。
*   客户端称为 C1、C2、C3、...、Cn。
*   当实例因 Sentinel 操作而更改角色时，我们将其放在方括号内，因此 \[M1] 表示由于 Sentinel 干预而成为主节点的实例。

请注意，我们永远不会显示**仅使用两个哨兵的设置**因为
哨兵总是需要**与大多数人交谈**为了启动一个
故障转移。

#### 示例 1：只有两个哨兵，不要这样做

    +----+         +----+
    | M1 |---------| R1 |
    | S1 |         | S2 |
    +----+         +----+

    Configuration: quorum = 1

*   在此设置中，如果主 M1 出现故障，R1 将被提升，因为两个哨兵可以就故障达成一致（显然仲裁设置为 1），并且还可以授权故障转移，因为大多数是 2。因此，显然它可以表面上工作，但是请检查以下几点，看看为什么此设置被破坏了。
*   如果运行 M1 的框停止工作，则 S1 也会停止工作。在另一个机箱 S2 中运行的 Sentinel 将无法授权故障转移，因此系统将不可用。

请注意，需要多数才能订购不同的故障转移，并在以后将最新配置传播到所有 Sentinels。另请注意，在上述设置的单端中进行故障转移的能力，如果没有任何协议，将是非常危险的：

    +----+           +------+
    | M1 |----//-----| [M1] |
    | S1 |           | S2   |
    +----+           +------+

在上面的配置中，我们创建了两个主服务器（假设 S2 可以进行故障转移）
未经授权）以完全对称的方式。客户端可以写入
对双方都不确定，并且没有办法理解何时
分区治愈了什么配置是正确的，以防止
一个*永久性裂脑状况*.

所以请**在三个不同的盒子中部署至少三个哨兵**总是。

#### 示例 2：三个盒子的基本设置

这是一个非常简单的设置，具有易于调整的优点
为了额外的安全性。它基于三个盒子，每个盒子运行两者
一个 Redis 进程和一个哨兵进程。

           +----+
           | M1 |
           | S1 |
           +----+
              |
    +----+    |    +----+
    | R2 |----+----| R3 |
    | S2 |         | S3 |
    +----+         +----+

    Configuration: quorum = 2

如果主 M1 出现故障，S2 和 S3 将就故障达成一致，并将
能够授权故障转移，使客户端能够继续。

在每个 Sentinel 设置中，由于 Redis 使用异步复制，因此存在
总是有丢失一些写入的风险，因为给定的确认写入
可能无法到达已提升为主副本的副本。但是
上述设置由于客户端被分区而存在更高的风险
与一位老主人，如下图所示：

             +----+
             | M1 |
             | S1 | <- C1 (writes will be lost)
             +----+
                |
                /
                /
    +------+    |    +----+
    | [M2] |----+----| R3 |
    | S2   |         | S3 |
    +------+         +----+

在这种情况下，网络分区隔离了旧的主站M1，因此
副本 R2 被提升为主副本。但是，像C1这样的客户端是
在与旧主站相同的分区中，可以继续写入数据
给老主人。此数据将永远丢失，因为分区
将愈合，主站将被重新配置为新主站的副本，
丢弃其数据集。

可以使用以下 Redis 复制来缓解此问题
功能，允许在主站检测到
它不再能够将其写入传输到指定数量的副本。

    min-replicas-to-write 1
    min-replicas-max-lag 10

采用以上配置（请看自评`redis.conf`Redis 发行版中的示例）一个 Redis 实例在充当主节点时，如果无法写入至少 1 个副本，它将停止接受写入。因为复制是异步的*无法写入*实际上意味着副本要么断开连接，要么没有向我们发送超过指定值的异步确认`max-lag`秒数。

使用此配置，上述示例中的旧 Redis 主 M1 将在 10 秒后变得不可用。当分区愈合时，Sentinel 配置将收敛到新配置，客户端 C1 将能够获取有效的配置，并将继续使用新的主服务器。

但是没有免费的午餐。通过此优化，如果两个副本是
向下，主站将停止接受写入。这是一种权衡。

#### 示例 3：客户端框中的哨兵

有时我们只有两个 Redis 盒子可用，一个用于主服务器和
一个用于复制副本。示例 2 中的配置在
这种情况，所以我们可以诉诸以下，哨兵被放置在哪里
其中客户端是：

                +----+         +----+
                | M1 |----+----| R1 |
                |    |    |    |    |
                +----+    |    +----+
                          |
             +------------+------------+
             |            |            |
             |            |            |
          +----+        +----+      +----+
          | C1 |        | C2 |      | C3 |
          | S1 |        | S2 |      | S3 |
          +----+        +----+      +----+

          Configuration: quorum = 2

在此设置中，Sentinels 的观点与客户端相同：如果
大多数客户都可以访问主站，这很好。
C1、C2、C3 这里是通用客户端，并不意味着 C1 标识
连接到 Redis 的单个客户端。它更有可能是这样的
一个应用程序服务器，一个Rails应用程序，或类似的东西。

如果运行 M1 和 S1 的机箱出现故障，将发生故障转移
没有问题，但是很容易看出不同的网络分区
将导致不同的行为。例如，哨兵将无法
以设置客户端和 Redis 服务器之间的网络是否为
已断开连接，因为 Redis 主服务器和副本都将不可用。

请注意，如果 C3 使用 M1 进行分区（几乎不可能使用
上述网络，但更有可能与不同
布局，或者因为软件层的故障），我们有类似的
示例 2 中描述的问题，不同之处在于我们这里有
没有办法打破对称性，因为只有复制品和主人，所以
主服务器在与其副本断开连接时无法停止接受查询，
否则，在副本失败期间，主服务器将永远不会可用。

因此，这是一个有效的设置，但示例 2 中的设置具有优势
例如Redis的HA系统与Redis本身在同一个盒子中运行
这可能更易于管理，并且能够对金额进行限制
少数分区中的主节点可以接收写入操作的时间。

#### 示例 4：少于三个客户端的 Sentinel 客户端

如果小于
客户端中的三个框（例如三个 Web 服务器）。在此
在这种情况下，我们需要采用如下混合设置：

                +----+         +----+
                | M1 |----+----| R1 |
                | S1 |    |    | S2 |
                +----+    |    +----+
                          |
                   +------+-----+
                   |            |
                   |            |
                +----+        +----+
                | C1 |        | C2 |
                | S3 |        | S4 |
                +----+        +----+

          Configuration: quorum = 3

这类似于示例 3 中的设置，但在这里我们运行四个 Sentinels
在我们可用的四个盒子里。如果主 M1 不可用
其他三个哨兵将执行故障转移。

从理论上讲，此设置可以删除运行C2和S4的盒子，并且
将仲裁设置为 2。但是，我们不太可能希望 HA 在
Redis 端在我们的应用层中没有高可用性。

### Sentinel、Docker、NAT 和可能的问题

Docker使用一种称为端口映射的技术：在Docker内运行的程序
容器可能暴露在不同的端口上，而容器的端口
程序认为正在使用。这对于运行多个操作很有用
容器在同一服务器中同时使用相同的端口。

Docker不是唯一发生这种情况的软件系统，还有其他
网络地址转换设置，其中端口可以重新映射，有时
不是端口，而是 IP 地址。

重新映射端口和地址会以两种方式产生 Sentinel 问题：

1.  哨兵自动发现其他哨兵不再有效，因为它基于*你好*消息，其中每个 Sentinel 宣布它们在哪个端口和 IP 地址侦听连接。但是，Sentinels无法理解地址或端口被重新映射，因此它正在宣布一个不正确的信息，以便其他Sentinels连接。
2.  副本列在`INFO`Redis 主站以类似的方式输出：地址由检查 TCP 连接的远程对等体的主站检测，而端口在握手期间由副本本身通告，但是端口可能由于与第 1 点中公开的原因相同而出错。

由于 Sentinels 使用主服务器自动检测副本`INFO`输出信息，
检测到的副本将无法访问，并且 Sentinel 将永远无法
故障转移主服务器，因为从以下角度来看，没有良好的副本
该系统，所以目前没有办法用Sentinel监控一套
使用 Docker 部署的主实例和副本实例，**除非你指示 Docker
映射端口 1：1**.

对于第一个问题，如果你想运行一组哨兵
使用具有转发端口的 Docker 的实例（或端口所在的任何其他 NAT 设置）
重新映射），您可以使用以下两个 Sentinel 配置指令
为了迫使 Sentinel 宣布一组特定的 IP 和端口：

    sentinel announce-ip <ip>
    sentinel announce-port <port>

请注意，Docker 能够运行在*主机网络模式*（检查`--net=host`选项以获取更多信息）。这应该不会产生任何问题，因为在此设置中不会重新映射端口。

### IP 地址和 DNS 名称

旧版本的 Sentinel 不支持主机名，并且要求在任何地方指定 IP 地址。
从版本 6.2 开始，Sentinel 具有*自选*支持主机名。

**默认情况下，此功能处于禁用状态。如果您要启用 DNS/主机名支持，请注意：**

1.  Redis 和 Sentinel 节点上的名称解析配置必须可靠，并且能够快速解析地址。地址解析的意外延迟可能会对 Sentinel 产生负面影响。
2.  您应该在任何地方使用主机名，并避免混合使用主机名和 IP 地址。为此，请使用`replica-announce-ip <hostname>`和`sentinel announce-ip <hostname>`分别用于所有 Redis 和 Sentinel 实例。

启用`resolve-hostnames`全局配置允许 Sentinel 接受主机名：

*   作为`sentinel monitor`命令
*   作为副本地址，如果副本使用主机名值`replica-announce-ip`

Sentinel 将接受主机名作为有效输入并对其进行解析，但在宣布实例、更新配置文件等时仍会引用 IP 地址。

启用`announce-hostnames`全局配置使 Sentinel 改用主机名。这会影响对客户端的答复，配置文件中写入的值，`REPLICAOF`向副本等发出命令。

此行为可能与所有可能显式需要 IP 地址的 Sentinel 客户端不兼容。

当客户端使用 TLS 连接到实例并需要名称而不是 IP 地址才能执行证书 ASN 匹配时，使用主机名可能很有用。

## 快速教程

在本文档的后续部分中，所有详细信息[*Sentinel API*](#sentinel-api),
配置和语义将逐步介绍。但是对于人来说
想要尽快与系统一起玩，本节是一个教程，显示
如何配置 3 个 Sentinel 实例并与之交互。

这里我们假设实例在端口 5000、5001、5002 处执行。
我们还假设您在端口 6379 上有一个正在运行的 Redis 主节点，并且
副本在端口 6380 上运行。我们将使用 IPv4 环回地址 127.0.0.1
在本教程中无处不在，假设您正在运行模拟
在您的个人计算机上。

三个 Sentinel 配置文件应如下所示：

    port 5000
    sentinel monitor mymaster 127.0.0.1 6379 2
    sentinel down-after-milliseconds mymaster 5000
    sentinel failover-timeout mymaster 60000
    sentinel parallel-syncs mymaster 1

其他两个配置文件将相同，但使用 5001 和 5002
作为端口号。

关于上述配置需要注意的几点：

*   主集称为`mymaster`.它标识主服务器及其副本。由于每个*主集*具有不同的名称，Sentinel 可以同时监视不同的主站和副本集。
*   仲裁设置为值 2（最后一个参数`sentinel monitor`配置指令）。
*   这`down-after-milliseconds`值为 5000 毫秒，即 5 秒，因此，只要我们在这段时间内没有收到 ping 的任何回复，主节点就会被检测为失败。

启动三个哨兵后，您将看到它们记录的一些消息，例如：

    +monitor master mymaster 127.0.0.1 6379 quorum 2

这是一个哨兵事件，您可以通过 Pub/Sub 接收此类事件
如果您`SUBSCRIBE`添加到事件名称，如后面指定[*发布/订阅消息*部分](#pubsub-messages).

Sentinel 在故障检测期间生成并记录不同的事件，以及
故障转移。

## 向哨兵询问大师的状态

与Sentinel一起开始的最明显的事情是检查
主人它正在监控做得很好：

    $ redis-cli -p 5000
    127.0.0.1:5000> sentinel master mymaster
     1) "name"
     2) "mymaster"
     3) "ip"
     4) "127.0.0.1"
     5) "port"
     6) "6379"
     7) "runid"
     8) "953ae6a589449c13ddefaee3538d356d287f509b"
     9) "flags"
    10) "master"
    11) "link-pending-commands"
    12) "0"
    13) "link-refcount"
    14) "1"
    15) "last-ping-sent"
    16) "0"
    17) "last-ok-ping-reply"
    18) "735"
    19) "last-ping-reply"
    20) "735"
    21) "down-after-milliseconds"
    22) "5000"
    23) "info-refresh"
    24) "126"
    25) "role-reported"
    26) "master"
    27) "role-reported-time"
    28) "532439"
    29) "config-epoch"
    30) "1"
    31) "num-slaves"
    32) "1"
    33) "num-other-sentinels"
    34) "2"
    35) "quorum"
    36) "2"
    37) "failover-timeout"
    38) "60000"
    39) "parallel-syncs"
    40) "1"

如您所见，它打印了有关主控形状的许多信息。有
我们特别感兴趣的几个：

1.  `num-other-sentinels`是2，所以我们知道哨兵已经为这个大师检测到了另外两个哨兵。如果您检查日志，您将看到`+sentinel`生成的事件。
2.  `flags`只是`master`.如果主人下来了，我们可以期待看到`s_down`或`o_down`标志以及这里。
3.  `num-slaves`正确设置为 1，因此 Sentinel 还检测到有一个附加到我们的主节点的副本。

为了了解有关此实例的更多信息，您可能需要尝试以下操作
两个命令：

    SENTINEL replicas mymaster
    SENTINEL sentinels mymaster

第一个将提供有关连接到
主人，第二个关于其他哨兵。

## 获取当前主服务器的地址

正如我们已经指定的那样，Sentinel 还充当
想要连接到一组主副本和副本的客户端。以
可能的故障转移或重新配置，客户端不知道谁是
给定实例集的当前活动主节点，因此 Sentinel 导出
一个 API 来问这个问题：

    127.0.0.1:5000> SENTINEL get-master-addr-by-name mymaster
    1) "127.0.0.1"
    2) "6379"

### 测试故障转移

此时，我们的玩具哨兵部署已准备好进行测试。我们可以
只需杀死我们的主人并检查配置是否更改。为此
我们可以做：

    redis-cli -p 6379 DEBUG sleep 30

此命令将使我们的主节点不再可访问，休眠 30 秒。
它基本上模拟了出于某种原因的主悬挂。

如果您检查 Sentinel 日志，您应该能够看到很多操作：

1.  每个哨兵检测到主站是否宕机`+sdown`事件。
2.  此事件稍后会升级到`+odown`，这意味着多个哨兵同意无法到达主人的事实。
3.  哨兵对将启动第一次故障转移尝试的哨兵进行投票。
4.  故障转移发生。

如果再次询问当前主地址`mymaster`最终
这次我们应该得到不同的回复：

    127.0.0.1:5000> SENTINEL get-master-addr-by-name mymaster
    1) "127.0.0.1"
    2) "6380"

目前为止，一切都好。。。此时，您可以跳转到创建 Sentinel 部署
或者可以阅读更多内容来了解所有 Sentinel 命令和内部。

## Sentinel API

Sentinel提供了一个API，以便检查其状态，检查运行状况
受监视的主站和副本，订阅以接收特定
通知，并在运行时更改 Sentinel 配置。

默认情况下，Sentinel 使用 TCP 端口 26379 运行（请注意，6379 是正常的
Redis port）。哨兵接受使用 Redis 协议的命令，因此您可以
用`redis-cli`或任何其他未经修改的 Redis 客户端，以便与之交谈
哨兵。

可以直接查询哨兵以检查状态
从其角度监视的 Redis 实例，看看还有什么
哨兵它知道，等等。或者，使用发布/订阅，可以
接收*推式*来自哨兵的通知，每次发生某些事件时
发生，如故障转移或实例进入错误条件，以及
等等。

### 哨兵命令

这`SENTINEL`命令是 Sentinel 的主要 API。以下是其子命令的列表（在适用的情况下注明了最低版本）：

*   **SENTINEL CONFIG GET`<name>`**(`>= 6.2`） 获取全局 Sentinel 配置参数的当前值。指定的名称可以是通配符，类似于 Redis`CONFIG GET`命令。
*   **哨兵配置集`<name>` `<value>`**(`>= 6.2`） 设置全局 Sentinel 配置参数的值。
*   **SENTINEL CKQUORUM`<master name>`**检查当前 Sentinel 配置是否能够达到故障转移主服务器所需的仲裁，以及授权故障转移所需的大多数配置。此命令应在监视系统中使用，以检查 Sentinel 部署是否正常。
*   **SENTINEL FLUSHCONFIG**强制 Sentinel 重写其在磁盘上的配置，包括当前的 Sentinel 状态。通常，Sentinel 会在每次状态发生更改时重写配置（在重新启动期间保留在磁盘上的状态子集的上下文中）。但是，有时配置文件可能会由于操作错误、磁盘故障、包升级脚本或配置管理器而丢失。在这些情况下，强制 Sentinel 重写配置文件的方法非常方便。即使完全缺少以前的配置文件，此命令也有效。
*   **哨兵故障转移`<master name>`**强制故障转移，就好像主服务器无法访问一样，并且不要求其他 Sentinels 同意（但是将发布新版本的配置，以便其他 Sentinels 更新其配置）。
*   **SENTINEL GET-MASTER-ADDR-BY-NAME`<master name>`**返回具有该名称的主服务器的 IP 和端口号。如果此主服务器的故障转移正在进行中或已成功终止，它将返回已提升副本的地址和端口。
*   **哨兵信息缓存**(`>= 3.2`） 返回缓存`INFO`主服务器和副本的输出。
*   **SENTINEL IS-MASTER-DOWN-BY-ADDR<ip> <port> <current-epoch> <runid>**从当前 Sentinel 的角度来看，检查 ip：port 指定的主节点是否已关闭。此命令主要用于内部使用。
*   **哨兵大师`<master name>`**显示指定主节点的状态和信息。
*   **哨兵大师**显示受监视主节点及其状态的列表。
*   **哨兵监视器**启动哨兵的监控。请参阅[*在运行时重新配置 Sentinel*部分](#reconfiguring-sentinel-at-runtime)了解更多信息。
*   **哨兵米德**(`>= 6.2`） 返回哨兵实例的 ID。
*   **SENTINEL PENDING-SCRIPTS**此命令返回有关挂起脚本的信息。
*   **哨兵移除**停止哨兵的监控。请参阅[*在运行时重新配置 Sentinel*部分](#reconfiguring-sentinel-at-runtime)了解更多信息。
*   **哨兵复制品`<master name>`**(`>= 5.0`） 显示此主服务器的副本列表及其状态。
*   **哨兵哨兵`<master name>`**显示此主服务器的哨兵实例及其状态的列表。
*   **哨兵套装**设置哨兵的监控配置。请参阅[*在运行时重新配置 Sentinel*部分](#reconfiguring-sentinel-at-runtime)了解更多信息。
*   **哨兵模拟失败（选举后崩溃|升级后崩溃|帮助）**(`>= 3.2`） 此命令模拟不同的 Sentinel 崩溃场景。
*   **哨兵复位`<pattern>`**此命令将重置具有匹配名称的所有主节点。模式参数是 glob 样式的模式。重置过程将清除主服务器中的任何先前状态（包括正在进行的故障转移），并删除已发现并与主服务器关联的每个副本和哨兵。

出于连接管理目的，Sentinel 支持 Redis 命令的以下子集：

*   **前交叉韧带**(`>= 6.2`） 此命令管理哨兵访问控制列表。有关详细信息，请参阅[前交叉韧带](/topics/acl)文档页面和[*哨兵访问控制列表身份验证*](#sentinel-access-control-list-authentication).
*   **认证**(`>= 5.0.1`） 对客户端连接进行身份验证。有关详细信息，请参阅`AUTH`命令和[*使用身份验证配置圣天诺实例*部分](#configuring-sentinel-instances-with-authentication).
*   **客户**此命令管理客户端连接。有关详细信息，请参阅其子命令的页面。
*   **命令**(`>= 6.2`） 此命令返回有关命令的信息。有关详细信息，请参阅`COMMAND`命令及其各种子命令。
*   **你好**(`>= 6.0`） 切换连接的协议。有关详细信息，请参阅`HELLO`命令。
*   **信息**返回有关哨兵服务器的信息和统计信息。有关详细信息，请参阅`INFO`命令。
*   **乒**此命令仅返回 PONG。
*   **角色**此命令返回字符串“sentinel”和受监视主节点的列表。有关详细信息，请参阅`ROLE`命令。
*   **关闭**关闭哨兵实例。

最后，Sentinel 还支持`SUBSCRIBE`,`UNSUBSCRIBE`,`PSUBSCRIBE`和`PUNSUBSCRIBE`命令。请参阅[*发布/订阅消息*部分](#pubsub-messages)了解更多详情。

### 在运行时重新配置 Sentinel

从 Redis 版本 2.8.4 开始，Sentinel 提供了一个 API，用于添加、删除或更改给定主服务器的配置。请注意，如果您有多个哨兵，则应将更改应用于所有实例，以便 Redis Sentinel 正常工作。这意味着更改单个哨兵的配置不会自动将更改传播到网络中的其他哨兵。

以下是`SENTINEL`用于更新 Sentinel 实例配置的子命令。

*   **哨兵监视器`<name>` `<ip>` `<port>` `<quorum>`**此命令告诉 Sentinel 开始监视具有指定名称、IP、端口和仲裁的新主服务器。它与`sentinel monitor`中的配置指令`sentinel.conf`配置文件，不同之处在于您不能在 中将主机名用作`ip`，但您需要提供 IPv4 或 IPv6 地址。
*   **哨兵移除`<name>`**用于删除指定的主节点：主节点将不再受到监视，并且将从 Sentinel 的内部状态中完全删除，因此它将不再由`SENTINEL masters`等等。
*   **哨兵套装`<name>`\[`<option>` `<value>`...]**SET 命令与`CONFIG SET`命令，用于更改特定主服务器的配置参数。可以指定多个选项/值对（或根本不指定任何选项/值对）。所有配置参数均可通过以下方式进行配置：`sentinel.conf`也可以使用 SET 命令进行配置。

以下是`SENTINEL SET`命令以修改`down-after-milliseconds`主设备的配置称为`objects-cache`:

    SENTINEL SET objects-cache-master down-after-milliseconds 1000

如前所述，`SENTINEL SET`可用于设置在启动配置文件中可设置的所有配置参数。此外，可以仅更改主仲裁配置，而无需删除并重新添加主仲裁配置`SENTINEL REMOVE`其次`SENTINEL MONITOR`，但只需使用：

    SENTINEL SET objects-cache-master quorum 5

请注意，没有等效的 GET 命令，因为`SENTINEL MASTER`以易于解析的格式（作为字段/值对数组）提供所有配置参数。

从 Redis 版本 6.2 开始，Sentinel 还允许获取和设置在此之前的配置文件中仅支持的全局配置参数。

*   **SENTINEL CONFIG GET`<name>`**获取全局 Sentinel 配置参数的当前值。指定的名称可以是通配符，类似于 Redis`CONFIG GET`命令。
*   **哨兵配置集`<name>` `<value>`**设置全局 Sentinel 配置参数的值。

可以操作的全局参数包括：

*   `resolve-hostnames`,`announce-hostnames`.看[*IP 地址和 DNS 名称*](#ip-addresses-and-dns-names).
*   `announce-ip`,`announce-port`.看[*Sentinel、Docker、NAT 和可能的问题*](#sentinel-docker-nat-and-possible-issues).
*   `sentinel-user`,`sentinel-pass`.看[*使用身份验证配置圣天诺实例*](#configuring-sentinel-instances-with-authentication).

### 添加或删除哨兵

将新的 Sentinel 添加到您的部署中是一个简单的过程，因为
由 Sentinel 实现的自动发现机制。您需要做的就是
启动配置为监视当前活动主服务器的新哨兵。
在10秒内，哨兵将获得其他哨兵的列表，并且
附加到主节点的副本集。

如果需要一次添加多个哨兵，建议添加
一个接一个，等待所有其他哨兵已经知道
在添加下一个之前，关于第一个。这对于静止非常有用
保证多数只能在分区的一侧实现，
在添加新哨兵的过程中应该发生故障的机会。

这可以通过添加每个延迟为30秒的新哨兵以及在没有网络分区的情况下轻松实现。

在过程结束时，可以使用以下命令
`SENTINEL MASTER mastername`为了检查是否所有哨兵都同意
监视主站的哨兵总数。

删除哨兵有点复杂：**哨兵永远不会忘记已经看到
哨兵**，即使它们很长一段时间都无法到达，因为我们没有
想要动态更改授权故障转移所需的多数，并且
创建新的配置号。所以为了移除哨兵
在没有网络分区的情况下，应执行以下步骤：

1.  停止要删除的哨兵的哨兵进程。
2.  发送`SENTINEL RESET *`命令到所有其他 Sentinel 实例（而不是`*`如果您只想重置单个主名称，则可以使用确切的主名称）。一个接一个，在实例之间等待至少 30 秒。
3.  通过检查`SENTINEL MASTER mastername`每个哨兵。

### 删除旧的主副本或无法访问的副本

哨兵永远不会忘记给定主人的复制品，即使他们是
长时间无法访问。这很有用，因为哨兵应该能够
以在网络分区或
失败事件。

此外，在故障转移之后，故障转移主服务器实际上被添加为
新主节点的副本，这样它将被重新配置为复制
新主控版一旦再次可用。

但是，有时您希望删除复制副本（可能是旧的主副本）
永远从哨兵监控的副本列表中。

为此，您需要发送一个`SENTINEL RESET mastername`命令
到所有哨兵：他们将刷新下一个哨兵中的副本列表
10 秒，仅添加从
当前主站`INFO`输出。

### 发布/订阅消息

客户端可以使用 Sentinel 作为与 Redis 兼容的发布/订阅服务器
（但你不能使用`PUBLISH`） 以`SUBSCRIBE`或`PSUBSCRIBE`自
频道并获得有关特定事件的通知。

频道名称与事件名称相同。例如
频道名称`+sdown`将收到与实例相关的所有通知
输入`SDOWN`（SDOWN 表示无法再从以下位置访问实例
您正在查询的哨兵）条件的观点。

要获取所有消息，只需使用`PSUBSCRIBE *`.

以下是您可以使用以下方法接收的通道和消息格式的列表
这个 API。第一个词是通道/事件名称，其余是数据的格式。

注意：其中*实例详细信息*，则表示提供以下参数来标识目标实例：

    <instance-type> <name> <ip> <port> @ <master-name> <master-ip> <master-port>

标识主控形状的部件（从 @ 参数到结尾）是可选的
并且仅当实例本身不是主实例时才指定。

*   **+复位主站** `<instance details>`-- 主设备已重置。
*   **+从站** `<instance details>`-- 检测到并附加了新的复制副本。
*   **+故障转移-状态-侦察-从站** `<instance details>`-- 故障切换状态更改为`reconf-slaves`州。
*   **+检测到故障转移** `<instance details>`-- 检测到由另一个 Sentinel 或任何其他外部实体启动的故障转移（附加的副本变为主节点）。
*   **+从站-侦察-发送** `<instance details>`-- 领导哨兵派出`REPLICAOF`命令，以便为新副本重新配置它。
*   **+slave-reconf-inprog** `<instance details>`-- 正在重新配置的副本显示为新的主 ip：端口对的副本，但同步过程尚未完成。
*   **+从属-侦察-完成** `<instance details>`-- 复制副本现在已与新主服务器同步。
*   **-dup-sentinel** `<instance details>`-- 指定主服务器的一个或多个哨兵被作为重复项删除（例如，当重新启动 Sentinel 实例时，就会发生这种情况）。
*   **+哨兵** `<instance details>`-- 检测到并连接了该主站的新哨兵。
*   **+击倒** `<instance details>`-- 指定的实例现在处于主观关闭状态。
*   **-下巴** `<instance details>`-- 指定的实例不再处于主观关闭状态。
*   **+odown** `<instance details>`-- 指定的实例现在处于“客观关闭”状态。
*   **-odown** `<instance details>`-- 指定的实例不再处于“客观关闭”状态。
*   **+新纪元** `<instance details>`-- 当前纪元已更新。
*   **+尝试-故障转移** `<instance details>`-- 新的故障转移正在进行中，等待由多数人选举产生。
*   **+民选领袖** `<instance details>`-- 在指定时间段内赢得选举，可以执行故障转移。
*   **+故障转移-状态-选择-从属** `<instance details>`-- 新的故障转移状态为`select-slave`：我们正在努力寻找合适的复制品进行推广。
*   **没有好奴隶** `<instance details>`-- 没有好的复制品可以推广。目前，我们将在一段时间后尝试，但在这种情况下，情况可能会更改，状态机将中止故障转移。
*   **选定的从属** `<instance details>`-- 我们找到了要提升的指定良好副本。
*   **failover-state-send-slaveof-noone** `<instance details>`-- 我们正在尝试将提升的副本重新配置为主副本，等待它切换。
*   **故障转移结束超时** `<instance details>`-- 故障转移因超时而终止，副本最终将被配置为使用新的主服务器进行复制。
*   **故障转移端** `<instance details>`-- 故障转移成功终止。所有副本似乎都已重新配置为使用新主服务器进行复制。
*   **交换机主站** `<master name> <oldip> <oldport> <newip> <newport>`-- 主新 IP 和地址是配置更改后的指定 IP 和地址。这是**大多数外部用户感兴趣的消息**.
*   **+倾斜**-- 已进入倾斜模式。
*   **-倾斜**-- 倾斜模式退出。

### -BUSY 状态的处理

当 Lua 脚本正在运行 时，Redis 实例返回 -BUSY 错误
超过配置的 Lua 脚本时间限制的时间。当这种情况发生之前
触发故障转移 Redis Sentinel 将尝试发送`SCRIPT KILL`
命令，仅当脚本为只读时才会成功。

如果实例在这次尝试后仍处于错误状态，它将
最终被故障转移。

## 副本优先级

Redis 实例具有一个名为`replica-priority`.
此信息由 Redis 副本实例在其`INFO`输出
和 Sentinel 使用它，以便在可以
用于故障转移主服务器：

1.  如果复制副本优先级设置为 0，则永远不会将复制副本提升为主副本。
2.  具有*降低*优先级编号由 Sentinel 首选。

例如，如果当前数据中心内有一个副本 S1
主站，以及另一个数据中心的另一个副本S2，可以设置
S1 的优先级为 10，S2 的优先级为 100，因此如果主站
失败，并且 S1 和 S2 都可用，S1 将是首选。

有关选择副本的方式的详细信息，请查看[*复制副本选择和优先级*部分](#replica-selection-and-priority)的文档。

### Sentinel 和 Redis 身份验证

当主服务器配置为要求从客户端进行身份验证时，
作为一项安全措施，副本还需要了解
命令以向主服务器进行身份验证并创建主副本连接
用于异步复制协议。

## Redis 访问控制列表身份验证

从 Redis 6 开始，用户身份验证和权限通过[访问控制列表 （ACL）](/topics/acl).

为了让哨兵连接到 Redis 服务器实例
配置了 ACL，哨兵配置必须包括
以下指令：

    sentinel auth-user <master-group-name> <username>
    sentinel auth-pass <master-group-name> <password>

哪里`<username>`和`<password>`是用于访问组实例的用户名和密码。应在具有最低控制权限的组的所有 Redis 实例上预配这些凭证。例如：

    127.0.0.1:6379> ACL SETUSER sentinel-user ON >somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill

### Redis 仅密码身份验证

在 Redis 6 之前，使用以下配置指令实现身份验证：

*   `requirepass`在主服务器中，为了设置身份验证密码，并确保实例不会处理未经身份验证的客户端的请求。
*   `masterauth`，以便副本向主服务器进行身份验证，以便从中正确复制数据。

使用 Sentinel 时，没有单个主服务器，因为在故障转移之后
副本可以扮演主节点的角色，旧的主节点可以在
为了充当副本，所以您要做的是设置上述指令
在您的所有实例中，包括主实例和副本。

这通常也是一个合理的设置，因为您不想保护
仅在主服务器中的数据，在副本中具有相同的数据可访问。

但是，在需要可访问的副本的罕见情况下
无需身份验证，您仍可以通过设置来执行此操作**副本优先级
的零**，以防止此复制副本提升为主副本，以及
在此复制副本中仅配置`masterauth`指令，不带
使用`requirepass`指令，以便数据可以通过以下方式读取
未经身份验证的客户端。

为了让哨兵连接到 Redis 服务器实例
配置了`requirepass`，则 Sentinel 配置必须包括
`sentinel auth-pass`指令，格式为：

    sentinel auth-pass <master-group-name> <password>

## 使用身份验证配置圣天诺实例

Sentinel 实例本身可以通过要求客户端通过`AUTH`命令。从 Redis 6.2 开始，[访问控制列表 （ACL）](/topics/acl)可用，而以前的版本（从 Redis 5.0.1 开始）支持仅密码身份验证。

请注意，圣天诺的身份验证配置应为**应用于每个实例**在部署中，以及**所有实例都应使用相同的配置**.此外，不应同时使用 ACL 和仅密码身份验证。

### 哨兵访问控制列表身份验证

使用 ACL 保护 Sentinel 实例的第一步是防止对其进行任何未经授权的访问。为此，您需要禁用默认超级用户（或者至少使用强密码设置它）并创建一个新密码并允许其访问Pub /Sub频道：

    127.0.0.1:5000> ACL SETUSER admin ON >admin-password allchannels +@all
    OK
    127.0.0.1:5000> ACL SETUSER default off
    OK

Sentinel 使用默认用户连接到其他实例。您可以使用以下配置指令提供其他超级用户的凭据：

    sentinel sentinel-user <username>
    sentinel sentinel-pass <password>

哪里`<username>`和`<password>`分别是哨兵的超级用户和密码（例如`admin`和`admin-password`在上面的示例中）。

最后，为了验证传入客户端连接，您可以创建 Sentinel 受限用户配置文件，如下所示：

    127.0.0.1:5000> ACL SETUSER sentinel-user ON >user-password -@all +auth +client|getname +client|id +client|setname +command +hello +ping +role +sentinel|get-master-addr-by-name +sentinel|master +sentinel|myid +sentinel|replicas +sentinel|sentinels

有关详细信息，请参阅您选择的圣天诺客户的文档。

### 圣天诺仅密码身份验证

要将 Sentinel 与仅密码身份验证结合使用，请添加`requirepass`配置指令**都**您的哨兵实例如下：

    requirepass "your_password_here"

以这种方式配置时，Sentinels将执行两项操作：

1.  客户端需要密码才能将命令发送到哨兵。这是显而易见的，因为这就是这种配置指令在Redis中的工作方式。
2.  此外，此 Sentinel 实例将使用配置为访问本地 Sentinel 的相同密码，以便向它连接到的所有其他 Sentinel 实例进行身份验证。

这意味着**您将必须配置相同的`requirepass`所有哨兵实例中的密码**.这样，每个 Sentinel 都可以与每个其他 Sentinel 通信，而无需为每个 Sentinel 配置密码来访问所有其他 Sentinel，这是非常不切实际的。

在使用此配置之前，请确保您的客户端库可以发送`AUTH`命令到哨兵实例。

### 圣天诺客户端实施

***

Sentinel 需要显式客户端支持，除非系统配置为执行脚本，该脚本将所有请求透明重定向到新的主实例（虚拟 IP 或其他类似系统）。本文档介绍了客户端库实现的主题[哨兵客户端指南](/topics/sentinel-clients).

## 更高级的概念

在以下部分中，我们将介绍有关 Sentinel 如何工作的一些详细信息，
无需诉诸实现细节和算法，这将是
本文最后一部分将对此进行介绍。

### 停机和 ODOWN 失败状态

Redis Sentinel有两个不同的概念*停机*，一个称为
一个*主观下降*条件 （SDOWN）， 并且是一种关闭条件，它是
给定哨兵实例的本地。另一个叫做*客观下降*
条件（ODOWN）和当足够的哨兵（至少
配置为`quorum`受监控主站的参数）具有
SDOWN 条件，并使用
这`SENTINEL is-master-down-by-addr`命令。

从哨兵的角度来看，当SDOWN条件达到时
未收到对秒数的 PING 请求的有效回复
在配置中指定为`is-master-down-after-milliseconds`
参数。

对 PING 的可接受答复是以下之一：

*   PING回答+PONG。
*   PING 回复了 -LOADING 错误。
*   PING 回复了 -MASTERDOWN 错误。

任何其他回复（或根本没有回复）均被视为无效。
但请注意，**将自身公布为副本的逻辑主服务器
INFO 输出被视为已关闭**.

请注意，SDOWN 要求整个过程中不接收可接受的答复
已配置间隔，例如，如果间隔为 30000 毫秒
（30 秒），并且我们每 29 秒收到一个可接受的 ping 回复，
实例被视为正在工作。

SDOWN 不足以触发故障转移：它仅意味着单个哨兵
认为 Redis 实例不可用。要触发故障转移，您需要
必须达到 ODOWN 状态。

要从SDOWN切换到ODOWN，没有使用强共识算法，但是
只是一种八卦形式：如果一个给定的哨兵得到一个大师的报告
没有足够的哨兵工作**在给定的时间范围内**，则 SDOWN 为
晋升为 ODOWN。如果以后缺少此确认，则会清除该标志。

需要使用实际多数的更严格的授权
为了真正启动故障转移，但如果没有
达到 ODOWN 状态。

ODOWN 条件**仅适用于母版**.对于其他类型的实例
Sentinel 不需要执行操作，因此副本永远不会达到 ODOWN 状态
和其他哨兵，但只有SDOWN是。

然而，SDOWN也有语义含义。例如，SDOWN 中的副本
状态未被选定为由执行故障转移的 Sentinel 提升。

## 哨兵和副本自动发现

哨兵与其他哨兵保持联系，以便相互
检查彼此的可用性，并交换消息。但是你
不需要在每个哨兵中配置其他哨兵地址的列表
您运行的实例，因为 Sentinel 使用 Redis 实例发布/订阅功能
为了发现监视相同主站的其他哨兵
和副本。

此功能是通过发送*你好留言*进入名为
`__sentinel__:hello`.

同样，您不需要配置附加的副本列表
到主节点，因为 Sentinel 会自动发现此列表，查询 Redis。

*   每个哨兵都会向每个受监视的主站和副本发布/订阅通道发布一条消息`__sentinel__:hello`，每两秒钟，通过 ip、端口、runid 宣布其存在。
*   每个哨兵都订阅了发布/订阅频道`__sentinel__:hello`每个主人和复制品，寻找未知的哨兵。当检测到新的哨兵时，它们将被添加为此主站的哨兵。
*   Hello 消息还包括主服务器的完整当前配置。如果接收 Sentinel 对给定主服务器的配置早于接收的主服务器的配置，则会立即更新到新配置。
*   在将新哨兵添加到主站之前，哨兵总是检查是否已经存在具有相同符文或相同地址（ip和端口对）的哨兵。在这种情况下，将删除所有匹配的哨兵，并添加新的哨兵。

## 故障转移过程之外的实例的 Sentinel 重新配置

即使没有进行故障转移，Sentinels 也将始终尝试将
受监控实例上的当前配置。具体说来：

*   声称是主服务器的副本（根据当前配置）将配置为副本以与当前主服务器进行复制。
*   连接到错误主服务器的副本将被重新配置为使用正确的主服务器进行复制。

对于要重新配置副本的 Sentinels，必须在一段时间内观察到错误的配置，这比用于广播新配置的时间段要长。

这可以防止具有陈旧配置的 Sentinels（例如，因为它们刚刚从分区重新加入）在接收更新之前尝试更改副本配置。

另请注意，始终尝试强制实施当前配置的语义如何使故障转移对分区更具抵抗力：

*   故障转移的主节点在恢复可用时将重新配置为副本。
*   在分区期间分区的副本在可访问后将重新配置。

关于本节要记住的重要一课是：**Sentinel 是一个系统，其中每个进程将始终尝试将最后一个逻辑配置强加给受监视的实例集**.

### 复制副本选择和优先级

当 Sentinel 实例准备好执行故障转移时，因为主实例
位于`ODOWN`状态，并且哨兵已收到故障转移授权
从大多数已知的哨兵实例中，需要合适的副本
以被选中。

复制副本选择过程将评估有关复制副本的以下信息：

1.  与主设备的断开连接时间。
2.  副本优先级。
3.  已处理复制偏移。
4.  运行 ID。

发现与主服务器断开连接超过十个的副本
倍于配置的主超时（毫秒后停机选项），加上
从主站的角度来看，母版也不可用的时间
哨兵做故障转移，被认为是不适合故障转移的
并被跳过。

用更严格的话来说，复制品`INFO`输出表明它已被
与主设备断开连接的时间超过：

    (down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state

被认为是不可靠的，完全被忽视。

复制副本选择仅考虑通过上述测试的副本，
并根据上述条件按以下顺序对其进行排序。

1.  复制副本按以下条件排序`replica-priority`如`redis.conf`文件。优先级较低者优先。
2.  如果优先级相同，则检查副本处理的复制偏移，并选择从主服务器接收更多数据的副本。
3.  如果多个副本具有相同的优先级并处理来自主节点的相同数据，则执行进一步的检查，选择运行 ID 在字典上较小的副本。对于副本来说，具有较低的运行 ID 并不是真正的优势，但对于使副本选择过程更具确定性（而不是诉诸于选择随机副本）非常有用。

在大多数情况下，`replica-priority`不需要显式设置，因此所有
实例将使用相同的默认值。如果存在特定的故障转移
偏好`replica-priority`必须在所有实例（包括主实例）上设置，
因为主站可能会在将来的某个时间点成为复制品 - 然后它将
需要适当的`replica-priority`设置。

Redis 实例可以配置一个特殊`replica-priority`的零
为了成为**从未选择**由哨兵作为新主人。
但是，以这种方式配置的副本仍将由
哨兵为了在故障转移后与新的主站进行复制，
唯一的区别是，它永远不会成为主人。

## 算法和内部

在以下部分中，我们将探讨 Sentinel 行为的详细信息。
用户并不严格需要了解所有细节，而是
对 Sentinel 的深入了解可能有助于部署和操作 Sentinel
一种更有效的方法。

### 法定人数

前面的部分显示，Sentinel 监控的每个主站都与已配置的**法定人数**.它指定哨兵进程的数量
需要就主节点的无法访问或错误条件达成一致
以触发故障转移。

但是，在触发故障转移后，为了实际执行故障转移，**至少大多数哨兵必须授权哨兵
故障转移**.Sentinel 从不在分区中执行故障转移，其中
少数哨兵存在。

让我们试着把事情说得更清楚一点：

*   仲裁：需要检测错误条件以便将主服务器标记为**奥当**.
*   故障转移由**奥当**州。
*   触发故障转移后，尝试故障转移的 Sentinel 需要向大多数 Sentinels 请求授权（如果仲裁设置为大于大多数，则请求授权超过大多数 Sentinel）。

这种差异可能看起来很微妙，但实际上很容易理解和使用。 例如，如果您有 5 个 Sentinel 实例，并且仲裁设置为 2，则只要 2 个 Sentinel 认为主服务器无法访问，就会触发故障转移，但是，只有当两个 Sentinel 中的一个至少从 3 个 Sentinels 获得授权时，才会触发故障转移。

相反，如果将仲裁配置为 5，则所有 Sentinels 必须就主错误条件达成一致，并且需要所有 Sentinels 的授权才能进行故障转移。

这意味着可以通过两种方式使用仲裁来调整 Sentinel：

1.  如果将仲裁设置为小于我们部署的大多数 Sentinel 的值，我们基本上会使 Sentinel 对主故障更加敏感，一旦只有少数 Sentinel 不再能够与主服务器通信，就会触发故障转移。
2.  如果将仲裁设置为大于大多数 Sentinels 的值，则仅当有大量（大于大多数）连接良好的 Sentinel 同意主服务器关闭时，我们才会使 Sentinel 能够进行故障转移。

### 配置纪元

哨兵需要获得多数人的授权才能启动
故障转移有几个重要原因：

当哨兵获得授权时，它将获得唯一**配置纪元**对于主节点，它正在故障转移。此数字将用于在故障转移完成后对新配置进行版本控制。因为大多数人同意给定的版本被分配给给定的哨兵，所以没有其他哨兵能够使用它。这意味着每个故障转移的每个配置都使用唯一的版本进行版本控制。我们将了解为什么这如此重要。

此外，Sentinels有一个规则：如果一个Sentinel投票给另一个Sentinel进行给定主节点的故障转移，它将等待一段时间以尝试再次故障转移同一个主节点。此延迟是`2 * failover-timeout`您可以在 中配置`sentinel.conf`.这意味着 Sentinels 不会尝试同时故障转移同一主节点，第一个请求获得授权的人会尝试，如果失败，另一个会在一段时间后尝试，依此类推。

瑞迪斯哨兵保证*活性*属性，如果大多数哨兵能够通信，最终将授权一个哨兵在主站关闭时进行故障转移。

Redis Sentinel还保证*安全*属性，即每个 Sentinel 将使用不同的主节点对同一主节点进行故障转移*配置纪元*.

### 配置传播

一旦哨兵能够成功故障转移主服务器，它将开始广播新配置，以便其他哨兵将更新有关给定主服务器的信息。

要将故障转移视为成功，它要求 Sentinel 能够发送`REPLICAOF NO ONE`命令到选定的复制副本，并且稍后在`INFO`主设备的输出。

此时，即使正在进行副本的重新配置，故障转移也被视为成功，并且需要所有 Sentinel 开始报告新配置。

新配置的传播方式是我们需要
Sentinel 故障转移使用不同的版本号（配置 epoch）进行授权。

每个 Sentinel 在主服务器和所有副本中都使用 Redis Pub/Sub 消息持续广播其主站配置版本。 同时，所有哨兵都在等待消息，看看配置是什么
由其他哨兵做广告。

配置在`__sentinel__:hello`发布/订阅频道。

由于每个配置都有不同的版本号，因此版本越大
总是胜过较小的版本。

例如，主设备的配置`mymaster`从所有
哨兵相信主人在192.168.1.50：6379。此配置
具有版本 1。一段时间后，哨兵被授权使用版本 2 进行故障转移。如果故障转移成功，它将开始广播新配置，例如版本 2 的 192.168.1.50：9000。所有其他实例将看到此配置，并将相应地更新其配置，因为新配置具有更高的版本。

这意味着 Sentinel 保证第二个活动属性：一组
能够通信的哨兵将全部收敛到具有较高版本号的相同配置。

基本上，如果对网络进行分区，每个分区都会收敛到更高的分区
本地配置。在没有分区的特殊情况下，有一个
分区和每个哨兵都会就配置达成一致。

### 分区下的一致性

Redis Sentinel 配置最终是一致的，因此每个分区都将
收敛到更高的可用配置。
然而，在使用Sentinel的现实世界系统中，有三种不同的玩家：

*   Redis 实例。
*   哨兵实例。
*   客户。

为了定义系统的行为，我们必须考虑所有这三个方面。

下面是一个简单的网络，其中有 3 个节点，每个节点都在运行
一个 Redis 实例和一个 Sentinel 实例：

                +-------------+
                | Sentinel 1  |----- Client A
                | Redis 1 (M) |
                +-------------+
                        |
                        |
    +-------------+     |          +------------+
    | Sentinel 2  |-----+-- // ----| Sentinel 3 |----- Client B
    | Redis 2 (S) |                | Redis 3 (M)|
    +-------------+                +------------+

在这个系统中，原始状态是Redis 3是主站，而
Redis 1 和 2 是复制品。发生分区以隔离旧的主服务器。
Sentinels 1 和 2 启动了故障转移，将 Sentinel 1 提升为新的主节点。

哨兵属性保证哨兵 1 和 2 现在具有新的
主服务器的配置。然而，Sentinel 3仍然有旧的配置。
因为它位于不同的分区中。

我们知道，当网络时，Sentinel 3将更新其配置。
分区将愈合，但是如果存在分区，则在分区期间会发生什么
客户端是否使用旧主服务器进行分区？

客户仍然可以写信给Redis 3，老主人。当
分区将重新加入，Redis 3 将变成 Redis 1 的副本，并且
在分区期间写入的所有数据都将丢失。

根据您的配置，您可能希望或不希望发生这种情况：

*   如果您使用 Redis 作为缓存，客户端 B 仍然能够写入旧的主服务器，即使其数据会丢失，也可能很方便。
*   如果您使用 Redis 作为存储，则这并不好，您需要配置系统才能部分防止此问题。

由于 Redis 是异步复制的，因此在这种情况下无法完全防止数据丢失，但是您可以限制 Redis 3 和 Redis 1 之间的分歧
使用以下 Redis 配置选项：

    min-replicas-to-write 1
    min-replicas-max-lag 10

采用以上配置（请看自评`redis.conf`Redis 发行版中的示例）一个 Redis 实例在充当主节点时，如果无法写入至少 1 个副本，它将停止接受写入。因为复制是异步的*无法写入*实际上意味着副本要么断开连接，要么没有向我们发送超过指定值的异步确认`max-lag`秒数。

使用此配置，上述示例中的 Redis 3 将在 10 秒后不可用。当分区愈合时，Sentinel 3 配置将收敛到
新的，客户端B将能够获取有效的配置并继续。

一般来说，Redis + Sentinel作为一个整体是一个**最终一致的系统**其中合并函数为**上次故障转移获胜**，并且丢弃旧主服务器的数据以复制当前主服务器的数据，因此始终存在丢失已确认写入的窗口。这是由于 Redis 异步
复制和系统的“虚拟”合并功能的丢弃性质。请注意，这不是 Sentinel 本身的限制，如果使用强一致的复制状态机协调故障转移，则相同的属性仍将适用。只有两种方法可以避免丢失已确认的写入：

1.  使用同步复制（以及适当的共识算法来运行复制的状态机）。
2.  使用最终一致的系统，其中可以合并同一对象的不同版本。

Redis目前无法使用上述任何系统，目前处于开发目标之外。但是，有代理在Redis商店（如SoundCloud）之上实现解决方案“2”[罗氏](https://github.com/soundcloud/roshi)或网飞[迪诺米特](https://github.com/Netflix/dynomite).

## 哨兵持久状态

哨兵状态保留在哨兵配置文件中。例如
每次收到或创建新配置（领导者哨兵）时，对于
主节点，配置与配置一起保留在磁盘上
时代。这意味着停止和重新启动 Sentinel 进程是安全的。

### 倾斜模式

Redis Sentinel在很大程度上依赖于计算机时间：例如
为了了解实例是否可用，它会记住
最近成功回复 PING 命令，并将其与当前命令进行比较
是时候了解它有多老了。

但是，如果计算机时间以意外方式更改，或者如果计算机
非常繁忙，或者由于某种原因进程被阻止，Sentinel 可能会开始
以意想不到的方式行事。

TILT模式是一种特殊的“保护”模式，哨兵可以在以下情况下进入
检测到一些奇怪的东西，可能会降低系统的可靠性。
Sentinel计时器中断通常称为每秒10次，因此我们
预计两次调用之间将经过或多或少的 100 毫秒
到计时器中断。

Sentinel 所做的是注册计时器中断的上一次
被调用，并将其与当前调用进行比较：如果时差
为负数或意外变大（2 秒或更长时间）进入 TILT 模式
（或者如果已经进入，则从TILT模式退出推迟）。

当处于 TILT 模式时，Sentinel 将继续监视所有内容，但是：

*   它完全停止行动。
*   它开始消极地回复`SENTINEL is-master-down-by-addr`请求作为检测故障的能力不再受信任。

如果 30 秒内一切正常，则退出 TILT 模式。

在 Sentinel TILT 模式下，如果我们发送 INFO 命令，我们可以得到以下响应：

    $ redis-cli -p 26379
    127.0.0.1:26379> info
    (Other information from Sentinel server skipped.)

    # Sentinel
    sentinel_masters:1
    sentinel_tilt:0
    sentinel_tilt_since_seconds:-1
    sentinel_running_scripts:0
    sentinel_scripts_queue_length:0
    sentinel_simulate_failure_flags:0
    master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=0,sentinels=1

字段“sentinel_tilt_since_seconds”表示哨兵已处于 TILT 模式的秒数。
如果它不处于 TILT 模式，则该值将为 -1。

请注意，在某些方面，TILT模式可以使用单调时钟进行替换
许多内核提供的 API。然而，目前还不清楚这是否是一件好事
解决方案，因为当前系统避免了问题，以防该过程只是
计划程序长时间挂起或未执行。

**关于本手册页中使用的“奴隶”一词的说明**：从 Redis 5 开始，如果不是为了向后兼容，Redis 项目不再使用“从属”一词。不幸的是，在此命令中，单词 slave 是协议的一部分，因此只有当此 API 自然弃用时，我们才能删除此类事件。
