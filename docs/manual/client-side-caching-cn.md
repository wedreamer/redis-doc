---
title: "Client-side caching in Redis"
linkTitle: "Client-side caching"
weight: 1
description: >
    Server-assisted, client-side caching in Redis
aliases:
    - /topics/client-side-caching
---

客户端缓存是一种用于创建高性能服务的技术。
它利用应用程序服务器上可用的内存, 这些服务器通常将不同的计算机与数据库节点进行比较, 以存储一些子集的数据库信息直接在应用程序端。

通常, 当需要数据时, 应用程序服务器会向数据库询问此类信息, 如下图所示：

    +-------------+                                +----------+
    |             | ------- GET user:1234 -------> |          |
    | Application |                                | Database |
    |             | <---- username = Alice ------- |          |
    +-------------+                                +----------+

使用客户端缓存时, 应用程序将存储流行的查询直接在应用程序内存中, 以便它可以稍后重用此类回复, 而无需再次联系数据库：

    +-------------+                                +----------+
    |             |                                |          |
    | Application |       ( No chat needed )       | Database |
    |             |                                |          |
    +-------------+                                +----------+
    | Local cache |
    |             |
    | user:1234 = |
    | username    |
    | Alice       |
    +-------------+

虽然用于本地缓存的应用程序内存可能不是很大, 访问本地计算机内存所需的时间是与访问数据库等网络服务相比, 幅度更小。
但是由于经常访问相同比例的一小部分数据, 这种模式可以大大减少应用程序获取数据的延迟的同时, 减少数据库端的负载。

此外, 还有许多数据集中项目变化非常不频繁。
例如, 社交网络中的大多数用户帖子要么是不可变的, 要么很少被用户编辑。除此之外, 通常一小部分帖子非常受欢迎, 或者因为一小部分用户有很多关注者和/或因为最近的帖子有更多的可见度, 很明显这就是这种模式可以很有用的原因.

通常, 客户端缓存的两个关键优点是：

1.  数据以非常小的延迟提供。
2.  数据库系统接收的查询较少, 从而允许它使用较少数量的节点为相同的数据集提供服务。

## 计算机科学中有两个难题...

上述模式的一个问题是如何使应用程序持有的信息无效, 以避免向用户呈现陈旧的数据。例如, 在上面的应用程序本地缓存了 user:1234 的信息后, Alice 可能会将她的用户名更新为 Flora。然而, 应用程序可能会继续为 user:1234 提供旧用户名。

有时, 根据我们正在建模的确切应用程序, 这没什么大不了的, 因此客户端将只使用固定的最大 "生存时间" 来缓存信息。一旦过了给定的时间, 该信息将不再被视为有效。更复杂的模式, 在使用 Redis 时, 利用 Pub/Sub 系统向监听客户端发送失效消息。这可以工作, 但从使用的带宽的角度来看是棘手且昂贵的, 因为这种模式通常涉及向应用程序中的每个客户端发送无效消息, 即使某些客户端可能没有任何无效数据的副本.此外, 每个更改数据的应用程序查询都需要使用 PUBLISH 命令, 这会花费数据库更多的 CPU 时间来处理此命令.

无论使用什么模式, 都有一个简单的事实：许多非常大应用程序实现某种形式的客户端缓存, 因为它是下一个逻辑步骤是拥有快速存储或快速缓存服务器。为此 Redis 6 实现对客户端缓存的直接支持的原因, 按顺序使此模式更易于实现, 更易于访问, 更可靠, 而且效率高。

## 客户端缓存的 Redis 实现

Redis 客户端缓存支持称为*跟踪*, 并具有两种模式：

*   在默认模式下, 服务器会记住给定客户端访问的 key, 并在修改相同 key 时发送失效消息。这会消耗服务器端的内存, 但仅针对客户端可能在内存中拥有的一组 key 发送失效消息。
*   在*广播*模式下, 服务器不会尝试记住给定客户端访问了哪些 key, 因此此模式在服务器端根本不消耗内存。相反, 客户端订阅键前缀, 例如`object:`或`user:`, 并在每次触发订阅前缀匹配的 key 时收到通知消息。

回顾一下, 现在让我们暂时忘记广播模式, 以专注于第一种模式。我们稍后将更详细地介绍广播。

1.  客户端可以根据需要启用跟踪。连接启动时未启用跟踪。
2.  启用跟踪后, 服务器将记住每个客户端在连接生存期内请求的 key (通过发送有关此类 key 的读取命令)。
3.  当 key 被某些客户端修改, 或由于具有关联的过期时间而被逐出, 或由于 *_maxmemory_* 策略, 所有启用了跟踪且可能缓存了 key 的客户端, 都会收到一个*失效消息*.
4.  当客户端收到失效消息时, 它们需要删除相应的 key , 以避免提供过时的数据。

这是协议的一个示例：

*   客户端 1`->`服务器：客户端跟踪打开
*   客户端 1`->`服务器： GET foo
*   (服务器记得客户端 1 可能缓存了 key  "foo")
*   (客户端 1 可能记得其本地内存中 "foo" 的值)
*   客户端 2`->`Server： SET foo SomeOtherValue
*   服务器`->`客户端 1：使 "foo" 无效

从表面上看, 这看起来很棒, 但是如果您想象 10k 连接的客户端, 通过长期连接请求数百万个 key , 服务器最终会存储过多信息。出于这个原因, Redis 在以限制服务器端使用的内存量和 CPU 成本处理实现该功能的数据结构：

*   服务器会记住可能已将给定键缓存在单个全局表中的客户端列表。此表称为**失效表**.失效表可以包含最大数量的条目。如果插入了新 key , 服务器可能会通过假装旧 key 已被修改(即使未修改)并向客户端发送失效消息来逐出较旧的条目。这样做, 它可以回收用于此 key 的内存, 即使这会强制具有 key 本地副本的客户端将其逐出。
*   在失效表中, 我们实际上不需要存储指向客户端结构的指针, 这将在客户端断开连接时强制执行垃圾回收过程: 相反, 我们所做的只是存储客户端ID(每个Redis客户端都有一个唯一的数字ID)。如果客户端断开连接, 则当缓存槽失效时, 将以增量方式对信息进行垃圾回收。
*   有一个 key 命名空间, 不除以数据库编号。因此, 如果客户端正在缓存 key `foo`在数据库 2 中, 其他一些客户端更改了键的值`foo`在数据库 3 中, 仍将发送失效消息。通过这种方式, 我们可以忽略数据库编号, 从而降低内存使用量和实现复杂性。

## 双连接模式

使用 Redis 6 支持的新版本 Redis 协议 RESP3, 可以在同一连接中运行数据查询并接收失效消息。但是, 许多客户端实现可能更喜欢使用两个单独的连接实现客户端缓存：一个用于数据, 另一个用于失效消息。因此, 当客户端启用跟踪时, 它可以通过指定其他连接的 "客户端 ID" 来指定将失效消息重定向到另一个连接。许多数据连接可以将失效消息重定向到同一连接, 这对于实现连接池的客户端非常有用。双连接模型是唯一一个也支持 RESP2 的模型(它缺乏在同一连接中多路复用不同类型信息的能力)。

下面是在旧的 RESP2 模式下使用 Redis 协议的完整会话的示例, 涉及以下步骤：启用跟踪重定向到另一个连接、请求 key 以及在 key 修改后获取失效消息。

首先, 客户端打开第一个连接, 该连接将用于失效, 请求连接 ID, 并通过 Pub/Sub 订阅用于在 RESP2 模式下获取失效消息的特殊通道(请记住, RESP2 是常用的 Redis 协议, 而不是您可以使用的更高级协议,  (可选)使用 Redis 6`HELLO`命令)：

    (Connection 1 -- used for invalidations)
    CLIENT ID
    :4
    SUBSCRIBE __redis__:invalidate
    *3
    $9
    subscribe
    $20
    __redis__:invalidate
    :1

现在, 我们可以从数据连接启用跟踪：

    (Connection 2 -- data connection)
    CLIENT TRACKING on REDIRECT 4
    +OK

    GET foo
    $3
    bar

客户端可能决定缓存`"foo" => "bar"`在本地内存中。

另一个客户端现在将修改 "foo" 键的值：

    (Some other unrelated connection)
    SET foo bar
    +OK

因此, 失效连接将收到一条消息, 使指定的 key 失效。

    (Connection 1 -- used for invalidations)
    *3
    $7
    message
    $20
    __redis__:invalidate
    *1
    $3
    foo

客户端将检查此缓存槽中是否有缓存的 key , 并将逐出不再有效的信息。

请注意, 发布/订阅消息的第三个元素不是单个键, 而是是一个只有一个元素的 Redis 数组。由于我们发送一个数组, 如果存在是要失效的键组, 我们可以在一条消息中执行此操作。
如果发生刷新(`FLUSHALL` 或 `FLUSHDB`), 将发送 `null` 消息。

了解客户端缓存的一件非常重要的事情 RESP2 和发布/订阅连接, 以便读取失效消息, 是使用Pub / Sub完全是一个技巧**为了重用旧客户端实现**, 但实际上消息并没有真正发送到通道并由所有订阅它的客户端接收。只有我们才能连接在`REDIRECT`参数`CLIENT`命令实际上会接收发布/订阅消息, 使该功能更具可扩展性。

当使用 RESP3 时, 将发送失效消息(在相同的连接, 或在使用重定向时在辅助连接中)如`push`消息(有关详细信息, 请阅读 RESP3 规范)。

## 跟踪内容

如您所见, 默认情况下, 客户端不需要告诉服务器哪些 key 它们正在缓存。在只读上下文中提到的每个键命令由服务器跟踪, 因为它*可以缓存*.

这有一个明显的优势, 即不需要客户端告诉服务器它正在缓存什么。此外, 在许多客户端实现中, 这就是您想要的, 因为一个好的解决方案可能是使用先进先出的方法缓存尚未缓存的所有内容：我们可能希望缓存固定数量的对象, 每个我们检索到的新数据, 我们可以缓存它, 丢弃最旧的缓存对象。更高级的实现可能会丢弃最少使用的对象或类似对象。

请注意, 无论如何, 如果服务器上有写入流量, 则缓存插槽在此期间将失效。一般来说, 当服务器假设我们得到的也缓存, 我们正在做出权衡：

1.  当客户端倾向于使用欢迎新对象的策略缓存许多内容时, 效率会更高。
2.  服务器将被迫保留有关客户端 key 的更多数据。
3.  客户端将收到有关未缓存对象的无用失效消息。

因此, 下一节中描述了另一种选择。

## 选择加入缓存

客户端实现可能希望仅缓存选定的键, 并进行通信明确地向服务器提供它们将缓存的内容和不缓存的内容。这将缓存新对象时需要更多带宽, 但同时减少服务器必须记住的数据量和客户端收到的失效消息。

为此, 必须使用 OPTIN 选项启用跟踪：

    CLIENT TRACKING on REDIRECT 1234 OPTIN

在这种模式下, 默认情况下, 读取查询中提到的键*不应该被缓存*, 相反, 当客户端想要缓存某些东西时, 它必须在实际命令之前立即发送一个特殊命令来检索数据：

    CLIENT CACHING YES
    +OK
    GET foo
    "bar"

`CACHING` 命令会影响紧随其后执行的命令, 但是如果下一个命令是 `MULTI`, 则将跟踪事务中的所有命令。同样, 在 Lua 脚本的情况下, 脚本执行的所有命令都将被跟踪。

## 广播模式

到目前为止, 我们描述了 Redis 实现的第一个客户端缓存模型。
还有一种叫做广播, 它从不同的权衡的角度来看待问题, 不消耗服务器端的任何内存, 而是向客户端发送更多的失效消息。
在此模式下, 我们有以下主要行为：

*   客户端使用`BCAST`选项, 使用`PREFIX`选择。例如：`CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:`.如果未指定前缀, 则假定前缀为空字符串, 因此客户端将收到每个被修改的键的失效消息。相反, 如果使用一个或多个前缀, 则只会在失效消息中发送与指定前缀之一匹配的键。
*   服务器不会在失效表中存储任何内容。相反, 它使用不同的**前缀表**, 其中每个前缀都与客户端列表相关联。
*   没有两个前缀可以跟踪键空间的重叠部分。例如, 不允许使用前缀 "foo" 和 "foob" , 因为它们都会触发 key  "foobar" 的失效。但是, 只需使用前缀 "foo" 就足够了。
*   每次修改与任何前缀匹配的 key 时, 订阅该前缀的所有客户端都将收到失效消息。
*   服务器消耗的 CPU 将与已注册前缀的数量成比例。如果你只有几个, 很难看出任何区别。使用大量前缀时, CPU 成本可能会变得非常大。
*   在此模式下, 服务器可以执行为订阅给定前缀的所有客户端创建单个回复的优化, 并向所有客户端发送相同的回复。这有助于降低 CPU 使用率。

## NOLOOP 选项

默认情况下, 客户端跟踪将向修改 key 的客户端发送失效消息。有时客户端需要这样做, 因为它们实现了非常基本的逻辑, 不涉及在本地自动缓存写入。但是, 更高级的客户端甚至可能希望缓存他们在本地内存表中所做的写入。在这种情况下, 在写入后立即接收无效消息是一个问题, 因为它会强制客户端驱逐它刚刚缓存的值。

在这种情况下, 可以使用 `NOLOOP` 选项：它可以在正常和广播模式下工作。使用此选项, 客户端可以告诉服务器他们不想接收他们修改的密钥的无效消息。

## 避免竞争条件

实现客户端缓存时, 重定向失效消息到另一个连接, 你应该知道有一个可能的争用条件。请参阅以下示例交互, 我们将在其中调用数据连接 "D" 和失效连接 "I" ：

    [D] client -> server: GET foo
    [I] server -> client: Invalidate foo (somebody else touched it)
    [D] server -> client: "bar" (the reply of "GET foo")

如您所见, 因为对 GET 的回复速度较慢, 无法到达客户端, 我们在收到失效消息之前的实际数据已不再有效。因此, 我们将继续提供过时版本的 foo key。若要避免此问题, 最好填充缓存当我们发送带有占位符的命令时：

    Client cache: set the local copy of "foo" to "caching-in-progress"
    [D] client-> server: GET foo.
    [I] server -> client: Invalidate foo (somebody else touched it)
    Client cache: delete "foo" from the local cache.
    [D] server -> client: "bar" (the reply of "GET foo")
    Client cache: don't set "bar" since the entry for "foo" is missing.

当对数据和失效消息使用单个连接时, 这种竞争条件是不可能的, 因为在这种情况下消息的顺序总是已知的。

## 与服务器断开连接时该怎么办

同样, 如果我们失去了与套接字的连接, 我们用于获取失效消息, 我们可能会以陈旧的数据结束。为了避免这个问题, 我们需要做以下事情：

1.  确保如果连接丢失, 则刷新本地缓存。
2.  将 RESP2 与 Pub/Sub 或 RESP3 一起使用时, 请定期 ping 通失效通道(即使连接处于 Pub/Sub 模式, 您也可以发送 PING 命令！如果连接看起来已断开, 并且我们无法接收 ping 回退, 则在最长时间后, 关闭连接并刷新缓存。

## 要缓存的内容

客户端可能希望运行有关给定缓存键在请求中实际服务的次数的内部统计信息, 以了解将来缓存什么是好的。一般来说：

*   我们不希望缓存许多不断更改的 key 。
*   我们不希望缓存许多很少请求的 key 。
*   我们希望缓存经常被请求的键并以合理的速率更改。举一个 key 没有以合理的速率变化的例子, 想想一个持续 "INCR" 的全局计数器。

然而, 更简单的客户可能只是使用一些随机抽样来逐出数据记住上次提供给定缓存值的时间, 尝试逐出最近没有服务的 key 。

## 实现客户端库的其他提示

*   处理 TTL：如果要支持使用 TTL 的缓存 key , 请确保还请求 key  TTL 并在本地缓存中设置 TTL。
*   在每个 key 上放置最大 TTL 是一个好主意, 即使它没有 TTL。这可以防止错误或连接问题, 这些问题会使客户端在本地副本中具有旧数据。
*   限制客户端使用的内存量是绝对必要的。必须有一种方法可以在添加新 key 时逐出旧 key 。

## 限制 Redis 使用的内存量

请确保为 Redis 记住的最大 key 数配置一个合适的值, 或者使用在 Redis 端完全不消耗内存的 BCAST 模式。请注意, 不使用 BCAST 时 Redis 消耗的内存与跟踪的 key 数和请求此类 key 的客户端数量成正比。
