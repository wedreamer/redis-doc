***

标题： “Redis pipelineing”
链接标题： “流水线”
体重： 1
描述： 如何通过批处理 Redis 命令来优化往返时间
别名：

*   /主题/流水线

***

Redis 流水线是一种通过一次发出多个命令而不等待对每个命令的响应来提高性能的技术。大多数 Redis 客户端都支持流水线。本文档介绍了流水线旨在解决的问题以及流水线在 Redis 中的工作原理。

## 请求/响应协议和往返时间 （RTT）

Redis 是一个 TCP 服务器，使用客户端-服务器模型和所谓的*请求/响应*协议。

这意味着通常通过以下步骤完成请求：

*   客户端向服务器发送查询，并从套接字读取（通常以阻塞方式）以获取服务器响应。
*   服务器处理命令并将响应发送回客户端。

例如，四个命令序列是这样的：

*   *客户：*英克罗 X
*   *服务器：*1
*   *客户：*英克罗 X
*   *服务器：*2
*   *客户：*英克罗 X
*   *服务器：*3
*   *客户：*英克罗 X
*   *服务器：*4

客户端和服务器通过网络链接连接。
这样的链接可以非常快（环回接口），也可以非常慢（通过 Internet 建立的连接，两台主机之间有许多跃点）。
无论网络延迟如何，数据包从客户端传输到服务器，从服务器返回到客户端以携带应答都需要时间。

此时间称为 RTT（往返时间）。
当客户端需要在一行中执行多个请求（例如，向同一列表添加许多元素，或者用许多键填充数据库）时，很容易看出这会如何影响性能。
例如，如果RTT时间为250毫秒（在Internet上链接速度非常慢的情况下），即使服务器每秒能够处理100k个请求，我们也能够以每秒最多四个请求的速度处理。

如果使用的接口是环回接口，则RTT要短得多，通常为亚毫秒级，但如果您需要连续执行多次写入，即使这样也会加起来很多。

幸运的是，有一种方法可以改进此用例。

## Redis Pipelining

可以实现请求/响应服务器，以便它能够处理新请求，即使客户端尚未读取旧响应。
这样就可以发送*多个命令*到服务器，根本不等待回复，最后在一步中阅读回复。

这被称为流水线，是一种广泛使用数十年的技术。
例如，许多POP3协议实现已经支持此功能，大大加快了从服务器下载新电子邮件的过程。

Redis 从早期就支持流水线，因此无论您运行哪个版本，都可以将流水线与 Redis 结合使用。
这是一个使用原始 netcat 实用程序的示例：

```bash
$ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379
+PONG
+PONG
+PONG
```

这一次，我们不为每次调用支付 RTT 的费用，而只需为三个命令支付一次费用。

为了明确起见，通过流水线，我们第一个示例的操作顺序如下：

*   *客户：*英克罗 X
*   *客户：*英克罗 X
*   *客户：*英克罗 X
*   *客户：*英克罗 X
*   *服务器：*1
*   *服务器：*2
*   *服务器：*3
*   *服务器：*4

> **重要提示**：当客户端使用流水线发送命令时，服务器将被迫使用内存对回复进行排队。因此，如果您需要使用流水线发送大量命令，则最好将它们作为批处理发送，每个命令包含合理数量，例如10k命令，读取回复，然后再次发送另外10k命令，依此类推。速度将几乎相同，但使用的额外内存最多是对这些10k命令的回复进行排队所需的数量。

## 这不仅仅是RTT的问题

流水线不仅仅是一种降低与
往返时间，实际上大大提高了操作次数
您可以在给定的 Redis 服务器中每秒执行一次。
这是因为在不使用流水线的情况下，为每个命令提供服务非常便宜。
访问数据结构并生成回复的观点，
但是从做套接字I / O的角度来看，这是非常昂贵的。这
涉及调用`read()`和`write()`系统调用，这意味着从用户
土地到内核土地。
上下文切换是一个巨大的速度损失。

使用流水线时，通常使用单个命令读取许多命令`read()`
系统调用，多个回复通过单个回复传递`write()`系统
叫。因此，每秒执行的总查询数
最初随着更长的管道而几乎线性增加，最终
达到在没有流水线的情况下获得的基线的 10 倍，如下图所示。

![Pipeline size and IOPs](../../images/pipeline_iops.png)

## 真实世界的代码示例

在下面的基准测试中，我们将使用支持流水线的 Redis Ruby 客户端来测试由于流水线而产生的速度改进：

```ruby
require 'rubygems'
require 'redis'

def bench(descr)
  start = Time.now
  yield
  puts "#{descr} #{Time.now - start} seconds"
end

def without_pipelining
  r = Redis.new
  10_000.times do
    r.ping
  end
end

def with_pipelining
  r = Redis.new
  r.pipelined do
    10_000.times do
      r.ping
    end
  end
end

bench('without pipelining') do
  without_pipelining
end
bench('with pipelining') do
  with_pipelining
end
```

运行上述简单脚本在我的Mac OS X系统上生成以下数字，运行在环回接口上，其中流水线将提供最小的改进，因为RTT已经很低：

    without pipelining 1.185238 seconds
    with pipelining 0.250783 seconds

如您所见，使用流水线，我们将传输提高了五倍。

## 流水线与脚本

用[Redis 脚本](/commands/eval)，自 Redis 2.6 起可用，可以使用脚本更有效地解决许多流水线用例，这些脚本在服务器端执行大量工作。
脚本的一大优点是它能够以最小的延迟读取和写入数据，使操作像*读取、计算、写入*非常快（在这种情况水线无法提供帮助，因为客户端需要读取命令的回复才能调用写入命令）。

有时应用程序可能还希望发送`EVAL`或`EVALSHA`管道中的命令。
这是完全可能的，Redis明确支持它[脚本加载](https://redis.io/commands/script-load)命令（它保证`EVALSHA`可以调用而不会有失败的风险）。

## 附录：为什么即使在环回接口上，忙循环也会变慢？

即使此页面中涵盖了所有背景，您可能仍然想知道为什么
像下面这样的Redis基准测试（在伪代码中），即使当
在环回接口中执行，当服务器和客户端正在运行时
在同一台物理机中：

```sh
FOR-ONE-SECOND:
    Redis.SET("foo","bar")
END
```

毕竟，如果 Redis 进程和基准测试都在同一环境中运行
框，它不是只是将内存中的消息从一个地方复制到另一个地方吗？
涉及任何实际的延迟或网络？

原因是系统中的进程并不总是在运行，实际上它是
允许进程运行的内核调度程序。
因此，例如，当允许基准测试运行时，它会从 Redis 服务器读取回复（与执行的最后一个命令相关），并写入一个新命令。
该命令现在位于环回接口缓冲区中，但为了被服务器读取，内核应调度服务器进程（当前在系统调用中被阻止）
运行，依此类推。
因此，实际上环回接口仍然涉及类似网络的延迟，因为内核调度程序的工作方式。

基本上，忙碌的循环基准测试是可以做的最愚蠢的事情，当
网络服务器上的计量性能。明智的做法是避免
以这种方式进行基准测试。
