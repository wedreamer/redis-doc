---
title: "Redis FAQ"
linkTitle: "FAQ"
weight: 100
description: >
    Commonly asked questions when getting started with Redis
aliases:
    - /docs/getting-started/faq
---

## Redis 与其他键值存储有何不同？

*   Redis 在键值数据库中具有不同的演进路径，其中值可以包含更复杂的数据类型，并在这些数据类型上定义原子操作。Redis 数据类型与基本数据结构密切相关，并且以这种方式向程序员公开，而无需额外的抽象层。
*   Redis 是一种内存中但可以持久存在于磁盘上的数据库，因此它代表了一种不同的权衡，即在数据集不能大于内存的限制下实现了非常高的写入和读取速度。内存数据库的另一个优点是，与磁盘上的相同数据结构相比，复杂数据结构的内存表示更易于操作，因此 Redis 可以用很少的内部复杂性做很多事情。同时这两种磁盘存储格式（RDB 和 AOF）不需要适合随机访问，因此它们是紧凑的并且总是以仅附加的方式生成（即使 AOF 日志轮换也是一种附加方式）唯一的操作，因为新版本是从内存中的数据副本生成的）。然而，与传统的磁盘存储相比，这种设计也涉及不同的挑战。作为内存上的主要数据表示，Redis 操作必须小心处理，以确保磁盘上始终存在数据集的更新版本.

## Redis 内存占用量是多少？

举几个例子（全部使用 64 位实例获得）：

*   空实例使用约 3MB 的内存。
*   100 万个小键 -> 字符串值对使用约 85MB 的内存。
*   100 万个键 -> 哈希值，表示具有 5 个字段的对象，使用约 160 MB 的内存。

测试您的用例是微不足道的。使用`redis-benchmark`实用程序生成随机数据集，然后检查与`INFO memory`命令。

64 位系统将使用比 32 位系统更多的内存来存储相同的键，尤其是在键和值很小的情况下。这是因为指针在 64 位系统中占用 8 个字节。但当然优点是您可以在 64 位系统中拥有大量内存，因此为了运行大型 Redis 服务器，或多或少需要 64 位系统。另一种方法是分片。

## 为什么 Redis 将其整个数据集保存在内存中？

过去，Redis 开发人员尝试使用虚拟内存和其他系统，以允许大于 RAM 的数据集，但毕竟，如果我们能做好一件事，我们非常高兴：从内存提供数据，用于存储的磁盘。因此，目前还没有计划为Redis创建磁盘后端。大部分什么毕竟，Redis是其当前设计的直接结果。

如果您真正的问题不是所需的总 RAM，而是您需要将数据集拆分为多个 Redis 实例这一事实，请阅读本文档中的 [分区页面](/topics/partitioning) 以获取更多信息。

赞助 Redis 开发的公司 Redis Ltd. 开发了一种“Redis on Flash”解决方案，该解决方案使用混合 RAM/闪存方法来处理具有偏向访问模式的较大数据集。您可以查看他们的产品以获取更多信息，但是此功能不是开源 Redis 代码库的一部分。

## 是否可以将 Redis 与基于磁盘的数据库一起使用？

是的，一种常见的设计模式涉及在 Redis 中获取写入量非常大的小数据（以及您需要 Redis 数据结构以有效方式对问题建模的数据），以及将大 *blob* 数据放入 SQL 或最终一致的基于磁盘的数据库。同样，有时使用 Redis 是为了在内存中获取存储在磁盘数据库中的相同数据子集的另一个副本。这可能看起来类似于缓存，但实际上是一种更高级的模型，因为通常 Redis 数据集会与磁盘上的数据库数据集一起更新，并且不会在缓存未命中时刷新。

## 如何减少 Redis 的整体内存使用量？

如果可以，请使用 Redis 32 位实例。还要充分利用小散列、列表、排序集和整数集，因为 Redis 能够以更紧凑的方式在少数元素的特殊情况下表示这些数据类型。 [内存优化页面]（/topics/memory-optimization）中有更多信息.

## 如果 Redis 内存不足，会发生什么情况？

Redis 具有内置保护功能，允许用户设置内存使用的最大限制，使用配置文件中的 `maxmemory` 选项来限制 Redis 可以使用的内存。如果达到此限制，Redis 将开始回复错误以写入命令（但会继续接受只读命令）。

您还可以将 Redis 配置为在达到最大内存限制时淘汰 key。有关此内容的更多信息，请参阅 [eviction policy docs](/docs/manual/eviction/)。

## 后台保存失败，在 Linux 上出现 fork() 错误？

简短的回答：`echo 1 > /proc/sys/vm/overcommit_memory`:)

现在详细回答：

Redis 后台保存模式依赖于现代操作系统中 "fork" 系统调用的写时复制语义：Redis forks（创建子进程）是父进程的精确副本。子进程将数据库转储到磁盘上并最终退出。理论上，子进程应该使用与作为副本的父进程一样多的内存，但实际上由于大多数现代操作系统实现的写时复制语义，父进程和子进程将_共享_公共内存页面。仅当页面在子级或父级中发生更改时，才会复制页面。由于理论上所有页面都可能在子进程保存时发生变化，Linux 无法提前知道子进程将占用多少内存，因此如果将 `overcommit_memory` 设置设置为零，除非有那么多，否则 fork 将失败根据需要释放 RAM 以真正复制所有父内存页面。

如果你有一个 3 GB 的 Redis 数据集和只有 2 GB 的可用内存，它将失败.

将 `overcommit_memory` 设置为 1 告诉 Linux 放松并以更乐观的分配方式执行分叉，这确实是你想要的 Redis。

您可以参考 [proc(5)][proc5] 手册页了解可用值的说明。

[proc5]: http://man7.org/linux/man-pages/man5/proc.5.html

## 磁盘上的 Redis 快照是原子快照吗？

是的，当服务器在执行命令之外时，Redis 后台保存进程总是被分叉，因此从磁盘快照的角度来看，每个报告为 RAM 中原子的命令也是原子的。

## Redis 如何使用多个 CPU 或内核？

CPU 成为 Redis 的瓶颈并不常见，因为通常 Redis 是内存或网络绑定的。例如，当使用流水线时，在平均 Linux 系统上运行的 Redis 实例每秒可以传递 100万 个请求，因此，如果您的应用程序主要使用 O(N) 或 O(log(N)) 命令，则几乎不会使用太多的 CPU。

但是，为了最大化 CPU 使用率，您可以在同一个机器中启动多个 Redis 实例并将它们视为不同的服务器。在某些时候，一个机器可能还不够，所以如果你想使用多个 CPU，你可以开始考虑一些更早分片的方法。

您可以在 [分区页面](/topics/partitioning) 中找到有关使用多个 Redis 实例的更多信息.

从 4.0 版开始，Redis 已开始实施线程操作。目前，这仅限于删除后台的对象和阻止通过 Redis 模块实现的命令。对于后续版本，计划是使 Redis 越来越线程化。

## 单个 Redis 实例可以容纳的最大 key 数是多少？哈希集、列表集、集和排序集中的最大元素数是多少？

Redis 最多可以处理 2^32 个 key，并在实践中进行了测试每个实例至少处理 2.5 亿个 key。

每个哈希、列表、集合和排序集都可以包含 2^32 个元素。

换句话说，您的限制可能是系统中的可用内存。

## 为什么我的复制副本的主实例具有不同数量的 key？

如果使用生存时间有限的 key （Redis 过期），这是正常行为。这是发生的事情：

*   主数据库在与副本的第一次同步时生成一个 RDB 文件。
*   RDB 文件将不包括主文件中已过期但仍在内存中的 key 。
*   这些 key 仍在 Redis 主数据库的内存中，即使逻辑上已过期也是如此。它们将被视为不存在，并且稍后将以增量方式或在访问时显式回收其内存。虽然这些键在逻辑上不是数据集的一部分，但它们在`INFO`输出和`DBSIZE`命令。
*   当副本读取主数据库生成的 RDB 文件时，将不会加载这组 key 。

因此，对于具有许多过期 key 的用户来说，在副本中看到较少的 key 是很常见的。但是，从逻辑上讲，主副本和副本将具有相同的内容。

## Redis 这个名字从何而来？
remote dictioncy server
Redis 是一个首字母缩写词，代表 **RE**mote **DI**ctionary **S**erver。

## 为什么Salvatore Sanfilippo 开始了 Redis 项目？

Salvatore 最初创建 Redis 是为了扩展 [LLOOGG](https://github.com/antirez/lloogg)，这是一个实时日志分析工具。但在基本的 Redis 服务器正常工作后，他决定与其他人分享工作，并将 Redis 变成一个开源项目。

## Redis 是如何发音的？

"Redis"（/ˈrɛd-ɪs/）的发音类似于 "红色" 一词加上 "kiss" 一词，但没有 "k"。
