---
title: "RESP protocol spec"
linkTitle: "Protocol spec"
weight: 1
description: Redis serialization protocol (RESP) specification
aliases:
    - /topics/protocol
---

Redis 客户端使用名为**注册教育储蓄计划** (REdis 序列化协议) 与 Redis 服务器进行通信。虽然该协议是专门为Redis设计的, 但它可用于其他客户端 - 服务器软件项目。

RESP是以下几点之间的折衷方案：

*   易于实施。
*   快速解析。
*   人类可读。

RESP 可以序列化不同的数据类型, 如整数、字符串和数组。还有一种特定类型的错误。请求作为字符串数组从客户端发送到 Redis 服务器, 这些字符串数组表示要执行的命令的参数。Redis 使用特定于命令的数据类型进行回复。

RESP 是二进制安全的, 不需要处理从一个进程传输到另一个进程的批量数据, 因为它使用前缀长度来传输批量数据。

注意：此处概述的协议仅用于客户端-服务器通信。Redis 集群使用不同的二进制协议在节点之间交换消息。

## 网络层

客户端通过创建与端口 6379 的 TCP 连接来连接到 Redis 服务器。

虽然RESP在技术上是非TCP特定的, 但在Redis的上下文中, 该协议仅用于TCP连接 (或等效的面向流的连接, 如Unix套接字) 。

## 请求-响应模型

Redis 接受由不同参数组成的命令。
收到命令后, 将对其进行处理并将回复发送回客户端。

这是最简单的模型;但是, 有两种例外情况：

*   Redis 支持流水线 (本文档稍后将介绍) 。因, , 客户端可以一次发送多个命, , 然后等待回复。
*   当 Redis 客户端订阅发布/订阅通道时, 协议会更改语义并成为*推*协议。客户端不再需要发送命令, 因为服务器将在收到新消息后立即自动向客户端发送新消息 (对于客户端订阅的通道) 。

排除这两个例外, Redis 协议是一个简单的请求-响应协议。

## 注册教育、仓储协议说明

RESP协议是在Redis 1.2中引入的, 但它成为
在 Redis 2.0 中与 Redis 服务器通信的标准方式。
这是您应该在 Redis 客户端中实现的协议。

RESP实际上是一种序列化协议, 支持以下内容
数据类型：简单字符串、错误、整数、批量字符串和数组。

Redis 使用 RESP 作为
以下方式：

*   客户端将命令作为批量字符串的 RESP 数组发送到 Redis 服务器。
*   服务器根据命令实现使用其中一种 RESP 类型进行回复。

在 RESP 中, 第一个字节确定数据类型：

*   为**简单字符串**, 则回复的第一个字节为“+”
*   为**错误**, 则回复的第一个字节为“-”
*   为**整数**, 则回复的第一个字节为“：”
*   为**批量字符串**, 则回复的第一个字节为“$”
*   为**阵 列**, 回复的第一个字节是”`*`"

RESP 可以使用稍后指定的批量字符串或数组的特殊变体来表示 Null 值。

在 RESP 中, 协议的不同部分始终以“\r\n” (CRLF)  结尾。

<a name="simple-string-reply"></a>

## RESP Simple Strings

简单字符串的编码方式如下：加号字符, 后跟不能包含 CR 或 LF 字符的字符串 (不允许换行符), , 并以 CRLF 终止 (即“\r\n”) 。

简单字符串用于以最小的开销传输非二进制安全字符串。例如, 许多 Redis 命令在成功时仅回复“OK”。RESP 简单字符串使用以下 5 个字节进行编码：

    "+OK\r\n"

要发送二进制安全字符串, 请改用 RESP 批量字符串。

当 Redis 使用简单字符串进行回复时, 客户端库应使用由“+”后面的第一个字符组成的字符串进行响应
直到字符串的末尾, 不包括最终的 CRLF 字节。

<a name="error-reply"></a>

## 注册教育计划错误

RESP 具有针对错误的特定数据类型。它们类似于
RESP 简单字符串, 但第一个字符是减号“-”字符
的加号。RESP 中的简单字符串和错误之间的真正区别在于客户端处理错误
作为异常, 以及构成
错误类型是错误消息本身。

基本格式为：

    "-Error message\r\n"

仅当出现问题时才会发送错误回复, 例如, 如果
您尝试对错误的数据类型执行操作, 或者如果命令
不存在。客户端在收到错误回复时应引发异常。

以下是错误回复的示例：

    -ERR unknown command 'helloworld'
    -WRONGTYPE Operation against a key holding the wrong kind of value

“-”后面的第一个单词, 直到第一个空格或换行符, 表示
返回的错误类型。这只是 Redis 使用的约定, 不是
RESP 错误格式的一部分。

例如`ERR`是一般错误, 而`WRONGTYPE`是一个更具体的
错误, 该错误暗示客户端尝试对
数据类型错误。这称为**错误前缀**并且是一种允许的方式
客户端了解服务器返回的错误类型, 而不检查确切的错误消息。

客户端实现可能会为不同的异常返回不同类型的异常
错误或提供一种通用方法来捕获错误, 方法是直接提供
以字符串形式提供给调用方的错误名称。

但是, 这样的功能不应被视为至关重要, 因为它很少有用, 并且有限的客户端实现可能只是返回一般错误条件, 例如`false`.

<a name="integer-reply"></a>

## RESP Integers

此类型只是一个以 CRLF 终止的字符串, 表示一个整数, 
以 “：” 字节为前缀。例如, “：0\r\n”和“：1000\r\n”是整数答复。

许多 Redis 命令返回 RESP 整数, 例如`INCR`,`LLEN`和`LASTSAVE`.

返回的整数没有特殊含义。它只是一个
的增量数`INCR`, UNIX 时间`LASTSAVE`, 依此类推。然而
返回的整数保证在有符号 64 位整数的范围内。

整数回复也用于返回 true 或 false。
例如, 像这样的命令`EXISTS`或`SISMEMBER`将返回 1 为真
和 0 表示假。

其他命令, 如`SADD`,`SREM`和`SETNX`如果操作
实际执行, 否则为 0。

以下命令将使用整数进行回复：`SETNX`,`DEL`,
`EXISTS`,`INCR`,`INCRBY`,`DECR`,`DECRBY`,`DBSIZE`,`LASTSAVE`,
`RENAMENX`,`MOVE`,`LLEN`,`SADD`,`SREM`,`SISMEMBER`,`SCARD`.

<a name="nil-reply"></a> <a name="bulk-string-reply"></a>

## RESP 批量字符串

使用批量字符串是为了表示单个二进制安全
字符串长度不超过 512 MB。

批量字符串按以下方式编码：

*   一个“$”字节, 后跟组成字符串的字节数 (前缀长度), , 由 CRLF 终止。
*   实际的字符串数据。
*   最后的CRLF。

因此, 字符串“hello”的编码如下：

    "$5\r\nhello\r\n"

空字符串编码为：

    "$0\r\n\r\n"

RESP 批量字符串也可用于表示值不存在
使用特殊格式来表示 Null 值。在此
格式, 长度为 -1, 并且没有数据。空值表示为：

    "$-1\r\n"

这称为**空批量字符串**.

客户端库 API 不应返回空字符串, 而应返回 nil 对象, 
当服务器使用空批量字符串进行回复时。
例如, Ruby 库应返回“nil”, 而 C 库应返回“nil”
返回 NULL (或在回复对象中设置特殊标志) 。

<a name="array-reply"></a>

## 注册资产方案阵列

客户端使用 RESP 阵列向 Redis 服务器发送命令。同样地
某些 Redis 命令, 这些命令将元素集合返回给客户端, 
使用 RESP 数组作为其回复。一个例子是`LRANGE`命令
返回列表的元素。

RESP 数组使用以下格式发送：

*   一个`*`字符作为第一个字节, 后跟数组中作为十进制数的元素数, 后跟 CRLF。
*   数组中每个元素的附加 RESP 类型。

因此, 空数组只是以下内容：

    "*0\r\n"

而两个 RESP 批量字符串“hello”和“world”的数组编码为：

    "*2\r\n$5\r\nhello\r\n$5\r\nworld\r\n"

正如你所看到的`*<count>CRLF`部分作为数组前缀, 另一个
组成数组的数据类型只是一个接一个地连接。
例如, 包含三个整数的数组的编码如下所示：

    "*3\r\n:1\r\n:2\r\n:3\r\n"

数组可以包含混合类型, 因此对于
元素的类型相同。例如, 包含四个的列表
整数和批量字符串可以按如下方式进行编码：

    *5\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    :4\r\n
    $5\r\n
    hello\r\n

 (为清楚起见, 答复被分成多行) 。

服务器发送的第一行是`*5\r\n`为了指定五
回复将紧随其后。然后, 每个回复构成的项目
传输多批量回复。

空数组也存在, 并且是替代方法
指定 Null 值 (通常使用 Null 批量字符串, 但用于历史
原因我们有两种格式) 。

例如, 当`BLPOP`命令超时, 它将返回一个空数组
计数`-1`如以下示例所示：

    "*-1\r\n"

客户端库 API 在以下情况下应返回空对象, 而不是空数组：
Redis 使用空数组进行回复。这是区分的必要条件
在空列表和不同条件之间 (例如超时
条件`BLPOP`命令) 。

嵌套数组在 RESP 中是可能的。例如, 两个数组的嵌套数组
编码如下：

    *2\r\n
    *3\r\n
    :1\r\n
    :2\r\n
    :3\r\n
    *2\r\n
    +Hello\r\n
    -World\r\n

 (该格式被分成多行, 使其更易于阅读) 。

上述 RESP 数据类型对一个双元素数组进行编码, 该数组由一个包含三个整数  (1、2、3)  的数组以及一个由简单字符串和一个错误组成的数组组成。

## 数组中的空元素

数组的单个元素可能为 Null。这在 Redis 回复中使用, 以指示这些元素丢失而不是空字符串。这
当与 GET 一起使用时, SORT 命令可能会发生*模式*选择
如果缺少指定的键。包含
空元素：

    *3\r\n
    $5\r\n
    hello\r\n
    $-1\r\n
    $5\r\n
    world\r\n

第二个元素是 Null。客户端库应返回一些内容
喜欢这个：

    ["hello",nil,"world"]

请注意, 这与前几节中所说的内容不同, 但是
进一步指定协议的示例。

## 将命令发送到 Redis 服务器

现在您已经熟悉了 RESP 序列化格式, 可以使用它来帮助编写 Redis 客户端库。我们可以进一步指定
客户端和服务器之间的交互如何工作：

*   客户端向 Redis 服务器发送仅包含批量字符串的 RESP 数组。
*   Redis 服务器回复客户端, 发送任何有效的 RESP 数据类型作为回复。

例如, 典型的交互可以是以下内容。

客户端发送命令**LLEN mylist**为了获得存储在键上的列表的长度*我的列表*.然后, 服务器使用整数回复进行回复, 如以下示例所示 (C：是客户端, S：是服务器) 。

    C: *2\r\n
    C: $4\r\n
    C: LLEN\r\n
    C: $6\r\n
    C: mylist\r\n

    S: :48293\r\n

像往常一样, 为了简单起见, 我们用换行符分隔协议的不同部分, 但实际的交互是客户端发送`*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n`作为一个整体。

## 多个命令和流水线

客户端可以使用相同的连接来发出多个命令。
支持流水线, 因此可以使用单个命令发送多个命令
由客户端写入操作, 无需读取服务器回复
在发出下一个命令之前, 上一个命令。
所有回复都可以在最后阅读。

有关详细信息, 请参阅[流水线](/topics/pipelining).

## 内联命令

有时您可能需要发送命令
到 Redis 服务器, 但只有`telnet`可用。虽然Redis协议易于实现, 但它是
不适合在交互式会话中使用, 并且`redis-cli`可能并不总是
可用。因此, Redis 还接受**内联命令**格式。

以下是使用内联命令的服务器/客户端聊天的示例
 (服务器聊天以 S：开头, 客户端聊天以 C：开头) 

    C: PING
    S: +PONG

以下是返回整数的内联命令的示例：

    C: EXISTS somekey
    S: :0

基本上, 您在 telnet 会话中编写空格分隔的参数。
由于没有命令以`*`改为在统一请求中使用
协议, Redis能够检测到这种情况并解析您的命令。

## 用于 Redis 协议的高性能解析器

虽然Redis协议是人类可读且易于实施的, 但它可以
以类似于二进制协议的性能实现。

RESP 使用前缀长度来传输批量数据, 因此存在
永远不需要像JSON那样扫描有效负载中的特殊字符, 也不需要引用需要发送到的有效负载
服务器。

批量和多批量长度可以使用执行
每个字符一个操作, 同时扫描
CR 字符, 类似于以下 C 代码：

    #include <stdio.h>

    int main(void) {
        unsigned char *p = "$123\r\n";
        int len = 0;

        p++;
        while(*p != '\r') {
            len = (len*10)+(*p - '0');
            p++;
        }

        /* Now p points at '\r', and the len is in bulk_len. */
        printf("%d\n", len);
        return 0;
    }

识别出第一个 CR 后, 可以将其与以下内容一起跳过
LF 无需任何处理。然后可以使用单个数据读取批量数据
不以任何方式检查有效负载的读取操作。最后
剩余的 CR 和 LF 字符将被丢弃, 无需任何处理。

虽然在性能上与二进制协议相当, 但 Redis 协议
在大多数高级语言中实现起来要简单得多, 
减少客户端软件中的错误数量。
