---
title: "Redis client handling"
linkTitle: "Client handling"
weight: 1
description: >
    How the Redis server manages client connections
aliases:
    - /topics/clients
---

本文档提供有关 Redis 如何在网络层级别处理客户端的信息：此处介绍了连接、超时、缓冲区和其他类似主题。

本文档中包含的信息是**仅适用于 Redis 版本 2.6 或更高版本**.

## 接受客户端连接

Redis 接受已配置的 TCP 端口和 Unix 套接字 (如果启用) 上的客户端连接。接受新的客户端连接时, 将执行以下操作：

*   客户端套接字处于非阻塞状态, 因为 Redis 使用多路复用和非阻塞 I/O。
*   这`TCP_NODELAY`设置选项是为了确保连接没有延迟。
*   一个*读*创建 file 事件, 以便 Redis 能够在套接字上有新数据可供读取时立即收集客户端查询。

客户端初始化后, Redis 会检查它是否已经达到限制
针对并发客户端数进行配置 (使用`maxclients`配置指令, 有关详细信息, 请参阅本文档的下一节) 。

当 Redis 由于最大客户端数而无法接受新的客户端连接时
已到达, 它尝试向客户端发送错误, 以便
使其知道此情况, 立即关闭连接。
错误消息将到达客户端, 即使连接是
Redis 立即关闭, 因为新的套接字输出缓冲区通常是
大到足以包含错误, 因此内核将处理传输
的错误。

## 客户请求的送达顺序是什么？

顺序由客户端套接字文件描述符的组合确定
内核报告事件的数量和顺序, 因此顺序应为
被视为未指定。

但是, Redis 在为客户端提供服务时会执行以下两项操作：

*   它只执行单个`read()`每次有新内容要从客户端套接字读取时, 系统调用。这可确保如果我们连接了多个客户端, 并且少数客户端以高速率发送查询, 则其他客户端不会受到惩罚, 也不会遇到延迟问题。
*   但是, 从客户端读取新数据后, 将按顺序处理当前缓冲区中包含的所有查询。这提高了局部性, 并且不需要再次迭代以查看是否存在需要一些处理时间的客户端。

## 最大并发连接客户端数

在 Redis 2.4 中, 对最大客户端数量有一个硬编码限制
可以同时处理。

在 Redis 2.6 及更高版本中, 此限制是动态的：默认情况下, 此限制设置为 10000 个客户端, 除非
另有说明`maxclients`指令`redis.conf`.

但是, Redis 会与内核一起检查文件的最大数量是多少
我们能够打开的描述符是 (*软限制*已选中) 。如果
限制小于我们要处理的最大客户端数, 加上
32 (即 Redis 为内部使用保留的文件描述符的数量), , 
然后更新最大客户端数以匹配该数量
的客户端它是*真正能够处理*在当前操作系统下
限制。

什么时候`maxclients`设置为大于 Redis 可以支持的数字, 则在启动时会记录一条消息：

    $ ./redis-server --maxclients 100000
    [41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.

当为了处理特定数量的客户端而配置 Redis 时
是一个好主意, 以确保操作系统限制为最大值
每个进程的文件描述符数也相应地设置。

在 Linux 下, 这些限制既可以在当前会话中设置, 也可以设置为
使用以下命令进行系统范围的设置：

*   `ulimit -Sn 100000 # This will only work if hard limit is big enough.`
*   `sysctl -w fs.file-max=100000`

## 输出缓冲器限制

Redis 需要为每个客户端处理一个可变长度的输出缓冲区, 因为
一个命令可以产生大量需要传输到
客户。

但是, 客户端可能会发送更多命令, 从而产生更多输出
以比 Redis 可以将现有输出发送到
客户。对于发布/订阅客户端尤其如此, 以防客户端不是
能够足够快地处理新消息。

这两种情况都会导致客户端输出缓冲区增长并消耗
越来越多的内存。因此, 默认情况下, Redis 将限制设置为
不同类型客户端的输出缓冲区大小。达到限制时
客户端连接已关闭, 事件记录在 Redis 日志文件中。

Redis 有两种限制：

*   这**硬限制**是一个固定的限制, 当达到该限制时, Redis 将尽快关闭客户端连接。
*   这**软限制**相反, 这是一个取决于时间的限制, 例如, 每10秒32兆字节的软限制意味着如果客户端的输出缓冲区连续10秒大于32兆字节, 则连接将关闭。

不同类型的客户端具有不同的默认限制：

*   **普通客户端**默认限制为 0, 这意味着根本没有限制, 因为大多数普通客户端使用阻止实现发送单个命令并等待回复完全读取, 然后再发送下一个命令, 因此在正常客户端的情况下, 总是不希望关闭连接。
*   **发布/订阅客户端**默认硬限制为 32 MB, 软限制为每 60 秒 8 MB。
*   **副本**默认硬限制为 256 MB, 软限制为每 60 秒 64 MB。

可以在运行时使用`CONFIG SET`命令或永久使用 Redis 配置文件`redis.conf`.查看示例`redis.conf`中有关如何设置限制的详细信息。

## 查询缓冲区硬限制

每个客户端还受到查询缓冲区限制的约束。这是一个不可配置的硬限制, 当客户端查询缓冲区 (即我们用于从客户端累积命令的缓冲区) 达到 1 GB 时将关闭连, , 实际上只是一个极端限, , 以避免在客户端或服务器软件错误的情况下服务器崩溃。

## 客户逐出

Redis 是为处理大量客户端连接而构建的。
客户端连接往往会消耗内存, 当存在许多内存时, 聚合内存消耗可能非常高, 从而导致数据逐出或内存不足错误。
这些情况可以在一定程度上减轻, 使用[输出缓冲区限制](#output-buffers-limits), 但 Redis 允许我们使用更强大的配置来限制所有客户端连接使用的聚合内存。

此机制称为**客户驱逐**, 它本质上是一种安全机制, 一旦所有客户端的聚合内存使用率超过阈值, 它将断开客户端。
该机制首先尝试断开使用最多内存的客户端。
它断开了返回所需的最小数量的客户端, 低于`maxmemory-clients`门槛。

`maxmemory-clients`定义连接到 Redis 的所有客户端的最大聚合内存使用量。
聚合考虑了客户端连接使用的所有内存：[查询缓冲区](#query-buffer-hard-limit)、输出缓冲区和其他中间缓冲区。

请注意, 副本和主连接不受客户端逐出机制的影响。因此, 这种连接永远不会被驱逐。

`maxmemory-clients`可以在配置文件 (`redis.conf`)  或通过`CONFIG SET`命令。
此设置可以是 0 (表示无限制), , 也可以是以字节为单位的大小 (可能带有`mb`/`gb`后缀,  , 
或百分比`maxmemory`通过使用`%`后缀 (例如, 将其设置为`10%`将表示 10% 的`maxmemory`配置) 。

默认设置为 0, 表示默认情况下客户端逐出处于关闭状态。
但是, 对于任何大型生产部署, 强烈建议配置一些非零部署`maxmemory-clients`价值。
一个值`5%`, 例如, 可以是一个很好的起点。

可以标记要从客户端逐出机制中排除的特定客户端连接。
这对于控制路径连接非常有用。
例如, 如果您有一个应用程序, 该应用程序通过`INFO`命令, 并在出现问题时提醒您, 您可能希望确保此连接未被逐出。
您可以使用以下命令 (从相关客户端的连接) 执行此操作：

`CLIENT NO-EVICT` `on`

你可以通过以下方式恢复它：

`CLIENT NO-EVICT` `off`

有关详细信息和示例, 请参阅`maxmemory-clients`部分`redis.conf`文件。

客户端逐出功能可从 Redis 7.0 获得。

## 客户端超时

默认情况下, 最新版本的 Redis 不会关闭与客户端的连接
如果客户端空闲了几秒钟：连接将永远保持打开状态。

但是, 如果您不喜欢此行为, 则可以配置超时, 以便
如果客户端空闲的时间超过指定的秒数, 则客户端连接将关闭。

您可以通过以下方式配置此限制：`redis.conf`或干脆使用`CONFIG SET timeout <value>`.

请注意, 超时仅适用于普通客户端, 并且**不适用于发布/订阅客户端**, 因为发布/订阅连接是*推式*连接, 因此空闲的客户端是常态。

即使默认情况下连接不受超时的影响, 在设置超时时有意义时, 也有两个条件：

*   任务关键型应用程序, 其中客户端软件中的错误可能会使 Redis 服务器因空闲连接而饱和, 从而导致服务中断。
*   作为一种调试机制, 以便在客户端软件中的错误使服务器与空闲连接饱和时能够与服务器连接, 从而无法与服务器交互。

超时不应被视为非常精确：Redis 避免设置计时器事件或运行 O (N)  算法以检查空闲客户, , 因此检查不时以增量方式执行。这意味, , 当超时设置为 10 秒, , 客户端连接可能会关, , 例, , 如果同时连接多个客户, , 则在 12 秒后。

## 客户端命令

雷迪斯酒店`CLIENT`命令允许您检查每个已连接客户端的状态、终止特定客户端以及命名连接。如果您大规模使用Redis, 它是一个非常强大的调试工具。

`CLIENT LIST`用于获取已连接客户端及其状态的列表：

    redis 127.0.0.1:6379> client list
    addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
    addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping

在上面的示例中, 两个客户端连接到 Redis 服务器。让我们看一下返回的一些数据代表什么：

*   **地址**：客户端地址, 即客户端 IP 及其用于与 Redis 服务器连接的远程端口号。
*   **断续器**：客户端套接字文件描述符编号。
*   **名字**：由 设置的客户端名称`CLIENT SETNAME`.
*   **年龄**：连接存在的秒数。
*   **怠**：连接处于空闲状态的秒数。
*   **标志**：客户端的类型 (N 表示普通客户端, 请检查[标志的完整列表](https://redis.io/commands/client-list)).
*   **omem**：客户端用于输出缓冲区的内存量。
*   **断续器**：上次执行的命令。

查看[`CLIENT LIST`](https://redis.io/commands/client-list)字段完整列表及其用途的文档。

获得客户端列表后, 可以使用`CLIENT KILL`命令, 指定客户端地址作为其参数。

命令`CLIENT SETNAME`和`CLIENT GETNAME`可用于设置和获取连接名称。从 Redis 4.0 开始, 客户端名称显示在
`SLOWLOG`输出, 以帮助识别造成延迟问题的客户端。

## TCP 保持警惕

从 3.2 版本开始, Redis 具有 TCP 保持警惕  (`SO_KEEPALIVE`套接字选项) 默认启, , 并设置为约 300 秒。此选项对于检测失效的对等体 (即使它们看起来已连接也无法到达的客户端) 非常有用。, 外, 如果客户端和服务器之间存在需要查看某些流量才能打开连接的网络, 备, 则该选项将防止意外的连接关闭事件。
