
**注意：本文档由Redis的创建者Salvatore Sanfilippo撰写，在Redis开发的早期（约2010年）。自 Redis 2.6 以来，虚拟内存已被弃用，因此本文档
这里只是为了历史兴趣。**

本文档详细介绍了 Redis 2.6 之前的 Redis 虚拟内存子系统的内部结构。目标受众不是最终用户，而是愿意理解或修改虚拟内存实现的程序员。

## 键与值：交换了什么？

VM 子系统的目标是释放内存，将 Redis 对象从内存传输到磁盘。这是一个非常通用的命令，但具体来说，Redis仅传输与*值*.为了更好地理解这个概念，我们将使用 DEBUG 命令展示从 Redis 内部的角度来看，保存值的键的外观：

    redis> set foo bar
    OK
    redis> debug object foo
    Key at:0x100101d00 refcount:1, value at:0x100101ce0 refcount:1 encoding:raw serializedlength:4

从上面的输出中可以看出，Redis 顶级哈希表将 Redis 对象（键）映射到其他 Redis 对象（值）。虚拟内存只能交换*值*上，与 关联的对象*钥匙*始终采用内存：这种权衡保证了非常好的查找性能，因为 Redis VM 的主要设计目标之一是在数据集中经常使用的部分适合 RAM 时，在禁用 VM 的情况下实现类似于 Redis 的性能。

## 交换值在内部的外观如何

当一个对象被换出时，这是在哈希表条目中发生的情况：

*   密钥继续包含表示密钥的 Redis 对象。
*   该值设置为 NULL

因此，您可能想知道我们在哪里存储了交换出给定值（与给定键关联）的信息。就在关键对象中！

这就是 Redis 对象结构*罗布吉*看来：

    /* The actual Redis Object */
    typedef struct redisObject {
        void *ptr;
        unsigned char type;
        unsigned char encoding;
        unsigned char storage;  /* If this object is a key, where is the value?
                                 * REDIS_VM_MEMORY, REDIS_VM_SWAPPED, ... */
        unsigned char vtype; /* If this object is a key, and value is swapped out,
                              * this is the type of the swapped out object. */
        int refcount;
        /* VM fields, this are only allocated if VM is active, otherwise the
         * object allocation function will just allocate
         * sizeof(redisObject) minus sizeof(redisObjectVM), so using
         * Redis without VM active will not have any overhead. */
        struct redisObjectVM vm;
    } robj;

如您所见，有几个关于 VM 的字段。最重要的一个是*存储*，可以是以下值之一：

*   `REDIS_VM_MEMORY`：关联的值在内存中。
*   `REDIS_VM_SWAPPED`：交换关联的值，并且哈希表的值条目仅设置为 NULL。
*   `REDIS_VM_LOADING`：值在磁盘上交换，条目为 NULL，但有一个作业将对象从交换加载到内存（此字段仅在线程 VM 处于活动状态时使用）。
*   `REDIS_VM_SWAPPING`：值在内存中，条目是指向实际 Redis 对象的指针，但有一个 I/O 作业，以便将此值传输到交换文件。

如果在磁盘上交换了对象 （`REDIS_VM_SWAPPED`或`REDIS_VM_LOADING`），我们如何知道它的存储位置，它是什么类型，等等？这很简单：*vtype*字段设置为交换的 Redis 对象的原始类型，而*虚拟机*字段（即*redisObjectVM*结构）保存有关对象位置的信息。这是此附加结构的定义：

    /* The VM object structure */
    struct redisObjectVM {
        off_t page;         /* the page at which the object is stored on disk */
        off_t usedpages;    /* number of pages used on disk */
        time_t atime;       /* Last access time */
    } vm;

如您所见，该结构包含交换文件中对象所在的页面、使用的页数以及对象的上次访问时间（这对于选择哪个对象是交换的良好候选对象的算法非常有用，因为我们希望在很少访问的磁盘对象上传输）。

如您所见，虽然所有其他字段都在旧的 Redis 对象结构中使用未使用的字节（由于自然内存对齐问题，我们有一些空闲位），*虚拟机*字段是新的，并且确实使用额外的内存。即使禁用了 VM，我们是否应该支付这样的内存成本？不！这是创建新的 Redis 对象的代码：

    ... some code ...
            if (server.vm_enabled) {
                pthread_mutex_unlock(&server.obj_freelist_mutex);
                o = zmalloc(sizeof(*o));
            } else {
                o = zmalloc(sizeof(*o)-sizeof(struct redisObjectVM));
            }
    ... some code ...

如您所见，如果 VM 系统未启用，我们只分配`sizeof(*o)-sizeof(struct redisObjectVM)`的内存。鉴于*虚拟机*字段是对象结构中的最后一个字段，如果禁用 VM，则永远不会访问此字段，我们是安全的，没有 VM 的 Redis 不会支付内存开销。

## 交换文件

为了了解 VM 子系统的工作原理，下一步是了解对象在交换文件中的存储方式。好消息是，这不是某种特殊格式，我们只是使用用于将对象存储在.rdb文件中的相同格式，这些格式是Redis使用的常用转储文件`SAVE`命令。

交换文件由给定数量的页组成，其中每个页面大小都是给定的字节数。此参数可以在 redis.conf 中更改，因为不同的 Redis 实例可能更适合使用不同的值：这取决于您存储在其中的实际数据。以下是默认值：

    vm-page-size 32
    vm-pages 134217728

Redis在内存中采用“位图”（设置为零或1的连续位数组），每个位代表磁盘上交换文件的一页：如果给定位设置为1，则表示已使用的页面（其中存储了一些Redis对象），而如果相应的位为零， 该页面是免费的。

在内存中采用这个位图（将调用页表）在性能方面是一个巨大的胜利，并且使用的内存很小：我们只需要磁盘上每个页面的1位。例如，在下面的示例中，134217728每个 32 字节的页面（4GB 交换文件）仅将 16 MB 的 RAM 用于页表。

## 将对象从内存传输到交换

为了将对象从内存传输到磁盘，我们需要执行以下步骤（假设非线程VM，只是一个简单的阻塞方法）：

*   查找需要多少页才能将此对象存储在交换文件上。这很简单，只需调用函数即可完成`rdbSavedObjectPages`返回磁盘上某个对象使用的页数。请注意，此函数不会复制 .rdb 保存代码，只是为了了解长度*后*一个对象将保存在磁盘上，我们使用打开/dev/null并将对象写入其中的技巧，最后调用`ftello`为了检查所需的字节数。我们基本上要做的是将对象保存在一个虚拟的非常快的文件上，即 /dev/null。
*   现在我们知道交换文件中需要多少页，我们需要在交换文件中找到这个数量的连续可用页。此任务由`vmFindContiguousPages`功能。正如您可以猜到的那样，如果交换已满，或者非常分散，以至于我们无法轻松找到所需数量的连续可用页面，则此功能可能会失败。当这种情况发生时，我们只是中止对象的交换，这将继续存在于内存中。
*   最后，我们可以将对象写入磁盘上的指定位置，只需调用函数即可`vmWriteObjectOnSwap`.

您可以猜到，一旦对象正确写入交换文件，它就会从内存中释放出来，关联键中的存储字段设置为`REDIS_VM_SWAPPED`，并且使用的页面将被标记为在页面表中使用。

## 将对象装回内存中

将对象从交换加载到内存更简单，因为我们已经知道对象的位置以及它正在使用多少页。我们也知道对象的类型（加载函数需要知道此信息，因为磁盘上没有标头或有关对象类型的任何其他信息），但这存储在*vtype*字段，如上所示。

调用函数`vmLoadObject`传递与我们要加载的值对象关联的键对象就足够了。该函数还将负责修复密钥的存储类型（这将是`REDIS_VM_MEMORY`），将页面标记为在页面表中释放，依此类推。

该函数的返回值是加载的 Redis Object 本身，我们必须在主哈希表中将其再次设置为 value（而不是我们在最初交换值时放置的对象指针的 NULL 值）。

## 阻止 VM 的工作原理

现在，我们有了所有构建块，以便描述阻塞 VM 的工作原理。首先，关于配置的重要细节。为了在 Redis 中启用阻止 VM`server.vm_max_threads`必须设置为零。
我们稍后将了解如何在线程化 VM 中使用此最大线程数信息，现在只需要 Redis 在将其设置为零时恢复到完全阻止 VM。

我们还需要引入另一个重要的 VM 参数，即：`server.vm_max_memory`.此参数非常重要，因为它用于触发交换：Redis 仅在使用比最大内存设置更多的内存时才会尝试交换对象，否则无需交换，因为我们匹配用户请求的内存使用情况。

## 阻止虚拟机交换

在 cron 函数中，对象从内存交换到磁盘时会发生。这个函数过去每秒调用一次，而在 git 上最近的 Redis 版本中，它每 100 毫秒调用一次（即每秒 10 次）。
如果此函数检测到内存不足，即使用的内存大于 vm-max-memory 设置，它将开始在调用该函数的循环中将对象从内存传输到磁盘`vmSwapOneObect`.此函数仅采用一个参数，如果为 0，它将以阻塞方式交换对象，否则如果为 1，则使用 I/O 线程。在阻塞场景中，我们只用零作为参数来调用它。

vmSwapOneObject 执行以下步骤：

*   检查中的键空间，以便找到一个好的交换候选者（我们稍后将看到什么是交换的好候选项）。
*   关联的值以阻塞方式传输到磁盘。
*   密钥存储字段设置为`REDIS_VM_SWAPPED`，而*虚拟机*对象的字段设置为正确的值（交换对象的页面索引，以及用于交换对象的页面数）。
*   最后，释放值对象，并将哈希表的值条目设置为 NULL。

该函数被一次又一次地调用，直到发生以下情况之一：无法交换更多对象，因为交换文件已满或几乎所有对象都已在磁盘上传输，或者只是内存使用情况已在 vm-max-memory 参数下。

## 当我们内存不足时要交换哪些值？

了解什么是交换的好候选者并不难。随机抽取几个对象，并为每个对象*可换用性*换算为：

    swappability = age*log(size_in_memory)

期限是未请求密钥的秒数，而size_in_memory是对内存中对象使用的内存量（以字节为单位）的快速估计。因此，我们尝试交换很少访问的对象，并尝试将较大的对象与较小的对象交换，但后者是一个不太重要的因素（因为使用了对数函数）。这是因为我们不希望将较大的对象换出，并且由于对象越大，传输对象所需的I / O和CPU就越多。

## 阻止 VM 加载

如果请求对与已换出对象关联的键执行操作，会发生什么情况？例如，Redis可能碰巧处理以下命令：

    GET foo

如果`foo`键被交换，我们需要在处理操作之前将其加载回内存中。在 Redis 中，密钥查找过程集中在`lookupKeyRead`和`lookupKeyWrite`函数，这两个函数用于实现所有访问密钥空间的 Redis 命令，因此我们在代码中有一个点来处理从交换文件到内存的密钥加载。

所以这就是发生的事情：

*   用户调用一些命令，参数是交换的键
*   命令实现调用查找函数
*   查找函数在顶级哈希表中搜索键。如果与请求的键关联的值被交换（我们可以看到，检查*存储*字段），我们将其以阻塞方式加载回内存中，然后再返回给用户。

这很简单，但事情会变得更好*有趣*与线程。从阻塞 VM 的角度来看，唯一真正的问题是使用另一个进程保存数据集，即处理`BGSAVE`和`BGREWRITEAOF`命令。

## VM 处于活动状态时的后台保存

在磁盘上保留的默认 Redis 方法是使用子进程创建 .rdb 文件。Redis调用fork（）系统调用以创建一个子进程，该子进程具有内存中数据集的精确副本，因为fork复制了整个程序内存空间（实际上，由于一种称为“写入时复制”的技术，内存页在父进程和子进程之间共享，因此fork（）调用不需要太多内存）。

在子进程中，我们在给定的时间点有数据集的副本。客户端发出的其他命令将仅由父进程提供，不会修改子数据。

子进程将仅将整个数据集存储到 dump.rdb 文件中，最后将退出。但是，当 VM 处于活动状态时会发生什么情况呢？值可以换出，这样我们就不会在内存中拥有所有数据，我们需要访问交换文件才能检索交换的值。当子进程保存时，交换文件在父进程和子进程之间共享，因为：

*   父进程需要访问交换文件，以便在对交换出的值执行操作时将值加载回内存。
*   子进程需要访问交换文件，以便在将数据集保存在磁盘上时检索完整的数据集。

为了避免在两个进程访问同一交换文件时出现问题，我们做了一件简单的事情，即在后台保存过程中不允许在父进程中交换值。这样，两个进程都将以只读方式访问交换文件。这种方法存在一个问题，即当子进程正在保存时，即使 Redis 使用的内存多于最大内存参数指示的内存，也无法在交换文件上传输新值。这通常不是问题，因为后台保存将在短时间内终止，如果仍然需要，将尽快在磁盘上交换一定比例的值。

此方案的替代方法是启用仅追加文件，仅当使用`BGREWRITEAOF`命令。

## 阻塞 VM 的问题

阻止 VM 的问题是...它阻止了:)
当Redis用于批处理活动时，这不是问题，但对于实时使用，Redis的一个优点是低延迟。阻塞 VM 将具有不良的延迟行为，因为当客户端访问已换出的值时，或者当 Redis 需要换出值时，在此期间不会为其他客户端提供服务。

交换键应该在后台进行。同样，当客户端访问已换出的值时，访问内存值的其他客户端应主要与禁用 VM 时一样快。只有处理交换密钥的客户端才应延迟。

所有这些限制都需要非阻塞 VM 实现。

## 线程化虚拟机

基本上有三种主要方法可以将阻塞 VM 转换为非阻塞 VM。

*   1：一种方法是显而易见的，在我看来，根本不是一个好主意，那就是将Redis本身变成一个线程服务器：如果每个请求都自动由不同的线程提供服务，则其他客户端不需要等待被阻止的客户端。Redis速度快，导出原子操作，没有锁，只有10k行代码，*因为*它是单线程的，所以这对我来说不是一个选择。
*   2：对交换文件使用非阻塞 I/O。毕竟，您可以认为Redis已经基于事件循环，为什么不以非阻塞的方式处理磁盘I / O呢？我也放弃了这种可能性，主要有两个原因。一个是非阻塞文件操作与套接字不同，是不兼容的噩梦。这不仅仅是调用 select，你需要使用特定于操作系统的东西。另一个问题是，I / O只是处理VM所花费时间的一部分，另一个重要部分是用于将数据编码/解码到交换文件/从交换文件解码的CPU。这是我选择的选项三，即...
*   3：使用 I/O 线程，即处理交换 I/O 操作的线程池。这就是 Redis VM 正在使用的内容，因此让我们详细介绍一下其工作原理。

## I/O 线程

线程化 VM 设计的目标如下，按重要性排序：

*   简单的实现，竞争条件的空间很小，锁定简单，VM系统或多或少地与Redis代码的其余部分完全分离。
*   良好的性能，客户端访问内存中的值时没有锁。
*   能够解码/编码 I/O 线程中的对象。

上述目标导致了一个实现，其中 Redis 主线程（为实际客户端提供服务的线程）和 I/O 线程使用作业队列进行通信，并使用单个互斥锁进行通信。
基本上，当主线程需要一些I / O线程在后台完成一些工作时，它会在`server.io_newjobs`queue（即，只是一个链接列表）。如果没有活动的 I/O 线程，则启动一个。此时，某个 I/O 线程将处理 I/O 作业，并将处理结果推送到`server.io_processed`队列。I/O 线程将使用 UNIX 管道向主线程发送一个字节，以发出信号，表明已处理新作业，并且结果已准备好进行处理。

这是如何`iojob`结构如下所示：

    typedef struct iojob {
        int type;   /* Request type, REDIS_IOJOB_* */
        redisDb *db;/* Redis database */
        robj *key;  /* This I/O request is about swapping this key */
        robj *val;  /* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this
                     * field is populated by the I/O thread for REDIS_IOREQ_LOAD. */
        off_t page; /* Swap page where to read/write the object */
        off_t pages; /* Swap pages needed to save object. PREPARE_SWAP return val */
        int canceled; /* True if this command was canceled by blocking side of VM */
        pthread_t thread; /* ID of the thread processing this entry */
    } iojob;

I/O 线程只能执行三种类型的作业（类型由`type`结构领域）：

*   `REDIS_IOJOB_LOAD`：将与给定键关联的值从交换加载到内存。交换文件内的对象偏移量为`page`，则对象类型为`key->vtype`.此操作的结果将填充`val`结构字段。
*   `REDIS_IOJOB_PREPARE_SWAP`：计算保存对象所需的页数`val`进入交换。此操作的结果将填充`pages`田。
*   `REDIS_IOJOB_DO_SWAP`：传输指向的对象`val`到交换文件，页面偏移`page`.

主线程只委派上述三个任务。其余所有工作都由 I/O 线程本身处理，例如，在交换文件页表中查找合适的可用页面范围（这是一个快速操作），决定要交换的对象，更改 Redis 对象的存储字段以反映值的当前状态。

## 非阻塞 VM 作为阻塞 VM 的概率增强

因此，现在我们有一种方法可以请求后台作业来处理缓慢的 VM 操作。如何将其添加到主线程完成的其余工作的组合中？虽然阻塞 VM 知道对象在查找对象时被交换出来，但这对我们来说为时已晚：在 C 中，在命令中间启动后台作业，离开函数，并在 I/O 线程完成我们请求的内容时，在同一点重新输入计算（即， 没有共同例程或延续或类似）。

幸运的是，有一种非常简单的方法来做到这一点。我们喜欢简单的事情：基本上将VM实现视为阻塞，但添加优化（使用我们能够执行的非无阻塞VM操作）以使阻塞*非常*不可能。

这就是我们所做的：

*   每当客户端向我们发送命令时，*以前*命令被执行，我们检查命令的参数向量以搜索交换的键。毕竟，我们知道对于每个命令，哪些参数是键，因为Redis命令格式非常简单。
*   如果我们检测到磁盘上交换了所请求命令中的至少一个密钥，则会阻止客户端，而不是真正发出命令。对于与请求的键关联的每个交换值，将创建一个 I/O 作业，以便将这些值带回内存中。主线程继续执行事件循环，而不关心被阻止的客户端。
*   同时，I/O 线程正在内存中加载值。每次 I/O 线程完成加载值时，它都会使用 UNIX 管道向主线程发送一个字节。管道文件描述符在主线程事件循环中具有关联的可读事件，即函数`vmThreadedIOCompletedJob`.如果此函数检测到已加载被阻止的客户端所需的所有值，则会重新启动客户端并调用原始命令。

因此，您可以将此视为几乎总是碰巧在内存中具有正确键的被阻止的 VM，因为我们暂停了将发出有关交换值的命令的客户端，直到加载此值。

如果检查哪个参数是键的函数以某种方式失败，则没有问题：查找函数将看到给定的键与交换的值相关联，并将阻止加载它。因此，当无法预测触及哪些密钥时，我们的非阻塞 VM 将恢复为阻塞 VM。

例如，在`SORT`命令与`GET`或`BY`选项，事先知道将请求哪些密钥并非易事，因此至少在第一个实现中，`SORT BY/GET`诉诸于阻止 VM 实现。

## 阻止交换密钥上的客户端

如何阻止客户端？在基于事件循环的服务器中挂起客户端是相当微不足道的。我们所要做的就是取消其读取处理程序。有时我们会做一些不同的事情（例如对于BLPOP），只是将客户端标记为被阻止，但不处理新数据（只是将新数据累积到输入缓冲区中）。

## 中止 I/O 作业

关于阻塞和非阻塞 VM 之间的交互，有一些难以解决的问题，也就是说，如果阻塞操作同时对一个键也对非阻塞操作“感兴趣”，会发生什么情况？

例如，在执行 SORT BY 时，排序命令以阻塞方式加载几个键。同时，另一个客户端可能会用简单的*获取密钥*命令，这将触发 I/O 作业的创建以在后台加载密钥。

处理这个问题的唯一简单方法是能够杀死主线程中的I / O作业，这样，如果我们要以阻塞方式加载或交换的密钥在`REDIS_VM_LOADING`或`REDIS_VM_SWAPPING`状态（即，有一个关于此密钥的 I/O 作业），我们可以只终止有关此密钥的 I/O 作业，然后继续执行我们想要执行的阻塞操作。

这并不像现在这样微不足道。在给定时刻，I/O 作业可以位于以下三个队列之一中：

*   server.io_newjobs：作业已排队，但没有线程正在处理它。
*   server.io_processing：作业正由 I/O 线程处理。
*   server.io_processed：作业已处理。
    能够终止 I/O 作业的函数是`vmCancelThreadedIOJob`，这就是它的作用：
*   如果作业位于 newjobs 队列中，则很简单，从队列中删除 iojob 结构就足够了，因为没有线程仍在执行任何操作。
*   如果作业位于处理队列中，则线程会弄乱我们的作业（可能还会干扰关联的对象！我们唯一能做的就是等待项目移动到*阻塞方式*.幸运的是，这种情况很少发生，因此这不是性能问题。
*   如果作业在已处理的队列中，我们只需将其标记为*取消*标记设置`canceled`字段在 iojob 结构中为 1。函数处理已完成的作业将忽略并释放作业，而不是真正处理它。

## 问题？

本文档绝不完整，获得全貌的唯一方法是阅读源代码，但它应该是一个很好的介绍，以使代码审查/理解变得更加简单。

此页面有不清楚的地方？请发表评论，我将尝试解决可能将答案整合到本文档中的问题。
