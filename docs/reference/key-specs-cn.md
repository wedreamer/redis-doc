***

标题：“命令键规范”
链接标题：“命令键规范”
体重： 1
描述：什么是命令键规范以及如何在客户端中使用它们
别名：

*   /主题/键规格

***

Redis 中的许多命令都接受键名作为输入参数。
回复中的第 9 个元素`COMMAND`（和`COMMAND INFO`） 是由命令的关键规范组成的数组。

一个*关键规格*描述了用于从给定命令的参数中提取一个或多个键的名称的规则。
关键规格提供了一个强大而灵活的机制，与*第一个键*,*最后一个键*和*步*方案一直采用到 Redis 7.0。
在引入这些规范之前，Redis 客户端没有简单的编程方法来提取所有命令的键名。

集群感知的 Redis 客户端必须在命令（如`EVAL`和`ZUNIONSTORE`依赖于*数字键*参数或`SORT`及其许多条款。
或者，`COMMAND GETKEYS`可用于实现类似的提取效果，但延迟较高。

Redis 客户端没有义务支持关键规范。
它可以继续使用旧版*第一个键*,*最后一个键*和*步*方案以及[*可移动键*旗](/commands/command#flags)保持不变。

但是，实现密钥规范支持的 Redis 客户端可以合并其大部分密钥的提取逻辑。
即使客户端遇到不熟悉类型的密钥规范，它也始终可以恢复到`COMMAND GETKEYS`命令。

也就是说，大多数集群感知客户端只需要一个键名即可执行正确的命令路由，因此，尽管命令具有一个不熟悉的规范，但其另一个规范仍可供客户端使用。

关键规格是具有三个键的映射：

1.  **begin_search：**：用于提取键的起始索引。
2.  **find_keys：**用于标识相对于 BS 的键的规则。
3.  **笔记**：有关此密钥规范的注释（如果有）。
4.  **标志**：指示数据访问的类型。

## begin_search

这*begin_search*规范的值通知客户端提取的开始。
该值为映射。
有三种类型的`begin_search`:

1.  **指数：**键名参数从常量索引处开始。
2.  **关键词：**键名从特定关键字（令牌）之后开始。
3.  **未知：**未知类型的规范 - 请参阅[不完整的标志部分](#incomplete)了解更多详情。

### 指数

这*指数*类型`begin_search`表示输入键以常量索引显示。
它是地图下*规范*具有单个键的键：

1.  **指数：**从 0 开始的索引，客户端应从该索引开始提取键名。

### 关键词

这*关键词*类型`begin_search`表示文本标记位于键名参数之前。
它是地图下*规范*使用两个键：

1.  **关键词：**标记键名参数开头的关键字（标记）。
2.  **开始从：**客户端应从中开始搜索的参数数组的索引。
    这可以是负值，这意味着搜索应以相反的顺序从参数数组的末尾开始。
    例如*-2*的意思是从倒数第二个参数反向搜索。

更多示例*关键词*搜索类型包括：

*   `SET`具有`begin_search`型式规格*指数*值为*1*.
*   `XREAD`具有`begin_search`型式规格*关键词*与值*“流”*和*1*如*关键词*和*启动从*分别。
*   `MIGRATE`具有*start_search*型式规格*关键词*具有*“钥匙”*和*-2*.

## find_keys

这`find_keys`键规范的值告诉客户端如何继续搜索键名。
`find_keys`有三种可能的类型：

1.  **范围：**键在特定索引处停止或相对于最后一个参数。
2.  **键数：**附加参数指定输入键的数量。
3.  **未知：**未知类型的规范 - 请参阅[不完整的标志部分](#incomplete)了解更多详情。

### 范围

这*范围*类型`find_keys`是地图下*规范*具有三个键的键：

1.  **上一键：**索引，相对于`begin_search`，的最后一个关键参数。
    这可以是负值，在这种情况下，它不是相对值。
    例如*-1*指示继续提取键，直到最后一个参数，*-2*直到最后一个之前，依此类推。
2.  **键步：**找到键后应跳过的参数数，以查找下一个参数。
3.  **限制：**如果*上一键*具有的价值*-1*，我们使用*限制*以按因子停止搜索。
    *0*和*1*意味着没有限制。
    *2*表示剩余参数的一半，3 表示三分之一，依此类推。

### 键数

这*键数*类型`find_keys`是地图下*规范*具有三个键的键：

*   **键数：**索引，相对于`begin_search`，则包含键数的参数。
*   **第一键：**索引，相对于`begin_search`，的第一个键。
    这通常是之后的下一个参数*keynumidx*，并且其值（在本例中）大于 1。
*   **键步：**找到密钥后，应跳过的参数数，以查找下一个参数。

例子：

*   这`SET`命令有一个*范围*之*0*,*1*和*0*.
*   这`MSET`命令有一个*范围*之*-1*,*2*和*0*.
*   这`XREAD`命令有一个*范围*之*-1*,*1*和*2*.
*   这`ZUNION`命令有一个*start_search*类型*指数*与值*1*和`find_keys`类型*键数*值为*0*,*1*和*1*.
*   这[`AI.DAGRUN`](https://oss.redislabs.com/redisai/master/commands/#aidagrun)命令有一个*start_search*类型*关键词*值为*“加载”*和*1*和`find_keys`类型*键数*值为*0*,*1*和*1*.

**注意：**
这不是一个完美的解决方案，因为模块编写者可以想出任何东西。
但是，此机制应允许提取绝大多数命令的键名参数。

## 笔记

有关不明显的关键规格注意事项（如果适用）的说明。

## 标志

密钥规范可以具有其他标志，这些标志提供有关密钥的更多详细信息。
这些标志分为三组，如下所述。

### 访问类型标志

以下标志声明命令对键的值或其元数据的访问类型。
键的元数据包括 LRU/LFU 计数器、类型和基数。
这些标志与发送回客户端的答复无关。

每个密钥规范都恰好具有以下标志之一：

*   **乌尔曼：**读写标志。
    该命令修改存储在键的值或其元数据中的数据。
    此标志标记不是明显删除、覆盖或只读的每个操作。
*   **RO：**只读标志。
    该命令仅读取密钥的值（尽管它不一定返回它）。
*   **嗯：**覆盖标志。
    该命令将覆盖存储在密钥值中的数据。
*   **马币：**删除标志。
    该命令将删除密钥。

### 逻辑操作标志

以下标志声明对存储为键的值及其 TTL（如果有）的数据执行的操作的类型，而不是元数据。
这些标志描述命令对数据执行的逻辑操作，由输入参数驱动。
这些标志与修改或返回元数据（如键的类型、基数或存在性）无关。

每个密钥规范可能包括以下标志：

*   **访问：**访问标志。
    此标志指示命令返回、复制或以某种方式使用存储在密钥中的用户数据。

此外，说明书可以精确地包括下列之一：

*   **更新：**更新标志。
    该命令更新存储在键值中的数据。
    新值可能取决于旧值。
    此标志标记不是明确插入或删除的每个操作。
*   **插入：**插入标志。
    该命令仅将数据添加到值;不会修改或删除现有数据。
*   **删除：**删除标志。
    该命令显式删除存储在键处的值中的数据。

### 其他标志

关键规范可能具有以下标志：

*   **not_key：**此标志指示指定的参数不是键。
    在计算应为 Redis 集群分配命令的插槽时，此参数被视为与密钥相同。
    出于所有其他目的，不应将此参数视为关键。
*   **不完全的：**下面将对此标志进行说明。
*   **variable_flags：**下面将对此标志进行说明。

### 不完全的

在指定其键时，某些命令具有奇特的方法，这使得提取变得困难。
例如，考虑一下调用`MIGRATE`包含文本字符串*“钥匙”*作为其参数*认证*第。
我们的关键规范会错过标记，并且提取将从错误的索引开始。

因此，我们认识到密钥规范不完整，可能无法提取所有密钥。
但是，我们保证，即使不完整的规范也永远不会产生错误的键名称，前提是命令在语法上是正确的。

在以下情况下`MIGRATE`，搜索从末尾 （*启动从*具有*-1*).
如果我们遇到名为*“钥匙”*，我们只会提取它后面的键名参数的子集。
这就是为什么`MIGRATE`具有*不完全的*标志在其关键规范中。

另一个不完整的情况是`SORT`命令。
在这里，`begin_search`和`find_keys`属于类型*未知*.
客户端应恢复为调用`COMMAND GETKEYS`命令，用于从参数中提取键名，而不是以本机方式实现它。
例如，困难就出现了，因为字符串*“商店”*既是关键字（标记），又是 有效的文字参数`SORT`.

**注意：**
唯一具有*不完全的*主要规格是`SORT`和`MIGRATE`.
我们不希望将来添加此类命令。

### variable_flags

在某些命令中，同一键名参数的标志可能依赖于其他参数。
例如，考虑`SET`命令及其可选*获取*论点。
没有*获取*论点`SET`是只写的，但它成为读取和写入命令。
当此标志存在时，这意味着关键规范标志涵盖了所有可能的选项，但有效标志依赖于其他参数。

## 例子

### `SET`的关键规格

      1) 1) "flags"
         2) 1) RW
            2) access
            3) update
         3) "begin_search"
         4) 1) "type"
            2) "index"
            3) "spec"
            4) 1) "index"
               2) (integer) 1
         5) "find_keys"
         6) 1) "type"
            2) "range"
            3) "spec"
            4) 1) "lastkey"
               2) (integer) 0
               3) "keystep"
               4) (integer) 1
               5) "limit"
               6) (integer) 0

### `ZUNION`的关键规格

      1) 1) "flags"
         2) 1) RO
            2) access
         3) "begin_search"
         4) 1) "type"
            2) "index"
            3) "spec"
            4) 1) "index"
               2) (integer) 1
         5) "find_keys"
         6) 1) "type"
            2) "keynum"
            3) "spec"
            4) 1) "keynumidx"
               2) (integer) 0
               3) "firstkey"
               4) (integer) 1
               5) "keystep"
               6) (integer) 1
