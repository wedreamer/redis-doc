
本文档将帮助您了解如果您遇到问题, 则可能是什么
在使用 Redis 时遇到延迟问题。

在这方面*延迟*是客户端之间的最大延迟
发出命令以及
客户。通常 Redis 处理时间极短, 在亚微秒内
范围, 但在某些情况下会导致更高的延迟数字。

## 我没有多少时间, 给我清单

以下文档对于在
低延迟时尚。然而, 我知道我们是忙碌的人, 所以
让我们从快速清单开始。如果您未能按照这些步骤操作, 请
返回此处阅读完整文档。

1.  确保您没有运行阻止服务器的慢速命令。使用 Redis[慢速日志功能](/commands/slowlog)以检查此内容。
2.  对于 EC2 用户, 请确保使用基于 HVM 的现代 EC2 实例, 如 m3.medium。否则 fork ()  太慢。
3.  必须从内核中禁用透明大页面。用`echo never > /sys/kernel/mm/transparent_hugepage/enabled`以禁用它们, 然后重新启动 Redis 进程。
4.  如果您使用的是虚拟机, 则可能存在与 Redis 无关的固有延迟。使用以下命令检查运行时环境可能预期的最小延迟`./redis-cli --intrinsic-latency 100`.注意：您需要在*服务器*不在客户端中。
5.  启用和使用[延迟监视器](/topics/latency-monitor)Redis 的功能, 以便对 Redis 实例中的延迟事件和原因进行人类可读的描述。

通常, 使用下表进行持久性与延迟/性能权衡, 从更强的安全性到更好的延迟排序。

1.  AOF + fsync总是：这是非常慢的, 只有当你知道自己在做什么时, 才应该使用它。
2.  AOF + fsync 每秒：这是一个很好的折衷方案。
3.  AOF + fsync 每秒 + 无附加fsync-on-rewrite 选项设置为 yes：如上所述, 但在重写期间避免使用 fsync 以降低磁盘压力。
4.  AOF + fsync 从不。在此设置中, Fsync 由内核决定, 甚至更少的磁盘压力和延迟峰值风险。
5.  新浪网.在这里, 您有大量的权衡, 具体取决于您配置的保存触发器。

现在, 对于有15分钟时间的人来说, 细节...

## 测量延迟

如果您遇到延迟问题, 您可能知道如何测量
它在你的应用程序的上下文中, 或者也许你的延迟问题非常严重
甚至在宏观上也很明显。但是, redis-cli 可用于测量
Redis 服务器的延迟 (以毫秒为单位), , 只需尝试：

    redis-cli --latency -h `host` -p `port`

## 使用内部 Redis 延迟监控子系统

从 Redis 2.8.13 开始, Redis 提供的延迟监控功能
能够对不同的执行路径进行采样, 以了解
服务器被阻止。这使得调试中所示的问题
本文档要简单得多, 因此我们建议启用延迟监控
尽快。请参阅[延迟监视器文档](/topics/latency-monitor).

而延迟监控采样和报告功能将使
更容易理解Redis系统中的延迟源, 它仍然
建议您广泛阅读本文档以更好地理解
Redis和延迟峰值的主题。

## 延迟基线

有一种延迟本质上是环境的一部分, 其中
您运行 Redis, 这是您的操作系统内核提供的延迟
并且, 如果您使用的是虚拟化, 则可以使用虚拟机管理程序。

虽然这种延迟无法消除, 但重要的是要研究它, 因为
它是基线, 换句话说, 您将无法实现Redis
延迟比您的每个进程中运行的延迟要好
环境将由于内核或虚拟机管理程序实现而遇到
或设置。

我们称之为延迟**固有延迟**和`redis-cli`开始
从Redis版本2.8.7能够测量它。这是一个示例运行
在入门级服务器上运行的 Linux 3.11.0 下。

注意：参数`100`是将执行测试的秒数。
我们运行测试的时间越长, 我们就越有可能发现
延迟峰值。100 秒通常是合适的, 但你可能想要
在不同时间执行几次运行。请注意, 测试是CPU
密集, 可能会使系统中的单个内核饱和。

    $ ./redis-cli --intrinsic-latency 100
    Max latency so far: 1 microseconds.
    Max latency so far: 16 microseconds.
    Max latency so far: 50 microseconds.
    Max latency so far: 53 microseconds.
    Max latency so far: 83 microseconds.
    Max latency so far: 115 microseconds.

注：在此特殊情况下需要重新调整**在服务器中运行**运行或计划运行 Redis 的位置, 而不是在客户端中。在这种特殊模式下, redis-cli 根本不会连接到 Redis 服务器：它只会尝试测量内核不提供 CPU 时间运行到 redis-cli 进程本身的最大时间。

在上面的示例中, 系统的固有延迟仅为 0.115
毫秒 (或115微秒), , 这是一个好消, , 但请记住
固有延迟可能会随时间而变化, 具体取决于
系统。

虚拟化环境不会显示如此好的数字, 尤其是在高
负载或是否有嘈杂的邻居。以下是在 Linode 4096 上运行的内容
运行 Redis 和 Apache 的实例：

    $ ./redis-cli --intrinsic-latency 100
    Max latency so far: 573 microseconds.
    Max latency so far: 695 microseconds.
    Max latency so far: 919 microseconds.
    Max latency so far: 1606 microseconds.
    Max latency so far: 3191 microseconds.
    Max latency so far: 9243 microseconds.
    Max latency so far: 9671 microseconds.

在这里, 我们有一个9.7毫秒的固有延迟：这意味着我们不能向Redis提出比这更好的要求。但是, 在具有不同虚拟化环境的不同虚拟化环境中, 其他运行在具有较高负载或嘈杂邻居的环境中, 很容易显示更差的值。我们能够测量长达40毫秒的
否则系统显然运行正常。

## 网络和通信引起的延迟

客户端使用 TCP/IP 连接或 Unix 域连接连接到 Redis。
1 Gbit/s网络的典型延迟约为200 us, 而延迟
使用Unix域套接字可以低至30 us。这实际上取决于您的
网络和系统硬件。在通信本身之上, 系统
增加了一些延迟 (由于线程调度, CPU缓存, NUMA放置, 
等等...系统引起的延迟在虚拟化上明显更高
环境, 而不是在物理机上。

结果是, 即使 Redis 在亚微秒内处理大多数命令也是如此。
范围, 执行多次往返服务器的客户端将不得不支付
对于这些网络和系统相关的延迟。

因此, 高效的客户端将尝试通过以下方式限制往返次数：
将多个命令串联在一起。服务器完全支持此功能
和大多数客户。聚合命令 (如 MSET/MGET) 也可用于
这个目的。从 Redis 2.4 开始, 许多命令还支持
所有数据类型的可变参数。

以下是一些准则：

*   如果负担得起, 请优先使用物理计算机而不是 VM 来托管服务器。
*   不要系统地连接/断开与服务器的连接 (尤其是
    对于基于 Web 的应用程序) 。尽可能长时间地保持您的连接。
*   如果您的客户端与服务器位于同一主机上, 请使用 Unix 域套接字。
*   首选使用聚合命令  (MSET/MGET)  或带有可变参数的命令
    参数 (如果可能) 通过流水线。
*   首选使用流水线 (如果可能) 而不是往返序列。
*   Redis 支持 Lua 服务器端脚本, 以涵盖不适合的情况
    用于原始流水线 (例如, 当命令的结果是
    以下命令) 。

在Linux上, 有些人可以通过玩进程来实现更好的延迟。
放置 (任务集) 、cgroups、实时优先级  (chrt) 、NUMA
配置  (numactl), , 或使用低延迟内核。请注意：
香草 Redis 并不适合被束缚在**单**中央处理器核心。
Redis 可以分叉出非常消耗 CPU 的后台任务
喜欢`BGSAVE`或`BGREWRITEAOF`.这些任务必须**从不**在同一内核上运行
作为主事件循环。

在大多数情况下, 不需要这些系统级优化。
仅当您需要它们并且熟悉它们时才执行它们。

## Redis 的单线程特性

Redis 使用*主要*单线程设计。这意味着单个进程
为所有客户端请求提供服务, 使用一种称为**多路复用**.
这意味着Redis可以在每个给定的时刻为单个请求提供服务, 因此
所有请求均按顺序送达。这与 Node 非常相似.js
也可以。然而, 这两种产品通常不被认为是缓慢的。
这部分是由于完成单个请求的时间很少, 
但主要是因为这些产品被设计为不阻止系统调用, 
例如从套接字读取数据或将数据写入套接字。

我说Redis是*主要*单线程实际上来自 Redis 2.4
我们在 Redis 中使用线程, 以便在
背景, 主要与磁盘 I/O 有关, 但这并不能改变事实
Redis 使用单个线程为所有请求提供服务。

## 慢速命令生成的延迟

单线程的结果是, 当请求服务速度很慢时
所有其他客户端将等待此请求得到处理。执行时
普通命令, 如`GET`或`SET`或`LPUSH`这不是问题
因为这些命令是在恒定 (并且非常小) 的时间内执行的。
但是, 有些命令对许多元素进行操作, 例如`SORT`,`LREM`,
`SUNION`和其他人。例如, 取两个大集合的交集
可能需要相当长的时间。

记录了所有命令的算法复杂性。良好的做法
是在使用您不熟悉的命令时系统地检查它。

如果您有延迟问题, 则不应使用慢速命令
值由许多元素组成, 或者您应该使用 Redis 运行副本
复制, 您可以在其中运行所有慢速查询。

可以使用 Redis 监视慢速命令
[慢速日志功能](/commands/slowlog).

此外, 您可以使用自己喜欢的每进程监控程序
 (top,  htop,  prstat,  etc ...) 快速检查 CPU 消耗
主 Redis 进程。如果流量不高, 则通常
表示使用了慢速命令。

**重要提示**：执行时生成的非常常见的延迟源
的慢速命令是使用`KEYS`命令。
`KEYS`, 如 Redis 文档中所述, 应仅用于
调试目的。从 Redis 2.8 开始, 引入了一个新的命令, 以便
增量迭代密钥空间和其他大型集合, 请检查
这`SCAN`,`SSCAN`,`HSCAN`和`ZSCAN`命令以了解更多信息。

## 分叉产生的延迟

为了在后台生成 RDB 文件, 或者在启用了 AOF 持久性的情况下重写仅追加文件, Redis 必须分叉后台进程。
分叉操作 (在主线程中运行) 本身会导致延迟。

在大多数类Unix系统上, 分叉是一种昂贵的操作, 因为它涉及
复制大量链接到进程的对象。这一点尤其重要
对于与虚拟内存机制关联的页表, 则为 true。

例如, 在 Linux/AMD64 系统上, 内存分为 4 kB 页。
要将虚拟地址转换为物理地址, 每个进程都会存储
至少包含指针的页表 (实际上表示为树) 
进程地址空间的每页。因此, 一个 24 GB 的大型 Redis 实例
需要 24 GB / 4 kB \* 8 = 48 MB 的页表。

执行后台保存时, 必须分叉此实例, 
这将涉及分配和复制48 MB的内存。这需要时间
和 CPU, 尤其是在分配和初始化的虚拟机上
的大内存块可能很昂贵。

## 不同系统中的分叉时间

现代硬件在复制页表方面非常快, 但Xen不是。
Xen 的问题不是特定于虚拟化的, 而是特定于 Xen 的。例如, 使用VMware或Virtual Box不会导致分叉时间变慢。
下表比较了不同 Redis 实例的分叉时间
大小。执行 BGSAVE 并查看`latest_fork_usec`在`INFO`命令输出。

然而, 好消息是**基于 EC2 HVM 的新型实例很多
更好的分叉时间**, 几乎与物理服务器相当, 例如
使用 m3.medium (或更好) 实例将提供良好的结果。

*   **Linux beefy VM on VMware**6.0GB RSS 在 77 毫秒内分叉 (每 GB 12.8 毫秒) 。
*   **在物理机上运行的 Linux (未知硬件) **6.1GB RSS 在 80 毫秒内分叉 (每 GB 13.1 毫秒) 
*   **在物理机上运行的 Linux (Xeon @ 2.27Ghz) **6.9GB RSS 分叉为 62 毫秒 (每 GB 9 毫秒) 。
*   **Linux VM on 6sync  (KVM) **360 MB RSS 在 8.2 毫秒内分叉 (每 GB 23.3 毫秒) 。
*   **EC2 上的 Linux VM, 旧实例类型  (Xen) **6.1GB RSS 分叉 1460 毫秒 (每 GB 239.3 毫秒) 。
*   **EC2 上的 Linux VM, 新的实例类型  (Xen) **1GB RSS 在 10 毫秒内分叉 (每 GB 10 毫秒) 。
*   **Linode 上的 Linux VM  (Xen) **0.9GBRSS 分叉为 382 毫秒 (每 GB 424 毫秒) 。

如您所见, 在 Xen 上运行的某些 VM 的性能会降低到一个数量级到两个数量级。对于 EC2 用户, 建议很简单：使用基于 HVM 的现代实例。

## 透明大页面引起的延迟

不幸的是, 当Linux内核启用了透明的大页面时, Redis
在`fork`调用用于
保留在磁盘上。大页面是导致以下问题的原因：

1.  称为Fork, 创建两个具有共享大页面的进程。
2.  在繁忙的实例中, 运行几个事件循环将导致命令以几千页为目标, 从而导致几乎整个进程内存的写入复制。
3.  这将导致大延迟和大内存使用量。

确保**禁用透明大页面**使用以下命令：

    echo never > /sys/kernel/mm/transparent_hugepage/enabled

## 交换 (操作系统分页) 引起的延迟

Linux (和许多其他现代操作系统) 能够重新定位内存
从内存到磁盘的页, 反之亦然, 以便使用
系统内存有效。

如果内核将 Redis 页面从内存移动到交换文件, 则当
Redis 使用此内存页中存储的数据 (例如, 访问
一个密钥存储在此内存页面中) 内核将停止 Redis 进程
以便将页面移回主内存。这是一个缓慢的操作
涉及随机 I/O (与访问内存中已有的页面相比) 
并将导致 Redis 客户端遇到异常延迟。

内核重新定位磁盘上的 Redis 内存页主要有三个原因：

*   系统处于内存压力之下, 因为正在运行的进程要求很高
    比可用内存量更多的物理内存。最简单的实例
    这个问题只是 Redis 使用的内存多于可用内存。
*   Redis 实例数据集或数据集的一部分大部分完全空闲
     (客户端从不访问), , 因此内核可以交换磁盘上的空闲内存页。
    这个问题非常罕见, 因为即使是中等速度的实例也会触及所有
    内存页经常, 迫使内核保留内存中的所有页。
*   某些进程正在系统上生成大量读取或写入 I/O。因为
    文件一般都是缓存的, 它往往会给内核施加压力以增加
    文件系统缓存, 因此生成交换活动。请注意
    包括 Redis RDB 和/或 AOF 后台线程, 它们可以生成大文件。

幸运的是, Linux提供了很好的工具来调查问题, 所以最简单的
要做的是, 当怀疑由于交换引起的延迟时, 只是为了检查是否
事实就是如此。

首先要做的是检查交换的 Redis 内存量
在磁盘上。为此, 您需要获取 Redis 实例 pid：

    $ redis-cli info | grep process_id
    process_id:5454

现在输入此过程的 /proc 文件系统目录：

    $ cd /proc/5454

在这里, 您将找到一个名为**smaps**描述的内存布局
Redis 进程 (假设您使用的是 Linux 2.6.16 或更高版本) 。
此文件包含有关我们的进程内存映射的非常详细的信息, 
和一个名为**交换**正是我们正在寻找的。然而
不只有一个交换字段, 因为 smaps 文件包含
Redis 进程的不同内存映射 (进程的内存布局
比简单的页面线性数组更复杂) 。

由于我们对进程交换的所有内存感兴趣, 因此首先要做的是
要做的是在所有文件中为交换字段添加 grep：

    $ cat smaps | grep 'Swap:'
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                 12 kB
    Swap:                156 kB
    Swap:                  8 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  4 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  4 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  4 kB
    Swap:                  4 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB
    Swap:                  0 kB

如果所有内容都是 0 kB, 或者如果存在零星的 4k 条目, 则一切都是
完全正常。实际上在我们的示例实例中 (真实Web的实例之一) 
运行Redis并每秒为数百名用户提供服务的网站) 有一个
显示更多交换页面的条目很少。调查这是否是严重的
问题与否我们改变我们的命令, 以便也打印的大小
内存映射：

    $ cat smaps | egrep '^(Swap|Size)'
    Size:                316 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  8 kB
    Swap:                  0 kB
    Size:                 40 kB
    Swap:                  0 kB
    Size:                132 kB
    Swap:                  0 kB
    Size:             720896 kB
    Swap:                 12 kB
    Size:               4096 kB
    Swap:                156 kB
    Size:               4096 kB
    Swap:                  8 kB
    Size:               4096 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:               1272 kB
    Swap:                  0 kB
    Size:                  8 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                 16 kB
    Swap:                  0 kB
    Size:                 84 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  8 kB
    Swap:                  4 kB
    Size:                  8 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  4 kB
    Size:                144 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  4 kB
    Size:                 12 kB
    Swap:                  4 kB
    Size:                108 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB
    Size:                272 kB
    Swap:                  0 kB
    Size:                  4 kB
    Swap:                  0 kB

从输出中可以看出, 有一个720896 kB的地图
 (交换的只有12 kB) 和在另一张地图中交换的156 kB：
基本上我们交换了非常少量的内存, 所以这不是
根本不会造成任何问题。

相反, 如果在磁盘上交换了大量进程内存, 则
延迟问题可能与交换有关。如果您的
Redis 实例, 您可以使用**vmstat**命令：

    $ vmstat 1
    procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
     0  0   3980 697932 147180 1406456    0    0     2     2    2    0  4  4 91  0
     0  0   3980 697428 147180 1406580    0    0     0     0 19088 16104  9  6 84  0
     0  0   3980 697296 147180 1406616    0    0     0    28 18936 16193  7  6 87  0
     0  0   3980 697048 147180 1406640    0    0     0     0 18613 15987  6  6 88  0
     2  0   3980 696924 147180 1406656    0    0     0     0 18744 16299  6  5 88  0
     0  0   3980 697048 147180 1406688    0    0     0     4 18520 15974  6  6 88  0
    ^C

满足我们需求的输出的有趣部分是两列**四**
和**所以**, 计算从交换文件/到交换文件的内存量。如果
您在这两列中看到非零计数, 然后存在交换活动
在您的系统中。

最后, **碘司他**命令可用于检查 全局 I/O 活动
系统。

    $ iostat -xk 1
    avg-cpu:  %user   %nice %system %iowait  %steal   %idle
              13.55    0.04    2.92    0.53    0.00   82.95

    Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
    sda               0.77     0.00    0.01    0.00     0.40     0.00    73.65     0.00    3.62   2.58   0.00
    sdb               1.27     4.75    0.82    3.54    38.00    32.32    32.19     0.11   24.80   4.24   1.85

如果您的延迟问题是由于 Redis 内存在磁盘上交换, 则需要
以降低系统中的内存压力, 如果 Redis, 则添加更多 RAM
使用的内存多于可用内存, 或避免运行其他内存
同一系统中的饥饿进程。

## 由于 AOF 和磁盘 I/O 导致的延迟

延迟的另一个来源是由于 Redis 上的“仅追加文件”支持。
AOF 基本上使用两个系统调用来完成其工作。一个是
write (2)  用于将数据写入仅追加文, ,  以及
另一个是 fdatasync (2), ,  用于刷新内核
磁盘上的文件缓冲区, 以确保
用户。

write (2)  和 fdatasync (2)  调用都可能成为延迟的来源。
例如, write (2)  可以在系统范围的同步时阻止两者
正在进行中, 或者当输出缓冲区已满且内核需要时
以刷新磁盘以接受新的写入。

fdatasync (2)  调用是一个更糟糕的延迟, , 与许多组合一样
使用的内核和文件系统可能需要几毫秒到
几秒钟即可完成, 特别是在其他一些过程的情况下
执行 I/O。因此, 如果可能的话, Redis 会执行 fdatasync (2)  调用
自 Redis 2.4 以来的不同线程中。

我们将了解配置如何影响延迟的数量和来源
使用 AOF 文件时。

AOF 可以配置为在三种不同的磁盘上执行 fsync
使用的方式**追加同步**配置选项 (此设置可以是
在运行时使用**配置集**命令) 。

*   当追加同步设置为的值**不**Redis 不执行 fsync。
    在此配置中, 延迟的唯一来源可以是 write (2) 。
    当这种情况发生时, 通常没有解决方案, 因为只是磁盘不能
    应对 Redis 接收数据的速度, 但这是
    如果磁盘没有被其他进程严重减慢速度, 则不常见
    输入/输出。

*   当追加同步设置为的值**每秒**Redis 执行
    每秒同步一次。它使用不同的线程, 并且如果 fsync 仍然是
    正在进行中 Redis 使用缓冲区将写入 (2)  调用延迟最多两秒
     (因为如果 fsync 正在针对
    同一文件) 。但, , 如果 fsync 花费的时间太, , Redis 最终将
    执行 write (2)  调, , 即使 fsync 仍在进行, ,  并且
    可能是延迟的来源。

*   当追加同步设置为的值**总是**执行同步
    在每次写入操作中使用 OK 代码回复客户端之前
     (实际上Redis会尝试集群同时执行的许多命令
    到单个 fsync 中) 。在这种模式, , 性能通常非常, , 并且
    强烈建议使用快速磁盘和文件系统实现
    可以在短时间内执行 fsync。

大多数 Redis 用户将使用**不**或**每秒**设置
附加异步配置指令。关于最小延迟的建议是
以避免其他进程在同一系统中执行 I/O。
使用SSD磁盘也可以提供帮助, 但通常即使是非SSD磁盘也可以执行
好吧, 如果磁盘在Redis写入时是备用的, 则仅追加文件
到仅追加文件而不执行任何查找。

如果要调查仅与追加相关的延迟问题
文件, 您可以在 Linux 下使用 strace 命令：

    sudo strace -p $(pidof redis-server) -T -e trace=fdatasync

上面的命令将显示所有 fdatasync (2)  执行的系统调用
主线程中的 Redis。使用上述命令, 您将不会看到
fdatasync 系统调用由后台线程执行, 当
附加同步配置选项设置为**每秒**.为了这样做
只需将 -f 开关添加到 strace。

如果您愿意, 您还可以看到 fdatasync 和写入系统调用, 并使用
以下命令：

    sudo strace -p $(pidof redis-server) -T -e trace=fdatasync,write

然而, 由于 write (2)  也用于将数据写入客户端
套接字, 这可能会显示太多与磁盘 I/O 无关的内容。
显然, 没有办法告诉strace只显示缓慢的系统调用, 所以
我使用以下命令：

    sudo strace -f -p $(pidof redis-server) -T -e trace=fdatasync,write 2>&1 | grep -v '0.0' | grep -v unfinished

## 过期产生的延迟

Redis 通过两种方式逐出过期的密钥：

*   一*懒惰*当命令请求密钥时, way 会使密钥过期, 但发现该密钥已过期。
*   一*积极*way 每 100 毫秒过期几个密钥。

活动过期被设计为自适应的。过期周期每 100 毫秒 (每秒 10 次) 启动一, , 并将执行以下操作：

*   样本`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`密钥, 逐出所有已过期的密钥。
*   如果发现超过 25% 的密钥已过期, 请重复上述步骤。

鉴于`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`默认设置为 20, 并且该过程每秒执行十次, 通常每秒只有 200 个密钥处于活动状态过期。这足以足够快地清理数据库, 即使已经过期的密钥长时间未被访问, 以便*懒惰*算法没有帮助。同时, 每秒仅过期 200 个密钥不会影响 Redis 实例的延迟。

但是, 该算法是自适应的, 如果它在采样密钥集中发现超过 25% 的已过期密钥, 它将循环。但是, 假设我们每秒运行该算法十次, 这意味着随机样本中超过25%的键的不幸事件至少即将到期。*在同一秒内*.

基本上这意味着**如果数据库有许多密钥在同一秒内过期, 并且这些密钥至少占当前具有过期集的密钥的 25%**, Redis 可以阻止以使已过期的密钥百分比低于 25%。

需要这种方法来避免对已经过期的密钥使用太多内存, 并且通常是绝对无害的, 因为奇怪的是, 大量的密钥将在同一秒内过期, 但用户使用并非不可能`EXPIREAT`在相同的Unix时间广泛。

简而言之：请注意, 在同一时刻过期的许多密钥可能是延迟的来源。

## Redis 软件看门狗

Redis 2.6 引入了*Redis Software Watchdog*这是一个调试工具
旨在跟踪由于某种原因而导致的延迟问题
逃避使用普通工具的分析。

软件看门狗是一项实验性功能。虽然它被设计为
在生产环境中使用时应注意备份数据库
在继续之前, 因为它可能与
Redis 服务器的正常执行。

重要的是仅将其用作*最后的手段*当无法通过其他方式跟踪问题时。

这是此功能的工作原理：

*   用户使用`CONFIG SET`命令。
*   Redis开始不断监控自身。
*   如果 Redis 检测到服务器被阻止进入某个返回速度不够快的操作, 并且这可能是延迟问题的根源, 则会在日志文件中转储有关服务器被阻止位置的低级别报告。
*   用户联系在 Redis Google 群组中编写消息的开发人员, 包括消息中的监视程序报告。

请注意, 使用 redis.conf 文件无法启用此功能, 因为它设计为仅在已运行的实例中启用, 并且仅用于调试目的。

要启用该功能, 只需使用以下命令：

    CONFIG SET watchdog-period 500

该时间段以毫秒为单位指定。在上面的示例中, 我指定仅当服务器检测到 500 毫秒或更大的延迟时才记录延迟问题。最小可配置周期为 200 毫秒。

完成软件看门狗后, 您可以将其关闭, 设置`watchdog-period`参数为 0。**重要：**请记住这样做, 因为在监视器打开的情况下使实例保持打开的时间比所需的时间长通常不是一个好主意。

以下是一个示例, 说明一旦软件监视器检测到比配置的延迟更长的延迟, 您将在日志文件中看到的内容：

    [8547 | signal handler] (1333114359)
    --- WATCHDOG TIMER EXPIRED ---
    /lib/libc.so.6(nanosleep+0x2d) [0x7f16b5c2d39d]
    /lib/libpthread.so.0(+0xf8f0) [0x7f16b5f158f0]
    /lib/libc.so.6(nanosleep+0x2d) [0x7f16b5c2d39d]
    /lib/libc.so.6(usleep+0x34) [0x7f16b5c62844]
    ./redis-server(debugCommand+0x3e1) [0x43ab41]
    ./redis-server(call+0x5d) [0x415a9d]
    ./redis-server(processCommand+0x375) [0x415fc5]
    ./redis-server(processInputBuffer+0x4f) [0x4203cf]
    ./redis-server(readQueryFromClient+0xa0) [0x4204e0]
    ./redis-server(aeProcessEvents+0x128) [0x411b48]
    ./redis-server(aeMain+0x2b) [0x411dbb]
    ./redis-server(main+0x2b6) [0x418556]
    /lib/libc.so.6(__libc_start_main+0xfd) [0x7f16b5ba1c4d]
    ./redis-server() [0x411099]
    ------

注意：在示例中**调试休眠**命令用于阻止服务器。如果服务器在不同的上下文中阻止, 则堆栈跟踪是不同的。

如果您碰巧收集了多个看门狗堆栈跟踪, 我们鼓励您将所有内容发送到 Redis Google Group：我们获得的跟踪越多, 就越容易了解您的实例的问题所在。
