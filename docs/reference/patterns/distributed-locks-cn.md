
分布式锁是许多环境中非常有用的原语, 其中
不同的流程必须使用共享资源在相互中运行
独特的方式。

有许多库和博客文章描述了如何实现
带有 Redis 的 DLM (分布式锁管理器), , 但每个库都使用不同的
方法, 并且许多使用简单的方法, 与
稍微复杂的设计可以实现什么。

本页介绍要实现的更规范的算法
使用 Redis 的分布式锁。我们提出了一种算法, 称为**雷德洛克**,
它实现了我们认为比香草单更安全的DLM
实例方法。我们希望社区能够对其进行分析, 提供
反馈, 并将其用作实现或更多实现的起点
复杂或替代设计。

## 实现

在描述算法之前, 这里有一些实现的链接
已经可用, 可以用作参考。

*   [红锁-rb](https://github.com/antirez/redlock-rb) (Ruby 实现) 。还有一个[红锁-rb的分叉](https://github.com/leandromoreira/redlock-rb)这增加了一个宝, , 便于分发。
*   [红锁-派](https://github.com/SPSCommerce/redlock-py) (Python 实现) 。
*   [陶器](https://github.com/brainix/pottery#redlock) (Python 实现) 。
*   [爱奥雷德洛克](https://github.com/joanvila/aioredlock) (Asyncio Python 实现) 。
*   [Redlock-php](https://github.com/ronnylt/redlock-php) (PHP 实现) 。
*   [PHPRedisMutex](https://github.com/malkusch/lock#phpredismutex) (进一步的 PHP 实现) 。
*   [cheprasov/php-redis-lock](https://github.com/cheprasov/php-redis-lock) (用于锁的 PHP 库) 。
*   [rtckit/react-redlock](https://github.com/rtckit/reactphp-redlock) (异步 PHP 实现) 。
*   [红色同步](https://github.com/go-redsync/redsync) (去实现) 。
*   [雷迪森](https://github.com/mrniko/redisson) (Java 实现) 。
*   [Redis：:D istLock](https://github.com/sbertrang/redis-distlock) (Perl 实现) 。
*   [Redlock-cpp](https://github.com/jacket-code/redlock-cpp) (C++实施) 。
*   [Redlock-cs](https://github.com/kidfashion/redlock-cs) (C#/.NET 实现) 。
*   [RedLock.net](https://github.com/samcook/RedLock.net) (C#/.NET 实现) 。包括异步和锁定扩展支持。
*   [猩红锁](https://github.com/psibernetic/scarletlock) (具有可配置数据存储的 C# .NET 实现) 。
*   [红锁4网](https://github.com/LiZhenNet/Redlock4Net) (C# .NET 实现) 。
*   [节点红锁](https://github.com/mike-marcacci/node-redlock) (NodeJS 实现) 。包括对锁扩展的支持。
*   [德诺 DLM](https://github.com/oslabs-beta/Deno-Redlock) (Deno 实现) 

## 安全和活力保证

我们将仅使用三个属性对设计进行建模, 从我们的角度来看, 这三个属性是有效使用分布式锁所需的最小保证。

1.  安全属性：相互排斥。在任何给定时刻, 只有一个客户端可以持有锁。
2.  活动属性 A：无死锁。最终, 始终可以获取锁定, 即使锁定资源的客户端崩溃或被分区也是如此。
3.  活动属性 B：容错。只要大多数 Redis 节点都处于启动状态, 客户端就能够获取和释放锁。

## 为什么基于故障转移的实现是不够的

为了理解我们想要改进的内容, 让我们分析一下大多数基于Redis的分布式锁库的当前状态。

使用 Redis 锁定资源的最简单方法是在实例中创建密钥。密钥通常是使用 Redis 过期功能在有限的时间内创建的, 因此最终它将被释放 (我们列表中的属性 2) 。当客户端需要释放资源, , 它会删除密钥。

从表面上看, 这很有效, 但有一个问题：这是我们架构中的单点故障。如果 Redis 主节点出现故障, 会发生什么情况？
好吧, 让我们添加一个副本！如果主服务器不可用, 请使用它。不幸的是, 这是行不通的。通过这样做, 我们无法实现相互排斥的安全属性, 因为 Redis 复制是异步的。

此模型存在争用条件：

1.  客户端 A 获取主服务器中的锁。
2.  主设备在将密钥的写入操作传输到副本之前崩溃。
3.  复制副本将提升为主副本。
4.  客户端 B 获取对同一资源 A 的锁, 该资源 A 已持有一个锁。**违反安全规定！**

有时, 在特殊情况下 (例如在故障期间), , 多个客户端可以同时持有锁是完全可以的。
如果是这种情况, 则可以使用基于复制的解决方案。否则, 我们建议实现本文档中描述的解决方案。

## 使用单个实例正确实现

在尝试克服上述单实例设置的限制之前, 让我们检查一下如何正确执行此操作, 因为在不时可以接受竞争条件的应用程序中, 这实际上是一个可行的解决方案, 并且因为锁定到单个实例是我们将用于此处描述的分布式算法的基础。

要获取锁, 要走的路如下：

        SET resource_name my_random_value NX PX 30000

仅当密钥尚不存在  (`NX`选项), , 过期时间为 30000 毫秒  (`PX`选项) 。
该键设置为值“my_random_value”。此值在所有客户端和所有锁定请求中必须是唯一的。

基本上, 使用随机值是为了以安全的方式释放锁, 并使用一个脚本告诉Redis：仅当密钥存在并且存储在密钥处的值与我期望的值完全相同时, 才将其删除。这是通过以下 Lua 脚本完成的：

    if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1])
    else
        return 0
    end

这对于避免删除由其他客户端创建的锁非常重要。例如, 客户端可能会获取锁, 在执行某些操作的时间超过锁定有效期 (密钥将过期的时间) 时被阻, , 然后删除其他客户端已经获得的锁定。
仅使用`DEL`不安全, 因为客户端可能会删除另一个客户端的锁。使用上述脚本, 每个锁都使用随机字符串“签名”, 因此仅当该锁仍然是尝试删除它的客户端设置的锁时, 才会将其删除。

这个随机字符串应该是什么？我们假设它是 20 字节`/dev/urandom`, 但您可以找到更便宜的方法, 使其足以满足您的任务的独特性。
例如, 一个安全的选择是将RC4种子`/dev/urandom`, 并从中生成伪随机流。
更简单的解决方案是使用具有微秒精度的 UNIX 时间戳, 将时间戳与客户端 ID 连接起来。它不那么安全, 但对于大多数环境来说可能已经足够了。

“锁效时间”是我们用作钥匙生存时间的时间。它既是自动释放时间, 也是客户端为了执行另一个客户端能够再次获取锁之前所需的操作所需的时间, 而不会在技术上违反互斥保证, 该保证仅限于从获取锁的那一刻起的给定时间窗口。

所以现在我们有了一个很好的方法来获取和释放锁。有了这个系统, 关于由单个, 始终可用的实例组成的非分布式系统的推理是安全的。让我们将这个概念扩展到一个分布式系统, 在那里我们没有这样的保证。

## 红锁算法

在算法的分布式版本中, 我们假设我们有N个Redis主节点。这些节点是完全独立的, 因此我们不使用复制或任何其他隐式协调系统。我们已经描述了如何在单个实例中安全地获取和释放锁。我们理所当然地认为, 算法将使用此方法在单个实例中获取和释放锁。在我们的示例中, 我们设置了 N=5, 这是一个合理的值, 因此我们需要在不同的计算机或虚拟机上运行 5 个 Redis 主节点, 以确保它们以一种基本独立的方式失败。

为了获取锁, 客户端执行以下操作：

1.  它获取当前时间 (以毫秒为单位) 。
2.  它尝试按顺序获取所有 N 个实例中的锁, 在所有实例中使用相同的键名和随机值。在步骤 2 中, 在每个实例中设置锁定时, 客户端使用与总锁定自动释放时间相比较小的超时来获取它。例如, 如果自动释放时间为 10 秒, 则超时可能在 ~ 5-50 毫秒范围内。这可以防止客户端长时间试图与已关闭的Redis节点通信：如果实例不可用, 我们应该尽快尝试与下一个实例通信。
3.  客户端通过从当前时间中减去步骤 1 中获得的时间戳来计算获取锁所经过的时间。当且仅当客户端能够在大多数实例 (至少 3 个) 中获取, , 并且获取锁所经过的总时间小于锁的有效时, , 则该锁被视为已获取。
4.  如果已获取锁, 则其有效性时间被视为初始有效时间减去经过的时间, 如步骤 3 中计算的那样。
5.  如果客户端由于某种原因未能获取锁定 (它无法锁定 N/2+1 个实例或有效期为负数), , 它将尝试解锁所有实例 (甚至是它认为无法锁定的实例) 。

### 算法是异步的吗？

该算法依赖于以下假设：虽然进程之间没有同步时钟, 但每个进程中的本地时间以大致相同的速率更新, 与锁的自动释放时间相比, 误差幅度很小。这个假设与现实世界的计算机非常相似：每台计算机都有一个本地时钟, 我们通常可以依靠不同的计算机来具有很小的时钟漂移。

在这一点上, 我们需要更好地指定我们的互斥规则：只要持有锁的客户端在锁有效时间内 (如步骤3中获得的那样) 终止其工, , 减去一些时间 (只需几毫, , 以补偿进程之间的时钟漂移,  , 它才能得到保证。

本文包含有关需要绑定的类似系统的更多信息*时钟漂移*:[租约：一种高效的容错机制, 用于分布式文件缓存一致性](http://dl.acm.org/citation.cfm?id=74870).

### 失败时重试

当客户端无法获取锁时, 它应该在随机延迟后重试, 以便尝试取消同步多个客户端, 尝试同时获取同一资源的锁 (这可能会导致没有人获胜的裂脑情况) 。此, , 在大多数 Redis 实例, , 客户端尝试获取锁的速度越, , 裂脑情况的窗口就越小 (并且需要重试,  , 因此理想情, 下, 客户端应尝试发送`SET`使用多路复用同时向 N 个实例发出命令。

值得强调的是, 对于未能获取大多数锁的客户端来说, 尽快释放 (部分) 获取的锁是多么重, , 这样就不需要等待密钥到期才能再次获取锁 (但, , 如果发生网络分区并且客户端不再能够与 Redis 实例通, ,  在等待密钥过期时需要支付可用性罚款) 。

### 释放锁

释放锁很简单, 无论客户端是否认为它能够成功锁定给定实例, 都可以执行。

### 安全论据

算法安全吗？让我们来看看在不同场景中会发生什么。

首先, 我们假设客户端能够在大多数实例中获取锁。所有实例都将包含一个具有相同生存时间的密钥。但是, 密钥是在不同的时间设置的, 因此密钥也会在不同的时间过期。但是, 如果第一个密钥在时间 T1 (我们在联系第一个服务器之前采样之前采样的时间) 设置为最, , 而最后一个密钥在时间 T2 (我们从最后一个服务器获得回复的时间) 设置为, 差, 则我们确信集合中第一个过期的密钥将至少存在`MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT`.所有其他密钥稍后将, 期, 因此我们确信至少这次将同时设置这些密钥。

在设置大多数密钥期间, 另一个客户端将无法获取锁, 因为如果 N/2+1 密钥已存在, 则 N/2+1 SET NX 操作无法成功。因此, 如果获得了锁, 则不可能同时重新获得它 (违反互斥属性) 。

但是, 我们还希望确保尝试同时获取锁的多个客户端无法同时成功。

如果客户端锁定大多数实例的时间接近或大于锁定最大有效时间 (我们基本上用于 SET 的 TTL), , 它将认为锁定无效并将解锁实, , 因此我们只需要考虑客户端能够在小于有效时间的时间内锁定大多数实例的情况。在这种情况, , 对于上面已经表达的论, , 对于`MIN_VALIDITY`任何客户端都无法重新获取锁。因, , 仅当锁定大多数实例的时间大于 TTL 时间, , 多个客户端才能同时锁定 N/2+1 个实例 (“时间”是步骤 2 的结束,  , 从而使锁定无效。

### 活泼性参数

系统活动性基于三个主要功能：

1.  自动释放锁 (因为钥匙过期) ：最终钥匙再次可供锁定。
2.  事实上, 通常, 当未获取锁或获取锁并终止工作时, 客户端将合作移除锁, 因此我们可能不必等待密钥过期即可重新获取锁。
3.  事实上, 当客户端需要重试锁时, 它等待的时间比获取大多数锁所需的时间要长得多, 以便从概率上使资源争用期间的裂脑条件变得不太可能。

但是, 我们支付的可用性罚款等于`TTL`网络分区上的时间, 因此, 如果有连续分区, 我们可以无限期地支付此罚款。
每次客户端获取锁并在能够删除锁之前进行分区时, 都会发生这种情况。

基本上, 如果存在无限连续的网络分区, 则系统可能会在无限长的时间内变得不可用。

### 性能、崩溃恢复和同步

许多使用 Redis 作为锁服务器的用户在获取和释放锁的延迟以及每秒可以执行的获取/释放操作数方面都需要高性能。为了满足这一要求, 与N Redis服务器对话以减少延迟的策略肯定是多路复用 (将套接字置于非阻塞模式, 发送所有命令, 稍后读取所有命令, 假设客户端和每个实例之间的RTT相似) 。

但是, 如果我们想以崩溃恢复系统模型为目标, 则关于持久性还有另一个考虑因素。

基本上, 为了看到这里的问题, 让我们假设我们配置Redis时根本没有持久性。客户端在 5 个实例中的 3 个实例中获取锁。客户端能够获取锁的其中一个实例重新启动, 此时我们可以为同一资源锁定3个实例, 而另一个客户端可以再次锁定它, 这违反了锁的独占性的安全属性。

如果我们启用AOF持久性, 事情将会有所改善。例如, 我们可以通过向服务器发送一个`SHUTDOWN`命令并重新启动它。由于 Redis 过期在语义上是实现的, 因此当服务器关闭时, 时间仍然会过去, 因此我们所有的要求都很好。
但是, 只要它是干净关闭, 一切都很好。停电怎么办？如果 Redis 配置为 (默认情况下) 每秒在磁盘上同步一, , 则重新启动, , 我们的密钥可能会丢失。从理论上, , 如果我们想在面对任何类型的实例重启时保证锁的安全, , 我们需要启用`fsync=always`在持久性设置中。由于额外的同步开, , 这将影响性能。

然而, 事情比乍一看要好。基本上
只要实例在
崩溃, 它不再参与任何**当前处于活动状态**锁。 这意味着
实例重新启动时的当前活动锁定集全部获得
通过锁定重新加入系统的实例以外的实例。

为了保证这一点, 我们只需要在崩溃后使一个实例不可用
至少比最大值多一点`TTL`我们使用。 这是所需的时间
对于实例崩溃时存在的有关锁的所有键
变为无效并自动释放。

用*延迟重新启动*基本上可以实现安全甚至
没有任何可用的 Redis 持久性, 但请注意, 这可能
转化为可用性损失。例如, 如果大多数实例
崩溃, 系统将变得全局不可用`TTL` (此处全球意味着
在此期间, 根本没有资源是可锁定的) 。

### 使算法更可靠：扩展锁

如果客户执行的工作由小步骤组成, 则可以
默认情况下使用较小的锁定有效期, 并扩展算法实现
锁定扩展机制。基本上是客户端, 如果在中间
当锁效率接近低值时进行计算, 可能会延长
通过将 Lua 脚本发送到扩展密钥 TTL 的所有实例来锁定
如果密钥存在, 并且其值仍然是客户端分配的随机值
获取锁的时间。

客户端应该只考虑重新获取锁, 如果它能够扩展
锁定到大多数实例中, 并在有效期内
 (基本上要使用的算法与获取时使用的算法非常相似
锁) 。

但是, 这在技术上不会改变算法, 因此最大数量
的锁重新获取尝试应受到限制, 否则其中一个活动
违反了属性。

## 想帮忙吗？

如果您喜欢分布式系统, 那么拥有您的意见/分析会很棒。此外, 其他语言的引用实现可能很棒。

提前致谢！

## 红锁分析

***

1.  马丁·克莱普曼[在这里分析了雷德洛克](http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html).与此分析的对应点可以是[在这里找到](http://antirez.com/news/101).
