Redis并不完全是键值存储，因为值可以是复杂的数据结构。但是，它有一个外部键值 shell：在 API 级别，数据由键名寻址。公平地说，从本质上讲，Redis只提供*主键访问*.但是，由于 Redis 是一个数据结构服务器，因此其功能可用于索引，以便创建不同类型的二级索引，包括复合（多列）索引。

本文档介绍如何使用以下数据结构在 Redis 中创建索引：

*   排序集，用于按 ID 或其他数值字段创建二级索引。
*   具有词典范围的排序集，用于创建更高级的二级索引、复合索引和图形遍历索引。
*   用于创建随机索引的集合。
*   用于创建简单可迭代索引和最后 N 个项目索引的列表。

使用 Redis 实现和维护索引是一个高级主题，因此大多数
需要对数据执行复杂查询的用户应该了解他们是否
由关系存储更好地提供服务。但是经常，特别是在缓存中
在某些情况下，明确需要将索引数据存储到Redis中，以加快需要某种形式的索引才能执行的常见查询。

# 具有排序集的简单数字索引

您可以使用 Redis 创建的最简单的二级索引是使用
排序集数据类型，它是表示一组
元素按浮点数排序，浮点数为*得分*之
每个元素。元素按从最小到最高分数的顺序排列。

由于分数是双精度浮点数，因此可以使用
香草排序集仅限于索引字段为数字的内容
在给定范围内。

用于构建此类索引的两个命令是`ZADD`和
`ZRANGEBYSCORE`分别添加项目和检索项目
指定范围。

例如，可以按其索引一组人名
通过将元素添加到排序集来年限。该元素将是
人和分数将是年龄。

    ZADD myindex 25 Manuel
    ZADD myindex 18 Anna
    ZADD myindex 35 Jon
    ZADD myindex 67 Helen

为了检索所有年龄在20至40岁之间的人员，请执行以下操作：
命令可以使用：

    ZRANGEBYSCORE myindex 20 40
    1) "Manuel"
    2) "Jon"

通过使用**得分**选项`ZRANGEBYSCORE`它也是可能的
以获取与返回的元素关联的分数。

这`ZCOUNT`命令可用于检索元素的数量
在给定的范围内，而不实际获取元素，这也是
很有用，特别是考虑到操作以对数执行的事实
时间与范围的大小无关。

范围可以是包容性的，也可以是排他性的，请参阅`ZRANGEBYSCORE`
命令文档以了解更多信息。

**注意**：使用`ZREVRANGEBYSCORE`可以查询
反转顺序，当数据在给定的索引中时通常很有用
方向（升序或降序），但我们想要检索信息
反之亦然。

## 使用对象 ID 作为关联值

在上面的例子中，我们将名称与年龄相关联。然而，总的来说，我们
可能想要索引存储在其他位置的对象的某些字段。
而不是直接使用排序的设置值来存储关联的数据
使用索引字段，可以仅存储对象的ID。

例如，我可能有代表用户的Redis哈希。每个用户都是
由单个密钥表示，可通过 ID 直接访问：

    HMSET user:1 id 1 username antirez ctime 1444809424 age 38
    HMSET user:2 id 2 username maria ctime 1444808132 age 42
    HMSET user:3 id 3 username jballard ctime 1443246218 age 33

如果我想创建一个索引以便按年龄查询用户，我
可以做到：

    ZADD user.age.index 38 1
    ZADD user.age.index 42 2
    ZADD user.age.index 33 3

这一次，与排序集中的分数关联的值为
对象的 ID。所以一旦我查询索引`ZRANGEBYSCORE`我会
还必须检索我需要的信息`HGETALL`或类似
命令。明显的优点是物体可以在不接触的情况下改变
索引，只要我们不更改索引字段即可。

在接下来的示例中，我们几乎总是使用 ID 作为与
索引，因为这通常是更合理的设计，有一些
异常。

## 更新简单排序集索引

我们经常对随时间变化的事物进行索引。在上面
例如，用户的年龄每年都在变化。在这种情况下，它将
使用出生日期作为索引而不是年龄本身是有意义的，
但是在其他情况下，我们只是希望某些字段从
时不时地，而指数反映了这一变化。

这`ZADD`命令使更新简单索引成为一项非常简单的操作
因为重新添加回具有不同分数和相同值的元素
只需更新分数并将元素移动到正确的位置，
因此，如果用户`antirez`年满39岁，为了更新
哈希值中的数据表示用户，索引中也需要
以执行以下两个命令：

    HSET user:1 age 39
    ZADD user.age.index 39 1

该操作可以包装在`MULTI`/`EXEC`交易，以便
确保两个字段都已更新或未更新。

## 将多维数据转换为线性数据

使用排序集创建的索引只能为单个数字编制索引
价值。因此，您可能会认为不可能索引某些内容
使用这种索引具有多个维度，但实际上这是
并不总是正确的。如果你能有效地代表某事
以线性方式进行多维，它们通常可以使用简单的
用于索引的排序集。

例如[Redis geo indexing API](/commands/geoadd)使用已排序
设置为按纬度和经度对地点进行索引，使用一种名为
[地理哈希](https://en.wikipedia.org/wiki/Geohash).排序的集合分数
表示经度和纬度的交替位，以便我们映射
排序集的线性分数为许多小*二 乘*在地球表面。
通过进行8 + 1风格中心加社区搜索，可以
按半径检索元素。

## 分数限制

排序集元素分数是双精度浮点数。这意味着
它们可以表示具有不同值的不同十进制或整数值
错误，因为它们在内部使用指数表示。
然而，对于索引目的来说，有趣的是分数是
始终能够在 -9007199254740992 之间表示没有任何错误号
和9007199254740992，这是`-/+ 2^53`.

当表示更大的数字时，您需要一种不同形式的索引
能够以任何精度索引数字，称为词典编纂
指数。

# 词典索引

Redis 排序集有一个有趣的属性。添加元素时
使用相同的分数，它们按字典顺序排序，比较
字符串作为二进制数据，带有`memcmp()`功能。

对于那些不懂C语言的人，也不懂`memcmp`功能，什么
这意味着具有相同分数的元素通过比较
其字节的原始值，一个字节接一个字节。如果第一个字节相同，
第二个是检查的，依此类推。如果两个字符串的公共前缀为
相同，那么较长的字符串被认为是两者中较大的一个，
所以“foobar”比“foo”大。

有命令，例如`ZRANGEBYLEX`和`ZLEXCOUNT`那
能够以字典方式查询和计数范围，假设
它们与排序集一起使用，其中所有元素都具有相同的分数。

此 Redis 功能基本上等效于`b-tree`数据结构
通常用于使用传统数据库实现索引。
正如您可以猜到的，因此，可以使用此Redis数据
结构，以实现相当花哨的索引。

在我们开始使用词典索引之前，让我们检查一下如何
排序集在此特殊操作模式下的行为。因为我们需要
添加相同分数的元素，我们将始终使用特殊分数
零。

    ZADD myindex 0 baaa
    ZADD myindex 0 abbb
    ZADD myindex 0 aaaa
    ZADD myindex 0 bbbb

从排序集中获取所有元素会立即显示它们
按字典顺序排列。

    ZRANGE myindex 0 -1
    1) "aaaa"
    2) "abbb"
    3) "baaa"
    4) "bbbb"

现在我们可以使用`ZRANGEBYLEX`为了执行范围查询。

    ZRANGEBYLEX myindex [a (b
    1) "aaaa"
    2) "abbb"

请注意，在范围查询中，我们以`min`和`max`元素
使用特殊字符标识范围`[`和`(`.
此前缀是必需的，它们指定元素
的范围是包含性的或排他性的。所以范围`[a (b`意味着给我
所有元素在词典之间`a`包容性和`b`独家
这些都是以`a`.

还有两个特殊字符表示无限负数
字符串和无限正字符串，它们是`-`和`+`.

    ZRANGEBYLEX myindex [b +
    1) "baaa"
    2) "bbbb"

基本上就是这样。让我们看看如何使用这些功能来构建索引。

## 第一个示例：完成

索引的一个有趣的应用是完成。完成是什么
当您开始在搜索引擎中键入查询时发生：用户
界面将预测您可能键入的内容，提供通用
以相同字符开头的查询。

一种幼稚的完成方法是只添加我们每个查询
从用户获取到索引。例如，如果用户搜索`banana`
我们只会做：

    ZADD myindex 0 banana

对于遇到的每个搜索查询，依此类推。然后当我们想要时
完成用户输入，我们使用范围查询`ZRANGEBYLEX`.
想象一下，用户在搜索表单中键入“bit”，而我们希望
提供以“位”开头的可能的搜索关键字。我们向 Redis 发送一个命令
诸如此类：

    ZRANGEBYLEX myindex "[bit" "[bit\xff"

基本上，我们使用用户现在正在键入的字符串创建一个范围
作为开始，并且相同的字符串加上设置为 255 的尾随字节，即`\xff`在示例中，作为范围的末尾。这样，我们就可以获取从用户键入的字符串开始的所有字符串。

请注意，我们不希望返回太多项目，因此我们可以使用**限制**选项以减少结果数。

## 在混音中添加频率

上面的方法有点幼稚，因为所有的用户搜索都是一样的。
以这种方式。在实际系统中，我们希望根据字符串完成它们
频率：非常热门的搜索将以更高的概率提出
与很少键入的搜索字符串相比。

为了实现一些取决于频率的东西，并且在
同时自动适应未来的输入，通过清除搜索
都不再流行，我们可以用一个很简单的*流算法*.

首先，我们修改索引，以便不仅存储搜索词，
还有与该术语相关的频率。因此，而不是仅仅添加
`banana`我们添加`banana:1`，其中 1 是频率。

    ZADD myindex 0 banana:1

我们还需要逻辑，以便在搜索词时递增索引
已经存在于索引中，因此我们实际要执行的操作类似于
那：

    ZRANGEBYLEX myindex "[banana:" + LIMIT 0 1
    1) "banana:1"

这将返回`banana`如果它存在。然后我们
可以增加关联的频率并发送以下两个
命令：

    ZREM myindex 0 banana:1
    ZADD myindex 0 banana:2

请注意，由于可能存在并发更新，因此
以上三个命令应通过[Lua 脚本](/commands/eval)
相反，因此 Lua 脚本将原子地获取旧计数和
重新添加分数递增的项目。

因此，结果将是，每次用户搜索`banana`我们将
更新我们的条目。

还有更多：我们的目标是非常频繁地搜索项目。
因此，我们需要某种形式的清除。当我们实际查询索引时
为了完成用户输入，我们可能会看到类似下面的内容：

    ZRANGEBYLEX myindex "[banana:" + LIMIT 0 10
    1) "banana:123"
    2) "banaooo:1"
    3) "banned user:49"
    4) "banning:89"

例如，显然没有人搜索“banaooo”，但查询是
执行了一次，因此我们最终将其呈现给用户。

这是我们能做的。从退回的物品中，我们随机选择一个，
将其分数递减 1，然后用新分数重新添加。
但是，如果分数达到 0，我们只需从列表中删除该项目即可。
您可以使用更高级的系统，但这个想法是索引在
长期运行将包含热门搜索，如果热门搜索将改变
它会自动适应的时间。

对此算法的改进是根据
它们的权重：分数越高，被选中的条目的可能性就越小
为了减少其分数，或驱逐它们。

## 规范化大小写和重音符号的字符串

在完成示例中，我们始终使用小写字符串。然而
现实远比这更复杂：语言有大写的名字，
口音，等等。

处理此问题的一种简单方法是实际规范化
字符串用户搜索。无论用户搜索“香蕉”是什么，
“香蕉”或“Ba'nana”我们可能总是把它变成“香蕉”。

但是，有时我们可能希望向用户展示原始内容
item 类型化，即使我们规范化字符串以进行索引。为了
这样做，我们所做的是更改索引的格式，以便改为
只是存储`term:frequency`我们商店`normalized:frequency:original`
如以下示例所示：

    ZADD myindex 0 banana:273:Banana

基本上，我们添加了另一个字段，我们将提取并仅用于
可视化。范围将始终使用规范化字符串进行计算
相反。这是一个具有多个应用程序的常见技巧。

## 在索引中添加辅助信息

当以直接方式使用排序集时，我们有两个不同的属性
对于每个对象：分数，我们将其用作索引，以及关联的分数
价值。改用词典索引时，分数始终为
设置为 0，基本上根本不使用。我们只剩下一根弦，
这是元素本身。

就像我们在之前的完成示例中所做的那样，我们仍然能够
使用分隔符存储关联的数据。例如，我们在
以添加频率和原始单词以完成。

通常，我们可以向索引键添加任何类型的关联值。
为了使用词典索引来实现简单的键值存储
我们只是将条目存储为`key:value`:

    ZADD myindex 0 mykey:myvalue

并使用以下项搜索密钥：

    ZRANGEBYLEX myindex [mykey: + LIMIT 0 1
    1) "mykey:myvalue"

然后，我们提取冒号后面的部分以检索值。
但是，在这种情况下要解决的问题是碰撞。冒号字符
可能是密钥本身的一部分，因此必须选择它才能从不
与我们添加的键冲突。

由于 Redis 中的词典编纂范围是二进制安全的，因此您可以使用任何
字节或任何字节序列。但是，如果您收到不受信任的用户
输入，最好使用某种形式的转义来保证
分隔符永远不会碰巧是密钥的一部分。

例如，如果使用两个空字节作为分隔符`"\0\0"`，您可以
希望始终将空字节转义为字符串中的两个字节序列。

## 数值填充

词典索引可能只有在手头的问题时才看起来不错
是要为字符串编制索引。实际上使用这种索引非常简单
以便对任意精度数字执行索引。

在 ASCII 字符集中，数字按 0 到 9 的顺序显示，因此
如果我们用前导零的左键数字，结果是比较
它们作为字符串将按其数值对它们进行排序。

    ZADD myindex 0 00324823481:foo
    ZADD myindex 0 12838349234:bar
    ZADD myindex 0 00000000111:zap

    ZRANGE myindex 0 -1
    1) "00000000111:zap"
    2) "00324823481:foo"
    3) "12838349234:bar"

我们有效地使用数字字段创建了一个索引，该数字字段可以
我们想要的又大。这也适用于任何精度的浮点数
通过确保我们用前导零和
带有尾随零的小数部分，如以下数字列表所示：

        01000000000000.11000000000000
        01000000000000.02200000000000
        00000002121241.34893482930000
        00999999999999.00000000000000

## 以二进制形式使用数字

以十进制存储数字可能会占用太多内存。另一种方法
只是为了存储数字，例如128位整数，直接在他们的
二进制形式。但是，要使此操作起作用，您需要将数字存储在
*大端格式*，以便将最高有效字节存储在之前
最低有效字节。这样，当 Redis 将字符串与
`memcmp()`，它将有效地按其值对数字进行排序。

请记住，以二进制格式存储的数据对于
调试，更难解析和导出。所以这绝对是一种权衡。

# 复合索引

到目前为止，我们探索了为单个字段编制索引的方法。然而，我们都知道
SQL 存储能够使用多个字段创建索引。例如
我可能会按房间号和价格在非常大的商店中索引产品。

我需要运行查询才能检索给定中的所有产品
房间有给定的价格范围。我能做的是索引每个产品
通过以下方式：

    ZADD myindex 0 0056:0028.44:90
    ZADD myindex 0 0034:0011.00:832

这里的字段是`room:price:product_id`.我只用了四位数的填充
为简单起见，在示例中。辅助数据（产品 ID）不
需要任何填充。

使用这样的索引，可以让56号房间的所有产品都有价格
10到30美元之间非常容易。我们可以运行以下内容
命令：

    ZRANGEBYLEX myindex [0056:0010.00 [0056:0030.00

上述内容称为组合索引。其有效性取决于
要运行的字段和查询的顺序。例如，上面的
索引不能有效地使用，以便使所有产品具有
一个特定的价格范围，无论房间号如何。但是我可以使用
主键，以便运行查询而不考虑价格，例如
*给我44号房间的所有产品*.

复合索引非常强大，用于传统商店
为了优化复杂的查询。在Redis中，它们可能既有用又有用
实现非常快速的内存中 Redis 索引，将存储到
传统的数据存储，或者为了直接索引 Redis 数据。

# 更新词典索引

词典索引中索引的值可能会变得非常花哨
并且很难或缓慢地从我们存储的有关对象的内容中重建。所以一个
简化索引处理的方法，代价是使用更多
内存，也是为了与表示索引的排序集一起
将对象 ID 映射到当前索引值的哈希值。

例如，当我们编制索引时，我们还会添加到哈希值中：

    MULTI
    ZADD myindex 0 0056:0028.44:90
    HSET index.content 90 0056:0028.44:90
    EXEC

这并不总是必需的，但简化了更新操作
索引。为了删除旧信息，我们为对象编制了索引
ID 90，无论*当前*字段对象的值，我们只是
必须按对象 ID 检索哈希值，并且`ZREM`它在排序
设置视图。

# 使用六元存储表示和查询图形

关于复合索引的一个很酷的事情是它们很方便
来表示图形，使用称为
[六合一店](http://www.vldb.org/pvldb/vol1/1453965.pdf).

六元存储为对象之间的关系提供了表示形式，
由*主题*一个*谓语*和*对象*.
对象之间的简单关系可以是：

    antirez is-friend-of matteocollina

为了表示这种关系，我可以存储以下元素
在我的词典索引中：

    ZADD myindex 0 spo:antirez:is-friend-of:matteocollina

请注意，我在项目前面加上了字符串**断续器**.这意味着
该项表示主语，谓词，宾语关系。

In 可以为同一关系再添加 5 个条目，但顺序不同：

    ZADD myindex 0 sop:antirez:matteocollina:is-friend-of
    ZADD myindex 0 ops:matteocollina:is-friend-of:antirez
    ZADD myindex 0 osp:matteocollina:antirez:is-friend-of
    ZADD myindex 0 pso:is-friend-of:antirez:matteocollina
    ZADD myindex 0 pos:is-friend-of:matteocollina:antirez

现在事情开始变得有趣，我可以查询许多图表
不同的方式。例如，谁是所有人`antirez`
*是朋友*?

    ZRANGEBYLEX myindex "[spo:antirez:is-friend-of:" "[spo:antirez:is-friend-of:\xff"
    1) "spo:antirez:is-friend-of:matteocollina"
    2) "spo:antirez:is-friend-of:wonderwoman"
    3) "spo:antirez:is-friend-of:spiderman"

或者，所有的关系是什么`antirez`和`matteocollina`有的地方
第一个是主体，第二个是客体？

    ZRANGEBYLEX myindex "[sop:antirez:matteocollina:" "[sop:antirez:matteocollina:\xff"
    1) "sop:antirez:matteocollina:is-friend-of"
    2) "sop:antirez:matteocollina:was-at-conference-with"
    3) "sop:antirez:matteocollina:talked-with"

通过组合不同的查询，我可以提出一些花哨的问题。例如：
*谁是我的朋友，像啤酒一样，住在巴塞罗那，马泰奥科利纳也认为是朋友？*
为了获得这些信息，我从一个`spo`查询以查找所有人员
我是朋友。然后，对于我得到的每个结果，我执行一个`spo`查询
检查他们是否喜欢啤酒，删除我找不到的啤酒
这种关系。我再次这样做以按城市过滤。最后我执行一个`ops`
查询查找，我得到的名单，谁被认为是朋友
马特奥科利纳。

请务必检查[Matteo Collina关于Levelgraph的幻灯片](http://nodejsconfit.levelgraph.io/)为了更好地理解这些想法。

# 多维索引

更复杂的索引类型是允许您执行查询的索引
其中，同时查询两个或多个变量以获取特定变量
范围。例如，我可能有一个表示人年龄和
薪水，我想找回所有50到55岁之间的人
薪水在70000到85000之间。

可以使用多列索引执行此查询，但这需要
我们选择第一个变量，然后扫描第二个变量，这意味着我们
可能会做比需要的更多的工作。可以执行这些类型的
涉及使用不同数据结构的多个变量的查询。
例如，多维树，例如*k-d 树*或*r 树*或+
有时使用。在这里，我们将介绍一种将数据索引到的另一种方法
多个维度，使用允许我们执行的表示技巧
使用 Redis 词典范围以非常有效的方式进行查询。

假设我们在空间中有点，这些点表示我们的数据样本，其中`x`和`y`是我们的坐标。这两个变量的最大值为 400。

在下图中，蓝色框表示我们的查询。我们想要所有点`x`介于 50 和 100 之间，并且其中`y`介于 100 和 300 之间。

![Points in the space](../../../images/2idx\_0.png)

为了表示使这些类型的查询快速执行的数据，
我们从用0填充我们的数字开始。例如，想象我们想要
将点 10，25 （x，y） 添加到我们的索引中。给定
例子是400，我们可以只填充到三位数字，所以我们得到：

    x = 010
    y = 025

现在我们要做的是交错数字，取最左边的数字
在 x 中，在 y 中最左边的数字，依此类推，以创建单个
数：

    001205

这是我们的索引，但是为了更容易地重建原始
表示，如果我们愿意（以空间为代价），我们也可以添加
作为附加列的原始值：

    001205:10:25

现在，让我们来推理一下这个表示，以及为什么它在
范围查询的上下文。例如，让我们以蓝色的中心为例
框，它位于`x=75`和`y=200`.我们可以像我们一样对此数字进行编码
通过交错数字，得到：

    027050

如果我们分别用00和99替换最后两位数字会发生什么？
我们得到一个在词典上连续的范围：

    027000 to 027099

这映射到一个正方形，表示所有值，其中`x`
变量介于 70 和 79 之间，并且`y`变量介于 200 和 209 之间。
为了识别这个特定区域，我们可以在该区间内写入随机点。

![Small area](../../../images/2idx\_1.png)

因此，上面的词典查询使我们能够轻松地查询
图片中的特定正方形。但是，正方形可能太小了
我们正在搜索的框，因此需要太多的查询。
因此，我们可以做同样的事情，但不是将最后两位数字替换为00
和99，我们可以对最后四位数字进行操作，获得以下内容
范围：

    020000 029999

这一次，范围表示所有点，其中`x`介于 0 和 99 之间
和`y`介于 200 和 299 之间。在此区间内绘制随机点
向我们展示了这个更大的区域。

![Large area](../../../images/2idx\_2.png)

所以现在我们的区域对于我们的查询来说太大了，而且我们的搜索框仍然是
不完全包括在内。我们需要更多的粒度，但我们可以很容易地获得
它通过以二进制形式表示我们的数字。这一次，当我们更换
数字而不是得到十倍大的正方形，我们得到平方
它们只是大两倍。

二进制形式的数字，假设每个变量只需要9位
（为了表示值高达400的数字）将是：

    x = 75  -> 001001011
    y = 200 -> 011001000

因此，通过交错数字，我们在索引中的表示形式将是：

    000111000011001010:75:200

让我们看看我们的范围是什么，因为我们替换了最后2，4，6，8，...
在交错表示中具有 0s ad 1s 的位：

    2 bits: x between 74 and 75, y between 200 and 201 (range=2)
    4 bits: x between 72 and 75, y between 200 and 203 (range=4)
    6 bits: x between 72 and 79, y between 200 and 207 (range=8)
    8 bits: x between 64 and 79, y between 192 and 207 (range=16)

等等。现在我们肯定有更好的粒度！
如您所见，从索引中替换N位可以给我们
搜索侧面框`2^(N/2)`.

因此，我们要做的是检查搜索框较小的维度，
并检查与此数字最接近的 2 的幂。我们的搜索框
是50，100到100，300，所以它的宽度为50，高度为200。
我们取两者中较小的一个，50，并检查两个最接近的幂
这是64。64 是 2^6，因此我们将使用获得的索引替换
交错表示中最新的 12 位（以便我们结束
仅替换每个变量的 6 位）。

但是，单个正方形可能无法覆盖我们所有的搜索，因此我们可能需要更多。
我们要做的是从搜索框的左下角开始，
即 50，100，并通过替换最后 6 位来查找第一个范围
在每个数字中，带 0。然后，我们对右上角执行相同的操作。

使用两个平凡嵌套的 for 循环，其中我们仅递增显著的
位，我们可以找到这两者之间的所有方块。对于每个正方形，我们
将两个数字转换为我们的交错表示，并创建
使用转换后的表示形式作为起点的范围，并且相同
表示，但最新的 12 位作为结束范围打开。

对于找到的每个正方形，我们执行查询并获取其中的元素，
删除我们搜索框之外的元素。

将其转换为代码很简单。下面是一个 Ruby 示例：

    def spacequery(x0,y0,x1,y1,exp)
        bits=exp*2
        x_start = x0/(2**exp)
        x_end = x1/(2**exp)
        y_start = y0/(2**exp)
        y_end = y1/(2**exp)
        (x_start..x_end).each{|x|
            (y_start..y_end).each{|y|
                x_range_start = x*(2**exp)
                x_range_end = x_range_start | ((2**exp)-1)
                y_range_start = y*(2**exp)
                y_range_end = y_range_start | ((2**exp)-1)
                puts "#{x},#{y} x from #{x_range_start} to #{x_range_end}, y from #{y_range_start} to #{y_range_end}"

                # Turn it into interleaved form for ZRANGEBYLEX query.
                # We assume we need 9 bits for each integer, so the final
                # interleaved representation will be 18 bits.
                xbin = x_range_start.to_s(2).rjust(9,'0')
                ybin = y_range_start.to_s(2).rjust(9,'0')
                s = xbin.split("").zip(ybin.split("")).flatten.compact.join("")
                # Now that we have the start of the range, calculate the end
                # by replacing the specified number of bits from 0 to 1.
                e = s[0..-(bits+1)]+("1"*bits)
                puts "ZRANGEBYLEX myindex [#{s} [#{e}"
            }
        }
    end

    spacequery(50,100,100,300,6)

虽然不是立即平凡的，但这是一个非常有用的索引策略，
将来可能会在Redis中以原生方式实现。
就目前而言，好处是复杂性可以很容易地封装起来。
在可用于执行索引和查询的库中。
此类库的一个示例是[Redimension](https://github.com/antirez/redimension)，这是一个概念证明 Ruby 库，它使用此处描述的技术对 Redis 内部的 N 维数据进行索引。

# 具有负数或浮点数的多维索引

表示负值的最简单方法是使用无符号
整数并使用偏移量表示它们，以便在编制索引时，在
在索引表示中转换数字，将绝对值相加
较小的负整数。

对于浮点数，最简单的方法可能是转换它们
通过将整数乘以与
要保留的点后面的位数。

# 非范围索引

到目前为止，我们检查了按范围或单个查询的有用索引
项目。但是，可以使用其他 Redis 数据结构，如集或列表
为了构建其他类型的索引。它们非常常用，但
也许我们并不总是意识到它们实际上是索引的一种形式。

例如，我可以将对象 ID 索引为 Set 数据类型，以便使用
这*获取随机元素*操作方式`SRANDMEMBER`为了检索
一组随机对象。集合还可用于在以下情况下检查是否存在
我需要做的就是测试给定的项目是否存在或具有单个布尔值
属性与否。

同样，可以使用列表将项目索引为固定顺序。
我可以将所有项目添加到 Redis 列表中，并旋转列表
`RPOPLPUSH`使用与源和目标相同的键名。这很有用
当我想在
相同的顺序。考虑一个需要刷新本地副本的 RSS 源系统
周期性地。

另一个经常与Redis一起使用的流行索引是**封顶列表**，其中项目
添加`LPUSH`并修剪`LTRIM`，以便创建视图
只有遇到的最新N个项目，它们的顺序相同
明显。

# 索引不一致

在几个月内保持索引更新可能具有挑战性
或年份，可能会因为软件而添加不一致
错误、网络分区或其他事件。

可以使用不同的策略。如果索引数据位于 Redis 之外
*读取修复*可以是一个解决方案，其中数据以懒惰的方式固定，当
它是请求的。当我们索引存储在Redis本身中的数据时
这`SCAN`可以使用命令系列进行验证、更新或
从头开始以增量方式重建索引。
