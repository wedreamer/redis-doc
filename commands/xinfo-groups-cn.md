此命令返回存储在`<key>`.

默认情况下，仅为每个组提供以下信息：

*   **名字**：消费者群体的名称
*   **消费者**：组中的消费者数量
*   **待定**：组的待处理条目列表 （PEL） 的长度，这些条目列表是已传递但尚未确认的邮件
*   **上次交付的 ID**：最后一个条目的 ID 已交付组的使用者
*   **条目读取**：传递给组使用者的最后一个条目的逻辑“读取计数器”
*   **滞后**：流中仍在等待传递给组使用者的条目数，如果无法确定该数字，则为 NULL。

### 消费者群体滞后

给定使用者组的滞后是该组的`entries_read`和流的`entries_added`.
换句话说，它是尚未交付给组消费者的条目数量。

此指标的值和趋势有助于做出有关使用者组的缩放决策。
您可以通过向组添加更多使用者来解决高滞后值，而低值可能表示您可以从组中删除使用者以缩小其规模。

Redis 通过保留两个计数器来报告使用者组的滞后：添加到流中的所有条目数和使用者组进行的逻辑读取数。
滞后是这两者之间的区别。

流的计数器（`entries_added`的领域`XINFO STREAM`命令） 递增 1，每`XADD`并计算在流生存期内添加到流中的所有条目。

消费组的柜台，`entries_read`是组已读取的条目的逻辑计数器。
重要的是要注意，此计数器只是一个启发式计数器，而不是一个准确的计数器，因此使用了术语“逻辑”。
计数器尝试反映组的条目数**应该阅读**以达到其当前`last-delivered-id`.
这`entries_read`计数器仅在完美世界中是准确的，其中消费者组从流的第一个条目开始并处理其所有条目（即，在处理之前没有删除任何条目）。

在两种特殊情况下，此机制无法报告滞后：

1.  使用任意上次传送的 ID 创建或设置使用者组（`XGROUP CREATE`和`XGROUP SETID`命令）。
    任意 ID 是指不是流的第一个条目、其最后一个条目或零 （“0-0”） ID 的 ID 的任何 ID。
2.  组之间的一个或多个条目`last-delivered-id`和流的`last-generated-id`已删除（使用`XDEL`或修剪操作）。

在这两种情况下，组的读取计数器都被视为无效，并且返回的值设置为 NULL 以指示滞后当前不可用。

但是，延迟只是暂时不可用。
它在常规操作期间自动恢复，因为使用者继续处理消息。
一旦使用者组将流中的最后一条消息传递给其成员，它将使用正确的逻辑读取计数器进行设置，并且可以恢复跟踪其延迟。

@reply

@array回复：消费者群体列表。

@examples

    > XINFO GROUPS mystream
    1)  1) "name"
        2) "mygroup"
        3) "consumers"
        4) (integer) 2
        5) "pending"
        6) (integer) 2
        7) "last-delivered-id"
        8) "1638126030001-0"
        9) "entries-read"
       10) (integer) 2
       11) "lag"
       12) (integer) 0
    2)  1) "name"
        2) "some-other-group"
        3) "consumers"
        4) (integer) 1
        5) "pending"
        6) (integer) 0
        7) "last-delivered-id"
        8) "1638126028070-0"
        9) "entries-read"
       10) (integer) 1
       11) "lag"
       12) (integer) 1
