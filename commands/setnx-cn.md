设置`key`以保存字符串`value`如果`key`不存在。
在这种情况下, 它等于`SET`.
什么时候`key`已持有值, 不执行任何操作。
`SETNX`是”**设置**如果**N**ot e**X**ists”。

@return

@integer回复, 具体而言：

*   `1`如果设置了密钥
*   `0`如果未设置密钥

@examples

```cli
SETNX mykey "Hello"
SETNX mykey "World"
GET mykey
```

## 设计模式：锁定`!SETNX`

**请注意：**

1.  不鼓励以下模式, 以支持[红锁算法](https://redis.io/topics/distlock)它的实现稍微复杂一些, 但提供了更好的保证并且是容错的。
2.  无论如何, 我们都会记录旧模式, 因为某些现有实现链接到此页面作为参考。此外, 这是一个有趣的例子, 说明如何使用Redis命令来挂载编程基元。
3.  无论如何, 即使假设一个单实例锁定原语, 从2.6.12开始, 也可以创建一个更简单的锁定原语, 相当于这里讨论的那个, 使用`SET`命令来获取锁, 以及一个简单的 Lua 脚本来释放锁。该模式记录在`SET`命令页。

可是`SETNX`可以使用, 并且在历史上被用作锁定原语。例如, 获取锁的钥匙`foo`, 客户端可以尝试
以后：

    SETNX lock.foo <current Unix time + lock timeout + 1>

如果`SETNX`返回`1`客户端获取了锁, 将`lock.foo`钥匙
到 Unix 时间, 在该时间, 锁不应再被视为有效。
客户端稍后将使用`DEL lock.foo`为了释放锁。

如果`SETNX`返回`0`密钥已被其他客户端锁定。
如果它是非阻塞锁, 我们可以返回给调用方, 也可以进入循环
重试保持锁定, 直到我们成功或某种超时到期。

### 处理死锁

在上面的锁定算法中存在一个问题：如果客户端会发生什么
失败、崩溃或无法释放锁？
可以检测到这种情况, 因为锁定键包含 UNIX
时间戳。
如果这样的时间戳等于当前的Unix时间, 则锁定不再
有效。

当这种情况发生时, 我们不能只是打电话`DEL`对着钥匙去掉锁
然后尝试发出`SETNX`, 因为这里有一个竞态条件, 当
多个客户端检测到过期的锁, 并正在尝试释放它。

*   C1 和 C2 读取`lock.foo`检查时间戳, 因为他们都收到了
    `0`执行后`SETNX`, 因为锁仍然被崩溃的C3持有
    握住锁后。
*   C1 发送`DEL lock.foo`
*   C1 发送`SETNX lock.foo`它成功了
*   C2 发送`DEL lock.foo`
*   C2 发送`SETNX lock.foo`它成功了
*   **错误**：由于争用条件, C1 和 C2 都获得了锁。

幸运的是, 可以使用以下算法避免此问题。
让我们看看我们理智的客户端 C4 是如何使用好的算法的：

*   C4 发送`SETNX lock.foo`为了获得锁

*   崩溃的客户端 C3 仍保留它, 因此 Redis 将使用`0`到 C4。

*   C4 发送`GET lock.foo`以检查锁是否过期。
    如果不是, 它将休眠一段时间, 然后从头开始重试。

*   相反, 如果锁定已过期, 因为 Unix 时间在`lock.foo`较旧
    比当前的 Unix 时间, C4 尝试执行：

        GETSET lock.foo <current Unix timestamp + lock timeout + 1>

*   由于`GETSET`语义上, C4可以检查旧值是否存储在
    `key`仍然是过期的时间戳。
    如果是, 则锁已获取。

*   如果另一个客户端 (例如 C5) 比 C4 更快并获取了锁
    与`GETSET`操作, C4`GETSET`操作将返回非
    过期的时间戳。
    C4 将简单地从第一步重新启动。
    请注意, 即使 C4 在将来的几秒钟内设置了密钥, 这也是
    没问题。

为了使这种锁定算法更加健壮, 一个
持有锁的客户端应始终检查超时之前未过期
解锁钥匙`DEL`因为客户端故障可能很复杂, 而不仅仅是
崩溃, 但也阻止了一些操作的大量时间并尝试
以发出`DEL`经过很多时间 (当锁已经被另一个人持有) ) 
客户端) 。
