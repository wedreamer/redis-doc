`BLPOP`是阻止列表弹出基元。
它是阻塞版本的`LPOP`因为它在存在时会阻止连接
没有要从任何给定列表中弹出的元素。
从第一个非空列表的头部弹出一个元素，其中
给定的密钥按照给定的顺序进行检查。

## 非阻塞行为

什么时候`BLPOP`如果至少一个指定的键包含
非空列表，从列表的头部弹出一个元素并返回到
呼叫者与`key`它是弹出的。

按提供密钥的顺序检查密钥。
假设关键`list1`不存在，并且`list2`和`list3`拿
非空列表。
请考虑以下命令：

    BLPOP list1 list2 list3 0

`BLPOP`保证从存储在`list2`（自
它是检查时的第一个非空列表`list1`,`list2`和`list3`在
该顺序）。

## 阻止行为

如果指定的键都不存在，`BLPOP`阻止连接，直到另一个连接
客户端执行`LPUSH`或`RPUSH`对其中一个键执行的操作。

一旦其中一个列表上存在新数据，客户端将返回名称
的键取消阻止它和弹出的值。

什么时候`BLPOP`导致客户端阻塞并指定非零超时，
客户端将取消阻止返回`nil`指定时的多批量值
超时已过期，没有对至少一个
指定的键。

**超时参数被解释为一个双精度值，指定要阻止的最大秒数**.超时值为零可用于无限期阻止。

## 首先提供什么密钥？什么客户？什么元素？优先级排序详细信息。

*   如果客户端尝试阻止多个键，但至少有一个键包含元素，则返回的键/元素对是从左到右的第一个键，其中包含一个或多个元素。在这种情况下，客户端不会被阻止。例如`BLPOP key1 key2 key3 key4 0`，假设两者兼而有之`key2`和`key4`为非空，将始终返回来自`key2`.
*   如果为同一密钥阻止了多个客户端，则要处理的第一个客户端是等待更多时间的客户端（第一个阻止密钥的客户端）。一旦客户端被解除阻止，当它再次被阻止时，它不会保留任何优先级，下次调用`BLPOP`它将根据同一密钥已阻止的客户端数量提供相应的服务，这些客户端将在它之前全部提供（从第一个到最后一个阻止）。
*   当客户端同时阻止多个密钥，并且元素在多个密钥中同时可用（由于事务或Lua脚本将元素添加到多个列表中），客户端将使用接收推送操作的第一个密钥解除阻止（假设它有足够的元素来为我们的客户端服务， 因为可能还有其他客户端也在等待此密钥）。基本上，在执行每个命令后，Redis将运行接收数据的所有密钥的列表，并且至少有一个客户端被阻止。该列表按新元素到达时间排序，从接收数据的第一个键到最后一个键。对于处理的每个密钥，只要此密钥中存在元素，Redis 就会以 FIFO 方式为所有等待该密钥的客户端提供服务。当密钥为空或不再有客户端等待此密钥时，将处理在上一个命令/事务/脚本中接收新数据的下一个密钥，依此类推。

## 的行为`!BLPOP`当多个元素被推送到列表中时。

有时，列表可以在同一概念命令的上下文中接收多个元素：

*   可变参数推送操作，例如`LPUSH mylist a b c`.
*   在`EXEC`的`MULTI`对同一列表执行多个推送操作的块。
*   使用 Redis 2.6 或更高版本执行 Lua 脚本。

当在客户端阻塞的列表内推送多个元素时，Redis 2.4 和 Redis 2.6 或更高版本的行为是不同的。

对于 Redis 2.6，执行多个推送的命令被执行，并且*仅在之后*执行命令，为被阻止的客户端提供服务。请考虑以下命令序列。

    Client A:   BLPOP foo 0
    Client B:   LPUSH foo a b c

如果使用 Redis 2.6 或更高版本的服务器时发生上述情况，则客户端**一个**将与`c`元素，因为在`LPUSH`列表包含的命令`c,b,a`，因此从左侧获取元素意味着返回`c`.

相反，Redis 2.4以不同的方式工作：为客户提供服务*在上下文中*的推送操作，所以只要`LPUSH foo a b c`开始将第一个元素推送到列表，它将被传递到客户端**一个**，则会收到`a`（推送的第一个元素）。

Redis 2.4 的行为在将数据复制或持久保存到 AOF 文件中时会产生很多问题，因此 Redis 2.6 中引入了更通用、语义更简单的行为来防止出现问题。

请注意，出于同样的原因，Lua 脚本或`MULTI/EXEC`块可能会将元素推入列表，然后再推送**删除列表**.在这种情况下，只要在执行单个命令、事务或脚本后列表中不存在任何数据，就不会为被阻止的客户端提供服务，并且将继续被阻止。

## `!BLPOP`在`!MULTI`/`!EXEC`交易

`BLPOP`可与流水线（发送多个命令和
批量阅读回复），但是此设置几乎完全有意义
当它是管道的最后一个命令时。

用`BLPOP`在`MULTI`/`EXEC`块没有多大意义
因为它需要阻止整个服务器才能执行块
原子，这反过来又不允许其他客户端执行推送
操作。因此，行为`BLPOP`里面`MULTI`/`EXEC`当列表为空时，返回`nil`多批量回复，这是相同的
达到超时时发生的情况。

如果你喜欢科幻小说，想想时间在里面以无限的速度流淌
`MULTI`/`EXEC`块。。。

@return

@array回复：具体而言：

*   一个`nil`当无法弹出任何元素并且超时过期时，多批量。
*   双元素多主体，第一个元素是键的名称
    其中，一个元素被弹出，第二个元素是
    弹出的元素。

@examples

    redis> DEL list1 list2
    (integer) 0
    redis> RPUSH list1 a b c
    (integer) 3
    redis> BLPOP list1 list2 0
    1) "list1"
    2) "a"

## 可靠的队列

什么时候`BLPOP`向客户端返回一个元素，它还从列表中删除该元素。这意味着该元素仅存在于客户端的上下文中：如果客户端在处理返回的元素时崩溃，它将永久丢失。

对于某些应用程序，这可能是一个问题，我们需要一个更可靠的消息传递系统。在这种情况下，请检查`BRPOPLPUSH`命令，即`BLPOP`在将返回的元素返回到客户端之前，将返回的元素添加到目标列表。

## 模式：事件通知

使用阻止列表操作，可以装载不同的阻止
原。
例如，对于某些应用程序，您可能需要阻止等待元素
到 Redis 集中，这样，只要将新元素添加到该集，它就是
可以在不诉诸轮询的情况下检索它。
这将需要一个阻塞版本的`SPOP`不可用，但使用
阻止列表操作我们可以轻松完成此任务。

消费者将做：

    LOOP forever
        WHILE SPOP(key) returns elements
            ... process elements ...
        END
        BRPOP helper_key
    END

在生产者方面，我们将简单地使用：

    MULTI
    SADD key element
    LPUSH helper_key x
    EXEC
