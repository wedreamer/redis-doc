将超时设置为`key`.
超时过期后，将自动删除密钥。
具有关联超时的密钥通常被认为是*挥发性的*（雷迪斯）
术语。

超时只能通过删除或覆盖
密钥的内容，包括`DEL`,`SET`,`GETSET`和所有`*STORE`
命令。
这意味着所有操作在概念上*改变*存储在 的值
如果不用新密钥替换密钥，则超时保持不变。
例如，递增键的值`INCR`，推动新值
进入列表`LPUSH`，或更改哈希的字段值`HSET`是
所有将保持超时不变的操作。

超时也可以清除，将密钥变回持久密钥，
使用`PERSIST`命令。

如果将密钥重命名为`RENAME`，则将关联的生存时间转移到
新密钥名称。

如果某个密钥被覆盖`RENAME`，例如在现有密钥的情况下`Key_A`
被类似`RENAME Key_B Key_A`，如果
原件`Key_A`是否关联了超时，新密钥`Key_A`将
继承所有特性`Key_B`.

请注意，呼叫`EXPIRE`/`PEXPIRE`非正超时或
`EXPIREAT`/`PEXPIREAT`与过去的时间将导致关键
[删除][del]而不是过期（相应地，发出[关键事件][ntf]
将是`del`不`expired`).

[del]: /commands/del

[ntf]: /topics/notifications

## 选项

这`EXPIRE`命令支持一组选项：

*   `NX`-- 仅当密钥没有过期时才设置过期时间
*   `XX`-- 仅当密钥具有现有到期时间时才设置到期时间
*   `GT`-- 仅当新到期时间大于当前到期时间时才设置到期时间
*   `LT`-- 仅当新的到期时间小于当前到期时间时才设置到期时间

非易失性密钥被视为无限 TTL，以便`GT`和`LT`.
这`GT`,`LT`和`NX`选项是互斥的。

## 刷新过期

可以调用`EXPIRE`使用已经具有
现有过期集。
在这种情况下，密钥的生存时间是*更新*添加到新值。
有许多有用的应用程序可用于此，一个示例记录在
*导航会话*下面的模式部分。

## 2.1.3 之前的 Redis 中的差异

在之前的 Redis 版本中**2.1.3**使用过期集更改具有过期集的密钥
命令更改其值具有完全删除密钥的效果。
之所以需要这种语义，是因为复制层的限制
现已修复。

`EXPIRE`将返回 0，并且不会更改具有超时集的密钥的超时。

@return

@integer回复，具体而言：

*   `1`如果设置了超时。
*   `0`如果未设置超时。例如.key不存在，或者由于提供的参数而跳过操作。

@examples

```cli
SET mykey "Hello"
EXPIRE mykey 10
TTL mykey
SET mykey "Hello World"
TTL mykey
EXPIRE mykey 10 XX
TTL mykey
EXPIRE mykey 10 NX
TTL mykey
```

## 模式：导航会话

假设您有一个 Web 服务，并且您对最新的 N 个页面感兴趣
*最近*您的用户访问过，使得每个相邻的页面视图都不是
在上一次之后进行了60秒以上。
从概念上讲，您可以将这组页面视图视为*导航会话*
，其中可能包含有关哪种类型的有趣信息
他或她目前正在寻找的产品，以便您可以推荐相关产品
产品。

您可以使用以下策略在 Redis 中轻松对此模式进行建模：每个
当用户执行页面视图时，您调用以下命令：

    MULTI
    RPUSH pagewviews.user:<userid> http://.....
    EXPIRE pagewviews.user:<userid> 60
    EXEC

如果用户空闲时间超过 60 秒，则密钥将被删除且仅
差异小于 60 秒的后续页面浏览量将为
记录。

此模式很容易修改为使用计数器`INCR`而不是列表
用`RPUSH`.

# 附录：Redis 已过期

## 过期的密钥

通常，Redis 密钥的创建没有关联的生存时间。
密钥将永远存在，除非用户在
显式方式，例如使用`DEL`命令。

这`EXPIRE`命令系列能够将过期与给定密钥相关联，
代价是密钥使用的一些额外内存。
当密钥设置了过期时，Redis 将确保在
指定的已用时间量。

可以使用`EXPIRE`和
`PERSIST`命令（或其他严格相关的命令）。

## 过期准确性

在 Redis 2.4 中，过期可能不准确，并且可能介于
从零到一秒。

自 Redis 2.6 起，过期错误介于 0 到 1 毫秒之间。

## 过期和持久性

过期信息的密钥存储为绝对 Unix 时间戳（以毫秒为单位）
在 Redis 版本 2.6 或更高版本的情况下）。
这意味着即使 Redis 实例未处于活动状态，时间也在流动。

为了使过期正常工作，必须稳定地使用计算机时间。
如果从两台时钟发生较大不同步的计算机上移动 RDB 文件，
可能会发生有趣的事情（例如加载的所有密钥在加载时都会过期
时间）。

即使正在运行的实例也始终会检查计算机时钟，因此例如，如果
设置一个生存时间为 1000 秒的密钥，然后设置计算机
时间 2000 秒，将来密钥将立即过期，而不是
持续1000秒。

## Redis 如何使密钥过期

Redis 密钥以两种方式过期：被动方式和主动方式。

密钥只是当某些客户端尝试访问它时被动过期，并且
发现键超时。

当然，这还不够，因为有些过期的密钥永远不会
再次访问。
无论如何，这些密钥都应该过期，因此 Redis 会定期测试一些密钥，
在具有过期集的密钥之间随机。
所有已过期的密钥都将从密钥空间中删除。

具体来说，这是Redis每秒做10次的事情：

1.  从具有关联过期的密钥集中测试 20 个随机密钥。
2.  删除所有发现已过期的密钥。
3.  如果超过 25% 的密钥已过期，请从步骤 1 重新开始。

这是一个微不足道的概率算法，基本上假设是我们的
样本代表了整个密钥空间，我们继续过期，直到
可能过期的密钥百分比低于 25%

这意味着在任何给定时刻，已过期的最大密钥数量
使用内存的最大等于每个内存的最大写入操作量
秒除以4。

## 如何在复制链接和 AOF 文件中处理过期

为了在不牺牲一致性的情况下获得正确的行为，当
密钥过期，一个`DEL`操作在 AOF 文件中合成，并获得所有
附加的副本节点。
这样，过期过程就集中在主实例中，并且在那里
没有一致性错误的机会。

但是，虽然连接到主服务器的副本不会使密钥过期
独立（但将等待`DEL`来自主人），他们会
仍然采取过期的完整状态存在于数据集中，因此当
复制副本被选为主控器，它将能够独立地使密钥过期，
完全扮演主人的角色。
