以原子方式返回并删除存储在
`source`, 并将元素推送到存储的列表的第一个元素 (头部) 
在`destination`.

例如：考虑`source`持有列表`a,b,c`和`destination`
持有列表`x,y,z`.
执行`RPOPLPUSH`结果`source`占有`a,b`和`destination`
占有`c,x,y,z`.

如果`source`不存在, 值`nil`返回, 并且没有操作
执行。
如果`source`和`destination`都是一样的, 操作等价于
从列表中删除最后一个元素, 并将其作为
list, 因此可以将其视为列表旋转命令。

@return

@bulk字符串回复：正在弹出和推送的元素。

@examples

```cli
RPUSH mylist "one"
RPUSH mylist "two"
RPUSH mylist "three"
RPOPLPUSH mylist myotherlist
LRANGE mylist 0 -1
LRANGE myotherlist 0 -1
```

## 模式：可靠队列

Redis通常用作消息传递服务器来实现后台处理
作业或其他类型的消息传递任务。
通常获得一种简单形式的队列, 将值推送到
生产者端, 并在使用者端等待此值`RPOP`
 (使用轮), ) , 或`BRPOP`如果通过阻止更好地为客户端提供服务
操作。

但是, 在此上下文中, 获取的队列不是*可靠*因为消息可以
丢失, 例如在存在网络问题或消费者的情况下
在收到消息后但在处理消息之前崩溃。

`RPOPLPUSH` (或`BRPOPLPUSH`对于阻塞变) ) 提供了一种避免的方法
这个问题：消费者获取消息, 同时推送它
进入一个*加工*列表。
它将使用`LREM`命令, 以便从 中删除消息
*加工*在处理完邮件后列出。

其他客户端可以监视*加工*剩余项目的列表
在那里花费了太多时间, 将超时的项目推入队列
如果需要, 再次。

## 模式：圆形列表

用`RPOPLPUSH`使用相同的源密钥和目标密钥, 客户端可以访问
N 元素列表中的所有元素, 一个接一个, 在 O () ),  中, 没有
使用单个列表将完整列表从服务器传输到客户端`LRANGE`
操作。

即使出现以下一种或两种情况, 上述模式也有效：

*   有多个客户端轮换列表：它们将获取不同的
    元素, 直到访问列表中的所有元素, 并执行该过程
    重新 启动。
*   其他客户正在积极推动列表末尾的新项目。

以上使得实现一组项目必须具有一组项目的系统变得非常简单。
由N个工人尽可能快地连续处理。
一个例子是监视系统, 它必须检查一组网站是否
可到达, 延迟尽可能小, 使用多个并行工作者。

请注意, worker 的这种实现是微不足道的可扩展性和可靠的, 
因为即使消息丢失, 该项目仍在队列中, 并且将
在下一次迭代中处理。
