该命令将 Redis 字符串视为位数组，并且能够处理具有不同位宽和任意非（必要）对齐偏移量的特定整数字段。实际上，使用此命令，您可以将位偏移量为1234处的有符号5位整数设置为特定值，从偏移量4567中检索31位无符号整数。同样，该命令处理指定整数的递增和递减，提供用户可以配置的有保证且明确指定的上溢和下溢行为。

`BITFIELD`能够在同一命令调用中对多个位字段进行操作。它需要一个要执行的操作列表，并返回一个回复数组，其中每个数组都与参数列表中的相应操作匹配。

例如，以下命令在位偏移量为 100 处递增一个 5 位有符号整数，并在位偏移量为 0 处获取 4 位无符号整数的值：

    > BITFIELD mykey INCRBY i5 100 1 GET u4 0
    1) (integer) 1
    2) (integer) 0

请注意：

1.  寻址方式`!GET`当前字符串长度之外的位（包括密钥根本不存在的情况），导致要执行的操作就像缺少的部分一样，所有部分都由设置为0的位组成。
2.  寻址方式`!SET`或`!INCRBY`当前字符串长度之外的位将放大字符串，根据需要将其填充为零，以获得所需的最小长度，根据触摸的最远的位。

## 支持的子命令和整数编码

以下是支持的命令列表。

*   **获取** `<encoding>` `<offset>`-- 返回指定的位字段。
*   **设置** `<encoding>` `<offset>` `<value>`-- 设置指定的位字段并返回其旧值。
*   **因克比** `<encoding>` `<offset>` `<increment>`-- 递增或递减（如果给定负增量）指定的位字段并返回新值。

还有另一个子命令，它只改变连续的行为
`!INCRBY`和`!SET`子命令通过设置溢出行为进行调用：

*   **溢出** `[WRAP|SAT|FAIL]`

在需要整数编码的地方，可以通过前缀`i`对于有符号整数和`u`对于具有整数编码位数的无符号整数。例如`u8`是 8 位的无符号整数，并且`i16`是一个
16 位的有符号整数。

支持的编码对于有符号整数最多为 64 位，对于
无符号整数。无符号整数的这种限制是由于以下事实
当前 Redis 协议无法返回 64 位无符号整数
作为回复。

## 位和位置偏移

有两种方法可以在位字段命令中指定偏移量。
如果指定了不带任何前缀的数字，则该数字将用作基于零的数字
字符串内的位偏移量。

但是，如果偏移量以`#`字符，指定的偏移量
乘以整数编码的宽度，例如：

    BITFIELD mystring SET i8 #0 100 SET i8 #1 200

将第一个 i8 整数设置为偏移量 0，将第二个 i8 整数设置为偏移量 8。
这样，您就不必在客户内部自己做数学运算，如果有的话
你想要的是给定大小的整数的纯数组。

## 溢出控制

使用`OVERFLOW`命令用户能够微调的行为
递增或递减溢出（或下溢），方法是指定
以下行为：

*   **包装**：换行，包括有符号和无符号整数。对于无符号整数，包装就像执行整数可以包含的最大值模运算（C 标准行为）。使用有符号整数代替换行意味着溢出会朝向最负的值重新开始，而下溢会向最正的值重新开始，例如，如果`i8`整数设置为值 127，将其递增 1 将得到`-128`.
*   **坐**：使用饱和算术，即在下溢上将值设置为最小整数值，在上溢时设置为最大整数值。例如，递增`i8`从值 120 开始的整数，增量为 10，将生成值 127，进一步增量将始终使值保持在 127。在下溢上也会发生同样的情况，但该值被阻止在最负的值处。
*   **失败**：在此模式下，不会对检测到溢出或下溢执行任何操作。相应的返回值设置为 NULL，以向调用方发出条件信号。

请注意，每个`OVERFLOW`语句仅影响`!INCRBY`和`!SET`
在子命令列表中跟在它的命令后面，直到下一个命令`OVERFLOW`
陈述。

默认情况下，**包装**如果未另行指定，则使用。

    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 1
    2) (integer) 1
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 2
    2) (integer) 2
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 3
    2) (integer) 3
    > BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
    1) (integer) 0
    2) (integer) 3

## 返回值

该命令返回一个数组，其中每个条目都是
在同一位置给出的子命令。`OVERFLOW`子命令不计算在内
作为生成回复。

以下是`OVERFLOW FAIL`返回空值。

    > BITFIELD mykey OVERFLOW FAIL incrby u2 102 1
    1) (nil)

## 动机

此命令的动机是能够存储许多小整数
因为单个大位图（或分割几个键以避免有大键）具有极高的内存效率，并为Redis的应用开辟了新的用例，特别是在实时分析领域。此用例受以受控方式指定溢出的功能的支持。

有趣的事实：Reddit的2017年愚人节项目[r/place](https://reddit.com/r/place)是[使用 Redis BITFIELD 命令构建](https://redditblog.com/2017/04/13/how-we-built-rplace/)以便获取协作画布的内存中表示。

## 性能注意事项

通常`BITFIELD`是一个快速命令，但请注意，对当前短字符串的远位进行寻址将触发分配，该分配可能比在已经存在的位上执行命令更昂贵。

## 位的阶数

使用的表示形式`BITFIELD`将位图视为具有
位数 0 是第一个字节的最高有效位，依此类推，因此
例如，将一个 5 位无符号整数设置为偏移量 7 处的值 23，设置为
先前设置为所有零的位图将生成以下表示形式：

    +--------+--------+
    |00000001|01110000|
    +--------+--------+

当偏移量和整数大小与字节边界对齐时，这是
与大端序相同，但是当这种对齐不存在时，它很重要
还要了解字节内的位是如何排序的。
