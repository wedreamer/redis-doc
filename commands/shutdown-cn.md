命令行为如下：

*   如果复制中有任何副本滞后：
    *   暂停尝试写入的客户端，方法是执行`CLIENT PAUSE`与`WRITE`选择。
    *   等待到已配置的`shutdown-timeout`（默认为 10 秒）用于副本以赶上复制偏移量。
*   停止所有客户端。
*   如果至少有一个，则执行阻止 SAVE**保存点**已配置。
*   如果启用了 AOF，则刷新仅追加文件。
*   退出服务器。

如果启用了持久性，此命令可确保关闭 Redis
没有任何数据丢失。

注意：配置为不在磁盘上保留的 Redis 实例（无 AOF）
已配置，也没有“保存”指令）不会转储 RDB 文件`SHUTDOWN`如
通常，您不希望仅用于缓存的 Redis 实例在以下情况下被阻止
关闭。

另请注意：如果 Redis 收到其中一个信号`SIGTERM`和`SIGINT`，则执行相同的关机顺序。
另请参见[信号处理](/topics/signals).

## 修饰 符

可以指定可选修饰符来更改命令的行为。
具体说来：

*   **救**将强制执行数据库保存操作，即使未配置保存点也是如此。
*   **诺萨夫**将阻止数据库保存操作，即使配置了一个或多个保存点也是如此。
*   **现在**跳过等待滞后副本，即它绕过关机序列中的第一步。
*   **力**忽略通常阻止服务器退出的任何错误。
    有关详细信息，请参阅以下部分。
*   **流产**取消正在进行的关机，并且不能与其他标志结合使用。

## 关机失败的情况

当配置了保存点或**救**指定了修饰符，如果无法保存 RDB 文件，则关闭可能会失败。
然后，服务器继续运行以确保没有数据丢失。
这可以通过使用**力**修饰符，导致服务器仍然退出。

启用“仅追加文件”时，关机可能会失败，因为
系统处于不允许立即安全持久化的状态
在磁盘上。

通常，如果有 AOF 子进程执行 AOF 重写，Redis
将简单地杀死它并退出。
但是，在某些情况下，这样做是不安全的，除非**力**指定了修饰符，**关闭**命令将被拒绝并显示错误。
在以下情况下会发生这种情况：

*   用户刚刚打开 AOF，服务器触发了第一次 AOF 重写，以创建初始 AOF 文件。在这种情况下，停止将导致丢失数据集：重新启动后，服务器可能会启用AOF，而根本没有任何AOF文件。
*   启用了 AOF 的副本，与其主服务器重新连接，执行完全重新同步，然后重新启动 AOF 文件，从而触发初始 AOF 创建过程。在这种情况下，未完成 AOF 重写是危险的，因为从主服务器接收的最新数据集将丢失。新主节点实际上甚至可以是不同的实例（如果**复制品**或**奴隶**命令用于重新配置副本），因此在服务器终止时，完成 AOF 重写并从表示内存中数据集的正确数据集开始非常重要。

在某些情况下，我们只想尽快终止 Redis 实例，而不管其内容是什么。
在这种情况下，命令**立即关机，节省力**可以使用。
在 7.0 之前的版本中，其中**现在**和**力**标志不可用，正确的命令组合是发送一个**CONFIG appendonly no**后跟**关断节气**.
如果需要，第一个命令将关闭 AOF，如果有一个处于活动状态，则将终止 AOF 重写子级。
第二个命令不会有任何问题执行，因为 AOF 不再启用。

## 将数据丢失的风险降至最低

从 Redis 7.0 开始，服务器等待滞后副本直到可配置`shutdown-timeout`，则默认为 10 秒，然后关闭。
这样可以尽最大努力在未配置保存点且禁用 AOF 的情况下最大限度地降低数据丢失的风险。
在版本 7.0 之前，在无盘设置中关闭负载过重的主节点更有可能导致数据丢失。
为了最大限度地降低此类设置中数据丢失的风险，建议触发手动`FAILOVER`（或`CLUSTER FAILOVER`） 以在关闭主节点之前将主节点降级为副本，并将其中一个副本提升为新的主节点。

@return

@simple字符串回复：`OK`如果`ABORT`已指定，并且已关闭。
成功关闭后，自服务器退出并关闭连接以来，不会返回任何内容。
失败时，将返回错误。

## 行为更改历史记录

*   `>= 7.0.0`：引入了在退出之前等待滞后副本的功能。
