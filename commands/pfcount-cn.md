使用单个键调用时, 返回由存储在指定变量处的 HyperLogLog 数据结构计算的近似基数, 如果变量不存在, 则为 0。

当使用多个键调用时, 通过将存储在提供的密钥处的 HyperLogLogs 内部合并到临时 HyperLogLog 中, 返回所传递的 HyperLogs 并集的近似基数。

可以使用HyperLogLog数据结构进行计数**独特**元素, 其中的元素仅使用少量恒定的内存, 特别是每个 HyperLogLog 的 12k 字节 (加上密钥本身的几个字节) 。

观测集的返回基数不是精确的, 但近似于标准误差 0.81%。

例如, 为了计算一天内执行的所有唯一搜索查询的计数, 程序需要调用`PFADD`每次处理查询时。可以使用以下命令检索估计的唯一查询数`PFCOUNT`在任何时候。

注意：作为调用此函数的副作用, 可能会修改 HyperLogLog, 因为最后 8 个字节编码最新计算的基数
用于缓存目的。所以`PFCOUNT`从技术上讲, 是一个写入命令。

@return

@integer回复, 具体而言：

*   通过观察的唯一元素的近似数量`PFADD`.

@examples

```cli
PFADD hll foo bar zap
PFADD hll zap zap zap
PFADD hll foo bar
PFCOUNT hll
PFADD some-other-hll 1 2 3
PFCOUNT hll some-other-hll
```

## 性能

什么时候`PFCOUNT`用单个键调用, 即使
从理论上讲, 处理密集的HyperLogLog的恒定时间很高。这是
可能, 因为`PFCOUNT`使用缓存以记住基数
以前计算过, 这很少改变, 因为大多数`PFADD`操作将
不更新任何寄存器。每秒可以进行数百次操作。

什么时候`PFCOUNT`使用多个键调用, 这是
执行HyperLogs, 这很慢, 而且是联合的基数
无法缓存, 因此当与多个键一起使用时`PFCOUNT`可能需要一段时间
毫秒的数量级, 并且不应该被滥用。

用户应牢记, 单键和多键执行
此命令在语义上不同, 并且具有不同的性能。

## 超日志表示形式

Redis HyperLogLogs 使用双重表示形式表示：*稀疏*表示适用于计数少量元素的HLL (导致少量寄存器设置为非零), ) , 并且*稠*适用于高基数的表示。Redis 会在需要时自动从稀疏表示切换到密集表示。

稀疏表示使用经过优化的运行长度编码, 以有效地存储大量设置为零的寄存器。密集表示形式是 12288 字节的 Redis 字符串, 用于存储 16384 个 6 位计数器。对双重表示的需求来自这样一个事实, 即使用12k (这是密集表示内存要) ) 来编码几个寄存器以获得较小的基数是非常不理想的。

这两种表示都以16字节的标头为前缀, 其中包括一个魔术, 一个编码/版本字段, 以及计算的缓存基数估计, 以小字节序格式存储 (如果估计无, , 则最高有效位为, , 因为HyperLogLog自计算基数以来已更) ) 。

HyperLogLog, 作为一个 Redis 字符串, 可以使用`GET`并恢复`SET`.叫`PFADD`,`PFCOUNT`或`PFMERGE`具有损坏的HyperLogLog的命令从来都不是问题, 它可能会返回随机值, 但不会影响服务器的稳定性。大多数情况下, 在损坏稀疏表示时, 服务器会识别损坏并返回错误。

从处理器字大小和字节序的角度来看, 该表示是中性的, 因此32位和64位处理器使用相同的表示, 大端或小字节序。

有关 Redis HyperLogLog 实现的更多详细信息, 请参阅[这篇博客文章](http://antirez.com/news/75).实现的源代码`hyperloglog.c`file也易于阅读和理解, 并且包括用于稀疏和密集表示的确切编码的完整规范。
