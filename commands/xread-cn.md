从一个或多个流中读取数据, 仅返回具有
ID 大于呼叫者报告的上次接收的 ID。
此命令具有一个选项, 用于在项目不可用时阻止, 在类似的
时尚到`BRPOP`或`BZPOPMIN`和其他人。

请注意, 在阅读此页面之前, 如果您不熟悉流, 
我们建议阅读[我们对 Redis Streams 的介绍](/topics/streams-intro).

## 非阻塞用法

如果**块**选项未使用, 命令是同步的, 并且可以
被认为与`XRANGE`：它将返回一系列项目
但是, 与`XRANGE`
即使我们只考虑同步用法：

*   如果我们想读取
    同时从多个键。这是`XREAD`因为
    特别是当阻塞**块**, 以便能够用单曲收听
    连接到多个密钥是一项重要功能。
*   而`XRANGE`返回一系列 ID 中的项目, `XREAD`更适合于
    从第一个条目开始使用流的顺序, 该条目更大
    比我们迄今为止看到的任何其他条目都要多。那么我们传递给什么`XREAD`是, 对于每个
    stream, 我们从该流接收的最后一个元素的 ID。

例如, 如果我有两个流`mystream`和`writers`, 而我想要
从两个流中读取数据, 从它们包含的第一个元素开始, 
我可以打电话`XREAD`如以下示例所示。

注意：我们使用**计数**选项, 以便对于每个流
调用将以每个流最多返回两个元素。

    > XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
    1) 1) "mystream"
       2) 1) 1) 1526984818136-0
             2) 1) "duration"
                2) "1532"
                3) "event-id"
                4) "5"
                5) "user-id"
                6) "7782813"
          2) 1) 1526999352406-0
             2) 1) "duration"
                2) "812"
                3) "event-id"
                4) "9"
                5) "user-id"
                6) "388234"
    2) 1) "writers"
       2) 1) 1) 1526985676425-0
             2) 1) "name"
                2) "Virginia"
                3) "surname"
                4) "Woolf"
          2) 1) 1526985685298-0
             2) 1) "name"
                2) "Jane"
                3) "surname"
                4) "Austen"

这**流**选项是强制性的, 必须是最终选项, 因为
这样的选项以以下格式获取可变长度的参数：

    STREAMS key_1 key_2 key_3 ... key_N ID_1 ID_2 ID_3 ... ID_N

因此, 我们从一个键列表开始, 然后继续使用所有关联的键
ID, 代表*我们为该流收到的最后一个 ID*, 以便
call 将仅向我们提供来自同一流的更大 ID。

例如, 在上面的示例中, 我们收到的最后一个项目
对于流`mystream`有身份证`1526999352406-0`, 而对于
流`writers`具有 ID`1526985685298-0`.

要继续迭代这两个流, 我将调用：

    > XREAD COUNT 2 STREAMS mystream writers 1526999352406-0 1526985685298-0
    1) 1) "mystream"
       2) 1) 1) 1526999626221-0
             2) 1) "duration"
                2) "911"
                3) "event-id"
                4) "7"
                5) "user-id"
                6) "9488232"
    2) 1) "writers"
       2) 1) 1) 1526985691746-0
             2) 1) "name"
                2) "Toni"
                3) "surname"
                4) "Morrison"
          2) 1) 1526985712947-0
             2) 1) "name"
                2) "Agatha"
                3) "surname"
                4) "Christie"

等等。最终, 调用不会返回任何项目, 而只是返回
空数组, 那么我们知道没有什么可以从我们的
流 (并且我们必须重试该操, , 因此此命令
还支持阻止模式) 。

## 不完整的身份证件

使用不完整的 ID 是有效的, 就像它对`XRANGE`.然而
在这里, ID的序列部分, 如果丢失, 总是被解释为
零, 所以命令：

    > XREAD COUNT 2 STREAMS mystream writers 0 0

完全等价于

    > XREAD COUNT 2 STREAMS mystream writers 0-0 0-0

## 阻止数据

在其同步形式中, 该命令可以获取新数据, 只要有
是更多可用的项目。但是, 在某些时候, 我们将不得不等待
要使用的数据的生产者`XADD`在流中推送新条目
我们正在消费。为了避免以固定或自适应间隔进行轮询
该命令能够阻止, 如果它不能返回任何数据, 根据
到指定的流和 ID, 并自动取消阻止一次
请求的键接受数据。

重要的是要了解此命令*扇出*到所有
正在等待相同范围的 ID 的客户端, 因此每个使用者都将
获取数据的副本, 这与弹出阻止列表时发生的情况不同
使用操作。

为了阻止, **块**选项与数字一起使用
我们想要在超时之前阻止的毫秒。通常 Redis 阻塞
命令以秒为单位超时, 但此命令需要一毫秒
超时, 即使服务器通常具有接近超时分辨率
到 0.1 秒。这次可以在较短的时间内阻塞
某些用例, 如果服务器内部会随着时间的推移而改善, 那么它是
超时的分辨率可能会提高。

当**块**命令已传递, 但有数据要返回
至少在传递的其中一个流中, 命令同步执行
*就像如果缺少 BLOCK 选项一样*.

这是阻止调用的一个示例, 命令稍后返回
空回复, 因为超时已过, 没有新数据到达：

    > XREAD BLOCK 1000 STREAMS mystream 1526999626221-0
    (nil)

## 特别`$`编号。

当阻止时, 有时我们希望只接收添加的条目
到流通过`XADD`从我们阻止的那一刻开始。在这种情况下
我们对已添加条目的历史记录不感兴趣。为
在这个用例中, 我们必须检查流顶部元素ID, 并使用
此类 ID 在`XREAD`命令行。这是不干净的, 需要
调用其他命令, 因此可以使用特殊`$`
ID 来指示流我们只想要新事物。

是的**非常重要**以了解您应该使用`$`
ID 仅用于第一次调用`XREAD`.稍后的 ID 应该是那个
流中最后报告的项目, 否则您可能会错过所有项目
在两者之间添加的条目。

这是典型的`XREAD`调用在第一次迭代中的样子
的消费者愿意只消费新条目：

    > XREAD BLOCK 5000 COUNT 100 STREAMS mystream $

一旦我们得到一些回复, 下一个电话将是这样的：

    > XREAD BLOCK 5000 COUNT 100 STREAMS mystream 1526999644174-3

等等。

## 如何为单个流上阻止的多个客户端提供服务

对列表或排序集的阻止列表操作具有*流行*行为。
基本上, 该元素将从列表中删除或按顺序排序集
以返回到客户端。在这种情况下, 您需要这些项目
以公平的方式消费, 具体取决于客户端被阻止的时刻
在给定的钥匙到达。通常, Redis在此使用FIFO语义
用例。

但请注意, 对于流, 这不是问题：流条目
当客户端提供服务时, 不会从流中删除, 因此每个
客户等待将在`XADD`命令提供
数据到流。

@return

@array回复, 具体而言：

该命令返回一个结果数组：返回的每个元素
array 是由包含键名和
为该密钥报告的条目。报告的条目是全流的
条目, 具有 ID 以及所有字段和值的列表。字段和
保证以与添加值相同的顺序报告值
由`XADD`.

什么时候**块**, 超时时返回空回复。

阅读[Redis Streams 介绍](/topics/streams-intro)是高度
建议, 以便更多地了解流的整体行为
和语义。
