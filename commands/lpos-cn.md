该命令返回 Redis 列表中匹配元素的索引。
默认情况下, 当没有给出任何选项时, 它将从头到尾扫描列表, 
查找“元素”的第一个匹配项。如果找到该元素, 则返回其索引 (列表中从零开始的位置) 。, 则, 如果未找到匹, 项, `nil`返回。

    > RPUSH mylist a b c 1 2 3 c c
    > LPOS mylist c
    2

可选的参数和选项可以修改命令的行为。
这`RANK`选项指定要返回的第一个元素的“排名”, 以防有多个匹配项。排名 1 表示返回第一个匹配项, 2 表示返回第二个匹配项, 依此类推。

例如, 在上面的例子中, 元素“c”多次出现, 如果我想要第二个匹配的索引, 我会写：

    > LPOS mylist c RANK 2
    6

也就是说, “c”的第二次出现位于位置 6。
负“等级”作为`RANK`参数告诉`LPOS`反转搜索方向, 从尾巴到头部。

所以, 我们想说, 给我从列表末尾开始的第一个元素：

    > LPOS mylist c RANK -1
    7

请注意, 索引仍然以“自然”方式报告, 即考虑从索引 0 处的列表头开始的第一个元素, 索引 1 处的下一个元素, 依此类推。这基本上意味着无论排名为正还是负, 返回的索引都是稳定的。

有时我们不仅要返回第 N 个匹配元素, 还要返回所有前 N 个匹配元素的位置。这可以通过使用`COUNT`选择。

    > LPOS mylist c COUNT 2
    [2,6]

我们可以结合`COUNT`和`RANK`因此`COUNT`将尝试返回最多指定的匹配项数, 但从第 N 个匹配项开始, 如`RANK`选择。

    > LPOS mylist c RANK -1 COUNT 2
    [7,6]

什么时候`COUNT`, 可以指定 0 作为匹配项的数量, 作为告诉命令我们希望找到的所有匹配项作为索引数组返回的一种方式。这比给一个非常大的`COUNT`选项, 因为它更通用。

    > LPOS mylist c COUNT 0
    [2,6,7]

什么时候`COUNT`, 但未找到匹配项, 则返回空数组。但是, 当`COUNT`未使用且没有匹配项, 则命令返回`nil`.

最后, `MAXLEN`选项, 告诉命令仅将提供的元素与给定的最大列表项数进行比较。例如, 指定`MAXLEN 1000`将确保该命令仅执行 1000 次比较, 从而有效地在列表的子集上运行算法 (第一部分或最后一部, , 具体取决于我们使用正或负排名的事) ) 。这对于限制命令的最大复杂性非常有用。当我们期望很早就找到, 配项, 但希望确保如果情况并, 如此, 该命令不会花费太多时间来, 行时, 它也很有用。

什么时候`MAXLEN`, 可以指定 0 作为最大比较次数, 作为告诉命令我们想要无限比较的一种方式。这比给一个非常大的`MAXLEN`选项, 因为它更通用。

@return

该命令返回表示匹配元素的整数, 或者`nil`如果没有匹配项。但是, 如果`COUNT`选项, 命令返回一个数组 (如果没有匹配, , 则为) ) 。

@examples

```cli
RPUSH mylist a b c d 1 2 3 4 3 3 3
LPOS mylist 3
LPOS mylist 3 COUNT 0 RANK 2
```
