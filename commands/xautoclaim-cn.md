此命令转移与指定条件匹配的挂起流条目的所有权。概念`XAUTOCLAIM`等同于调用`XPENDING`然后`XCLAIM`,
但提供了一种更直接的方式来处理消息传递失败, 如下所示`SCAN`-像语义。

喜欢`XCLAIM`, 则该命令对位于`<key>`并在提供的上下文中`<group>`.
它将所有权转移到`<consumer>`挂起时间超过的邮件数`<min-idle-time>`毫秒, 并且 ID 等于或大于`<start>`.

可选`<count>`参数 (默认为 100) 是命令尝试声明的条目数的上限。
在内部, 该命令开始扫描使用者组的挂起条目列表  (PE), ) , `<start>`并筛选出空闲时间小于或等于`<min-idle-time>`.
命令扫描的最大挂起条目数是乘法的乘积`<count>`的值 x 10 (硬编) ) 。
因此, 声明的条目数可能会小于指定的值。

可选`JUSTID`参数将回复更改为仅返回已成功声明的消息的 ID 数组, 而不返回实际消息。
使用此选项意味着重试计数器不会递增。

该命令将声明的条目作为数组返回。它还返回一个流 ID, 用于类似游标的使用, 作为`<start>`其后续调用的参数。
当没有剩余的 PEL 条目时, 该命令返回`0-0`ID 以指示完成。
但是, 请注意, 您可能希望继续呼叫`XAUTOCLAIM`即使在扫描完成后, 使用`0-0`如`<start>`ID, 因为经过了足够的时间, 所以较旧的待处理条目现在可能有资格申领。

请注意, 只有空闲时间长于以下时间的邮件`<min-idle-time>`, 并且声明消息会重置其空闲时间。
这可确保只有单个使用者可以在特定时刻成功声明给定的挂起消息, 并轻松降低多次处理同一消息的可能性。

在迭代 PEL 时, 如果`XAUTOCLAIM`偶然发现流中不再存在的消息 (修剪或删除`XDEL), ) , 它不会, 明它, 并将其从找到它的PEL中删除。此功能是在 Redis 7.0 中引入的。
这些消息 ID 作为`XAUTOCLAIM`的回复。

最后, 声明消息`XAUTOCLAIM`还会增加该邮件的尝试传递计数, 除非`JUSTID`选项 (仅传递消息 I, , 而不传递消息本) ) 。
由于某种原因无法处理的消息 (例, , 因为使用者在处理它们时系统地崩) ) 将表现出可以通过监视检测到的高尝试传递计数。

@return

@array回复, 具体而言：

具有三个元素的数组：

1.  要用作`<start>`参数, 用于下一次调用`XAUTOCLAIM`.
2.  一个数组, 其中包含所有已成功声明的消息, 格式与`XRANGE`.
3.  一个数组, 其中包含流中不再存在的消息 ID, 这些消息 ID 已从找到它们的 PEL 中删除。

@examples

    > XAUTOCLAIM mystream mygroup Alice 3600000 0-0 COUNT 25
    1) "0-0"
    2) 1) 1) "1609338752495-0"
          2) 1) "field"
             2) "value"
    3) (empty array)

在上面的示例中, 我们尝试从流开始时声明最多 25 个待处理和空闲 (未确认或声) ) 至少一个小时的条目。
来自“mygroup”组的使用者“Alice”获得这些消息的所有权。
请注意, 示例中返回的流 ID 为`0-0`, 指示已扫描整个流。
我们还可以看到`XAUTOCLAIM`没有偶然发现任何已删除的消息 (第三个回复元素是一个空数) ) 。
