覆盖存储在*钥匙*, 从指定的偏移量开始, 
对于整个长度*价值*.
如果偏移量大于字符串的当前长度, 则*钥匙*这
字符串填充有零字节*抵消*适合。
不存在的键被视为空字符串, 因此此命令将使
确保它包含一个足够大的字符串, 以便能够设置*价值*在*抵消*.

请注意, 您可以设置的最大偏移量为 2^29 -1 (536870911,  , 因为 Redis
字符串限制为 512 MB。
如果需要增长到超过此大小, 可以使用多个键。

**警告**：设置最后一个可能的字节和存储在
*钥匙*尚未保存字符串值, 或保存小字符串值, Redis
需要分配所有中间内存, 这可能会阻止某些人的服务器
时间。
在 2010 年的 MacBook Pro 上, 设置字节数536870911 (512MB 分) ) 需要
\~300ms, 设置字节数134217728 (128MB 分) ) 需要 ~8, ms, 设置
位数33554432 (32MB 分) ) 需要大约 30, 毫秒, 设置位号8388608
 (8MB 分) ) 需要大约 8 毫秒。
请注意, 完成第一次分配后, 后续调用`SETRANGE`为
一样*钥匙*将没有分配开销。

## 模式

由于`SETRANGE`和类似物`GETRANGE`命令, 您可以使用 Redis
字符串作为具有 O () )  随机访问的线性数组。
在许多实际用例中, 这是一种非常快速高效的存储。

@return

@integer回复：字符串在被命令修改后的长度。

@examples

基本用法：

```cli
SET key1 "Hello World"
SETRANGE key1 6 "Redis"
GET key1
```

零填充示例：

```cli
SETRANGE key2 6 "Redis"
GET key2
```
