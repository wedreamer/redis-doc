这`SCAN`命令和密切相关的命令`SSCAN`,`HSCAN`和`ZSCAN`用于增量迭代元素集合。

*   `SCAN`循环访问当前选定的 Redis 数据库中的键集。
*   `SSCAN`迭代 Sets 类型的元素。
*   `HSCAN`迭代 Hash 类型的字段及其关联值。
*   `ZSCAN`迭代排序集类型的元素及其关联的分数。

由于这些命令允许增量迭代, 每次调用仅返回少量元素, 因此它们可以在生产中使用, 而不会有命令的缺点, 例如`KEYS`或`SMEMBERS`当针对大量键或元素集合调用时, 可能会长时间 (甚至几秒钟) 阻止服务器。

但是, 在阻止命令时, 例如`SMEMBERS`能够在给定时刻提供属于 Set 的所有元素, SCAN 命令系列仅对返回的元素提供有限的保证, 因为我们增量迭代的集合可能会在迭代过程中更改。

请注意, `SCAN`,`SSCAN`,`HSCAN`和`ZSCAN`它们的工作方式非常相似, 因此本文档涵盖了所有四个命令。然而, 一个明显的区别是, 在以下情况下`SSCAN`,`HSCAN`和`ZSCAN`第一个参数是包含 Set、Hash 或 Sorted Set 值的键的名称。这`SCAN`命令不需要任何键名参数, 因为它循环访问当前数据库中的键, 因此迭代的对象是数据库本身。

## 扫描基本用法

SCAN 是基于游标的迭代器。这意味着, 在每次调用该命令时, 服务器都会返回一个更新的游标, 用户需要在下次调用中将其用作游标参数。

迭代在游标设置为 0 时开始, 当服务器返回的游标为 0 时终止。以下是 SCAN 迭代的一个示例：

    redis 127.0.0.1:6379> scan 0
    1) "17"
    2)  1) "key:12"
        2) "key:8"
        3) "key:4"
        4) "key:14"
        5) "key:16"
        6) "key:17"
        7) "key:15"
        8) "key:10"
        9) "key:3"
       10) "key:7"
       11) "key:1"
    redis 127.0.0.1:6379> scan 17
    1) "0"
    2) 1) "key:5"
       2) "key:18"
       3) "key:0"
       4) "key:2"
       5) "key:19"
       6) "key:13"
       7) "key:6"
       8) "key:9"
       9) "key:11"

在上面的示例中, 第一个调用使用零作为游标来启动迭代。第二个调用使用上一个调用返回的游标作为应答的第一个元素, 即 17。

如您所见**扫描返回值**是两个值的数组：第一个值是要在下一次调用中使用的新游标, 第二个值是元素数组。

由于在第二次调用中返回的游标为 0, 因此服务器向调用方发出迭代完成的信号, 并且完全浏览了集合。以游标值为 0 开始迭代, 然后调用`SCAN`直到返回的游标再次为 0, 否则称为**完全迭代**.

## 扫描保证

这`SCAN`命令, 以及`SCAN`族, 能够向用户提供一组与完整迭代相关的保证。

*   完整迭代始终检索集合中从完整迭代的开始到结束的所有元素。这意味着, 如果给定元素在迭代开始时位于集合内, 并且在迭代终止时仍然存在, 则在某个时刻`SCAN`已将其返回给用户。
*   完整迭代从不返回从完整迭代的开始到结束集合中不存在的任何元素。因此, 如果某个元素在迭代开始之前被删除, 并且在迭代持续期间从未被添加回集合中, `SCAN`确保永远不会返回此元素。

但是, 因为`SCAN`具有很少的关联状态 (只是游), ) , 它具有以下缺点：

*   给定元素可以多次返回。由应用程序来处理重复元素的情况, 例如, 仅使用返回的元素来执行多次重新应用时安全的操作。
*   在完整迭代期间集合中不经常存在的元素可能会返回, 也可以不返回：它是未定义的。

## 每次 SCAN 调用返回的元素数

`SCAN`族函数不保证每次调用返回的元素数在给定范围内。还允许命令返回零个元素, 只要返回的游标不为零, 客户端就不应认为迭代已完成。

但是, 返回的元素数是合理的, 也就是说, 实际上, 在迭代大型集合时, SCAN 可能会以几十个元素的顺序返回最大数量的元素, 或者当迭代的集合足够小, 可以在内部表示为编码数据结构时, 在单个调用中返回集合的所有元素 (对于小集, ,  哈希和排序) ) 。

但是, 有一种方法可以让用户使用**计数**选择。

## 计数选项

而`SCAN`不提供关于每次迭代返回的元素数量的保证, 可以根据经验调整`SCAN`使用**计数**选择。基本上用计数用户指定的*为了从集合中检索元素, 每次调用都应完成的工作量*.这是**只是一个提示**对于实现, 但是一般来说, 这是您在大多数情况下对实现的期望。

*   默认 COUNT 值为 10。
*   当迭代密钥空间或集、哈希或排序集时, 该集足够大, 可以由哈希表表示, 假设没有**火柴**选项被使用, 服务器通常会返回*计数*或多一点*计数*元素数。请检查*为什么 SCAN 可以一次返回所有元素*部分。
*   当迭代编码为intset (仅由整数组成的小集) ) 或编码为ziplist的Hashes和Sorted Sets (小哈希和由小的单个值组成,  集) 时, 通常所有元素都在第一个`S, AN`调用, 而不考虑 COUNT 值。

重要：**无需使用相同的 COUNT 值**对于每次迭代。调用方可以根据需要自由地将计数从一次迭代更改为另一次迭代, 只要在下一次调用中传递的游标是在上一次调用命令中获得的游标即可。

## 匹配选项

可以只迭代与给定的 glob 样式模式匹配的元素, 类似于`KEYS`将模式作为唯一参数的命令。

为此, 只需附加`MATCH <pattern>`末尾的参数`SCAN`命令 (它适用于所有 SCAN 系列命) ) 。

这是使用**火柴**:

    redis 127.0.0.1:6379> sadd myset 1 2 3 foo foobar feelsgood
    (integer) 6
    redis 127.0.0.1:6379> sscan myset 0 match f*
    1) "0"
    2) 1) "foo"
       2) "feelsgood"
       3) "foobar"
    redis 127.0.0.1:6379>

重要的是要注意**火柴**筛选器在从集合中检索元素后, 紧接在将数据返回到客户端之前应用。这意味着, 如果模式与集合中的元素非常少, `SCAN`在大多数迭代中, 可能不会返回任何元素。示例如下所示：

    redis 127.0.0.1:6379> scan 0 MATCH *11*
    1) "288"
    2) 1) "key:911"
    redis 127.0.0.1:6379> scan 288 MATCH *11*
    1) "224"
    2) (empty list or set)
    redis 127.0.0.1:6379> scan 224 MATCH *11*
    1) "80"
    2) (empty list or set)
    redis 127.0.0.1:6379> scan 80 MATCH *11*
    1) "176"
    2) (empty list or set)
    redis 127.0.0.1:6379> scan 176 MATCH *11* COUNT 1000
    1) "0"
    2)  1) "key:611"
        2) "key:711"
        3) "key:118"
        4) "key:117"
        5) "key:311"
        6) "key:112"
        7) "key:111"
        8) "key:110"
        9) "key:113"
       10) "key:211"
       11) "key:411"
       12) "key:115"
       13) "key:116"
       14) "key:114"
       15) "key:119"
       16) "key:811"
       17) "key:511"
       18) "key:11"
    redis 127.0.0.1:6379>

如您所见, 大多数调用返回零个元素, 但最后一次调用使用 COUNT 1000, 以强制命令对该迭代执行更多扫描。

## “类型”选项

您可以使用`!TYPE`询问选项`SCAN`仅返回与给定对象匹配的对象`type`, 允许您循环访问数据库以查找特定类型的键。这**类型**选项仅在整个数据库上可用`SCAN`不`HSCAN`或`ZSCAN`等。

这`type`参数是与`TYPE`命令返回。请注意一个怪癖, 其中某些 Redis 类型 (如 GeoHashes、HyperLogLogs、Bitmaps 和 Bitfield) ) 可能在内部使用其他 Redis 类型 (如字符串或 zs), t) 实现, 因此无法通过以下方式与相同类型的其他键区分开来。`SC, N`.例如, ZSET 和 GEOHASH：

    redis 127.0.0.1:6379> GEOADD geokey 0 0 value
    (integer) 1
    redis 127.0.0.1:6379> ZADD zkey 1000 value
    (integer) 1
    redis 127.0.0.1:6379> TYPE geokey
    zset
    redis 127.0.0.1:6379> TYPE zkey
    zset
    redis 127.0.0.1:6379> SCAN 0 TYPE zset
    1) "0"
    2) 1) "geokey"
       2) "zkey"

重要的是要注意**类型**从数据库中检索元素后也会应用 filter, 因此该选项不会减少服务器完成完整迭代所需的工作量, 并且对于罕见的类型, 您可能会在多次迭代中收到任何元素。

## 多个并行迭代

无限数量的客户端可以同时迭代同一集合, 因为迭代器的完整状态位于游标中, 该状态在每次调用时都会获取并返回给客户端。根本不采用服务器端状态。

## 在中间终止迭代

由于没有状态服务器端, 但完整状态由游标捕获, 因此调用方可以自由地在中途终止迭代, 而无需以任何方式向服务器发出信号。可以启动无限次迭代, 并且永远不会终止, 而不会出现任何问题。

## 使用损坏的光标调用 SCAN

叫`SCAN`如果游标损坏、否定、超出范围或其他无效游标, 将导致未定义的行为, 但永远不会导致崩溃。未定义的是, 关于返回元素的保证不能再由`SCAN`实现。

要使用的唯一有效游标是：

*   启动迭代时的游标值 0。
*   上一次调用 SCAN 以继续迭代时返回的游标。

## 终止保证

这`SCAN`仅当迭代集合的大小保持在给定的最大大小范围内时, 算法才保证终止, 否则迭代始终增长的集合可能会导致`SCAN`从不终止完整迭代。

这很容易直观地看到：如果集合增长, 为了访问所有可能的元素, 需要做越来越多的工作, 而终止迭代的能力取决于调用次数。`SCAN`及其 COUNT 选项值与集合增长速率的比较。

## 为什么 SCAN 可以在单个调用中返回聚合数据类型的所有项目？

在`COUNT`选项文档, 我们声明有时这组命令可能会在一次调用中一次返回集, 哈希或排序集的所有元素, 而不管`COUNT`选项值。发生这种情况的原因是, 仅当我们正在扫描的聚合数据类型表示为哈希表时, 才能实现基于游标的迭代器, 并且该迭代器才有用。但是, Redis 使用[内存优化](/topics/memory-optimization)其中, 小型聚合数据类型, 直到它们达到给定数量的项目或单个元素的给定最大大小, 都使用紧凑的单分配打包编码来表示。在这种情况下, `SCAN`没有有意义的游标返回, 并且必须一次迭代整个数据结构, 因此它唯一合理的行为是在调用中返回所有内容。

但是, 一旦数据结构更大, 并且被提升为使用真正的哈希表, 则`SCAN`命令系列将诉诸正常行为。请注意, 由于返回所有元素的特殊行为仅对小型聚合为真, 因此它对命令复杂性或延迟没有影响。但是, 转换为实际哈希表的确切限制是[用户可配置](/topics/memory-optimization), 因此, 在单个调用中可以看到返回的最大元素数取决于聚合数据类型的大小, 并且仍使用打包的表示形式。

另请注意, 此行为特定于`SSCAN`,`HSCAN`和`ZSCAN`.`SCAN`本身从不显示此行为, 因为密钥空间始终由哈希表表示。

## 返回值

`SCAN`,`SSCAN`,`HSCAN`和`ZSCAN`返回两个元素的多批量回复, 其中第一个元素是表示无符号 64 位数字 (游) ) 的, 符串, 第二个元素是具有元素数组的多批量。

*   `SCAN`元素数组是键的列表。
*   `SSCAN`元素数组是 Set 成员的列表。
*   `HSCAN`元素数组包含两个元素, 一个字段和一个值, 用于 Hash 的每个返回元素。
*   `ZSCAN`元素数组包含两个元素, 一个成员及其关联的分数, 用于排序集的每个返回元素。

## 其他示例

哈希值的迭代。

    redis 127.0.0.1:6379> hmset hash name Jack age 33
    OK
    redis 127.0.0.1:6379> hscan hash 0
    1) "0"
    2) 1) "name"
       2) "Jack"
       3) "age"
       4) "33"
