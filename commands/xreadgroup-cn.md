这`XREADGROUP`命令是 的特殊版本`XREAD`命令
支持消费者群体。也许你必须了解
`XREAD`在阅读此页面之前命令将有意义。

此外，如果您是流新手，我们建议您阅读我们的
[Redis Streams 简介](/topics/streams-intro).
一定要在介绍中了解消费群体的概念
因此，遵循此命令的工作原理将更简单。

## 30秒内消费组

此命令与普通命令之间的区别`XREAD`是这个
一个支持消费群体。

没有消费群体，只使用`XREAD`，则所有客户端都与到达流中的所有条目一起提供服务。而是使用使用者组`XREADGROUP`，则可以创建客户端组，这些客户端使用到达给定流中的消息的不同部分。例如，如果流获取新条目 A、B 和 C，并且有两个使用者通过使用者组读取，则一个客户端将获得消息 A 和 C，另一个客户端将获得消息 B，依此类推。

在使用者组中，给定的使用者（即，仅使用来自流的消息的客户端）必须使用唯一标识*使用者名称*.这只是一个字符串。

使用者组的保证之一是给定的使用者只能看到传递给它的消息的历史记录，因此消息只有一个所有者。但是，有一个特殊功能称为*消息声明*允许其他使用者在某个使用者出现不可恢复的故障时声明消息。为了实现这种语义，使用者组需要显式确认使用者成功处理的消息，通过`XACK`命令。这是必需的，因为流将为每个使用者组跟踪谁正在处理什么消息。

以下是了解如何了解是否要使用使用者组：

1.  如果您有一个流和多个客户端，并且您希望所有客户端都获取所有消息，则不需要使用者组。
2.  如果您有一个流和多个客户端，并且您希望该流是*分区*或*分片*在客户端之间，以便每个客户端都将获得到达流中的消息的子集，您需要一个使用者组。

## XREAD和XREADGROUP之间的差异

从语法的角度来看，命令几乎是相同的，
然而`XREADGROUP` *需要*特殊和强制性选项：

    GROUP <group-name> <consumer-name>

组名称只是与流关联的使用者组的名称。
该组是使用`XGROUP`命令。使用者名称是
客户端用于在组内标识自身的字符串。
使用者在第一次在使用者组内自动创建
是锯。不同的客户端应选择不同的使用者名称。

当您阅读时`XREADGROUP`，服务器将*记得*一个给定的
消息已传递给您：消息将存储在
所谓的待处理条目列表 （PEL） 中的使用者组，即
已传递但尚未确认的邮件 ID 的列表。

客户端必须使用以下命令确认消息处理`XACK`
以便从 PEL 中删除待处理条目。公共教育
可以使用`XPENDING`命令。

这`NOACK`子命令可用于避免将消息添加到 PEL 中
可靠性不是必需的，并且偶尔会丢失消息
是可以接受的。这等效于在读取消息时确认消息。

要在**流**使用时的选项`XREADGROUP`能
是以下两个之一：

*   特别`>`ID，这意味着使用者只想接收以下消息：*从未交付给任何其他消费者*.它只是意味着，给我新的消息。
*   任何其他 ID（即 0 或任何其他有效 ID 或不完整 ID）（只是毫秒时间部分）将具有返回等待的条目的效果，这些条目对于发送 ID 大于所提供 ID 的命令的使用者。所以基本上如果ID不是`>`，则该命令将只允许客户端访问其挂起的条目：传递给它但尚未确认的消息。请注意，在这种情况下，两者`BLOCK`和`NOACK`将被忽略。

喜欢`XREAD`这`XREADGROUP`命令可以以阻塞方式使用。那里
在这方面没有区别。

## 将消息传递给使用者时会发生什么情况？

两件事：

1.  如果邮件从未传递给任何人，也就是说，如果我们谈论的是新邮件，则会创建一个PEL（待处理条目列表）。
2.  相反，如果消息已经传递给此使用者，并且它只是再次重新获取相同的消息，则*最后一个交付计数器*将更新为当前时间，并且*交货次数*递增 1。您可以使用`XPENDING`命令。

## 用法示例

通常，您使用这样的命令来获取新消息和
处理它们。在伪代码中：

    WHILE true
        entries = XREADGROUP GROUP $GroupName $ConsumerName BLOCK 2000 COUNT 10 STREAMS mystream >
        if entries == nil
            puts "Timeout... try again"
            CONTINUE
        end

        FOREACH entries AS stream_entries
            FOREACH stream_entries as message
                process_message(message.id,message.fields)

                # ACK the message as processed
                XACK mystream $GroupName message.id
            END
        END
    END

这样，示例消费者代码将仅获取新消息，处理
他们，并通过以下方式确认他们`XACK`.但是，上面的示例代码是
不完整，因为它无法处理崩溃后的恢复。什么
如果我们在处理消息的过程中崩溃，就会发生这种情况，是我们的
消息将保留在待处理条目列表中，因此我们可以访问我们的
历史通过给予`XREADGROUP`最初 ID 为 0，并执行相同的操作
圈。一旦提供ID为0，回复就是一组空消息，我们
知道我们处理并确认了所有待处理的消息：我们
可以开始使用`>`作为 ID，以便获取新消息并重新加入
正在处理新事物的消费者。

要查看该命令的实际回复方式，请检查`XREAD`命令页。

## 删除挂起的邮件后会发生什么情况？

由于修剪或显式调用`XDEL`在任何时候。
根据设计，Redis 不会阻止删除流 PEL 中存在的条目。
发生这种情况时，PEL 将保留已删除条目的 ID，但实际的条目有效负载不再可用。
因此，在读取此类 PEL 条目时，Redis 将返回一个空值来代替其各自的数据。

例：

    > XADD mystream 1 myfield mydata
    "1-0"
    > XGROUP CREATE mystream mygroup 0
    OK
    > XREADGROUP GROUP mygroup myconsumer STREAMS STREAMS mystream >
    1) 1) "mystream"
       2) 1) 1) "1-0"
             2) 1) "myfield"
                2) "mydata"
    > XDEL mystream 1-0
    (integer) 1
    > XREADGROUP GROUP mygroup myconsumer STREAMS STREAMS mystream 0
    1) 1) "mystream"
       2) 1) 1) "1-0"
             2) (nil)

@return

@array回复，具体而言：

该命令返回一个结果数组：返回的每个元素
array 是由包含键名和
为该密钥报告的条目。报告的条目是全流的
条目，具有 ID 以及所有字段和值的列表。字段和
保证以与添加值相同的顺序报告值
由`XADD`.

什么时候**块**，超时时返回空回复。

阅读[Redis Streams 介绍](/topics/streams-intro)是高度
建议，以便更多地了解流的整体行为
和语义。
